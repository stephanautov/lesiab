// path: lib/ai/flows/codegenFlow.ts
/**
 * Codegen Flow (LangGraph if available; otherwise a minimal pipeline fallback).
 *
 * Contract:
 *  - buildCodegenFlow({ writeFile, formatRepo }).invoke(request)
 *  - 'request' is any structured object with { profile, goals, constraints }.
 *  - Tools:
 *      writeFile({ path, content }): Promise<{ ok: true }>
 *      formatRepo(): Promise<{ ok: true }>
 */

export type WriteFile = (args: { path: string; content: string }) => Promise<{ ok: true }>;
export type FormatRepo = () => Promise<{ ok: true }>;

export type CodegenTools = { writeFile: WriteFile; formatRepo: FormatRepo };

export type CodegenRequest = {
  profile: { id: string; entities?: Array<{ name: string; table: string }> };
  goals?: string[];
  constraints?: Record<string, unknown>;
};

export type ProposedFile = { path: string; intent: "create" | "update" };
export type Synthesis = { path: string; content: string };

export type CodegenState = {
  request: CodegenRequest;
  proposed: ProposedFile[];
  synthesized: Synthesis[];
  verified: boolean;
};

function stableHash(input: string) {
  // Deterministic, simple FNV-1a like hash (not crypto).
  let h = 2166136261 >>> 0;
  for (let i = 0; i < input.length; i++) {
    h ^= input.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return ("0000000" + (h >>> 0).toString(16)).slice(-8);
}

/** Stage (a) — analyze */
export async function analyzeRequest(req: CodegenRequest): Promise<CodegenState> {
  return { request: req, proposed: [], synthesized: [], verified: false };
}

/** Stage (b) — propose files */
export async function proposeFiles(state: CodegenState): Promise<CodegenState> {
  const { request } = state;
  const base = [
    { path: "README.md", intent: "update" as const },
    { path: "app/(protected)/dashboard/page.tsx", intent: "create" as const },
  ];
  const entityFiles =
    (request.profile.entities ?? []).flatMap((e) => [
      { path: `server/trpc/${e.name}.router.ts`, intent: "create" as const },
      { path: `app/(protected)/${e.name}/page.tsx`, intent: "create" as const },
    ]);
  return { ...state, proposed: [...base, ...entityFiles] };
}

/** Stage (c) — synthesize content (deterministic, placeholder-safe) */
export async function synthesizeContent(state: CodegenState): Promise<CodegenState> {
  const out: Synthesis[] = state.proposed.map((f) => {
    if (f.path.endsWith("README.md")) {
      const id = state.request.profile.id || "app";
      const body = [
        "# Codegen Output",
        "",
        `Project: ${id}`,
        `Hash: ${stableHash(id)}`,
        "",
        "This file was proposed and synthesized by the codegen flow.",
      ].join("\n");
      return { path: f.path, content: body + "\n" };
    }
    if (f.path.endsWith("dashboard/page.tsx")) {
      const body = [
        "// path: app/(protected)/dashboard/page.tsx",
        "\"use client\";",
        "export default function Dashboard() {",
        "  return (",
        "    <div className=\"p-4\">",
        "      <h1 className=\"text-xl font-semibold\">Dashboard</h1>",
        "      <p className=\"text-sm text-neutral-600\">Generated by codegen flow.</p>",
        "    </div>",
        "  );",
        "}",
        "",
      ].join("\n");
      return { path: f.path, content: body };
    }
    // Fallback deterministic placeholders:
    const body = `// generated file: ${f.path}\n`;
    return { path: f.path, content: body };
  });
  return { ...state, synthesized: out };
}

/** Stage (d) — verify types (placeholder; real impl can shell out to tsc in CI) */
export async function verifyTypes(state: CodegenState): Promise<CodegenState> {
  // In-app verification avoids non-determinism; real type-checks happen in CI.
  return { ...state, verified: true };
}

/** ToolNodes wiring — write files then format repo */
async function applyTools(tools: CodegenTools, synthesized: Synthesis[]) {
  for (const s of synthesized) {
    await tools.writeFile({ path: s.path, content: s.content });
  }
  await tools.formatRepo();
}

/** Factory: LangGraph if present; otherwise run stages sequentially. */
export function buildCodegenFlow(tools: CodegenTools) {
  async function tryGraph() {
    try {
      // Dynamic import to avoid hard dependency during bootstrap
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const mod: any = await import("@langchain/langgraph");
      const StateGraph = mod.StateGraph ?? mod.ExperimentalStateGraph ?? null;
      const START = mod.START ?? "START";
      const END = mod.END ?? "END";
      if (!StateGraph) return null;

      const graph = new StateGraph<CodegenState>({ channels: {} })
        .addNode("analyzeRequest", analyzeRequest)
        .addNode("proposeFiles", proposeFiles)
        .addNode("synthesizeContent", synthesizeContent)
        .addNode("verifyTypes", verifyTypes)
        .addEdge("analyzeRequest", "proposeFiles")
        .addEdge("proposeFiles", "synthesizeContent")
        .addEdge("synthesizeContent", "verifyTypes")
        .addEdge("verifyTypes", END)
        .addEdge(START, "analyzeRequest")
        .compile();

      return {
        async invoke(req: CodegenRequest) {
          const result = await graph.invoke({ request: req, proposed: [], synthesized: [], verified: false });
          await applyTools(tools, result.synthesized);
          return result;
        }
      };
    } catch {
      return null;
    }
  }

  return {
    /** Run the codegen flow for a given request. */
    async invoke(req: CodegenRequest) {
      const g = await tryGraph();
      if (g) return g.invoke(req);
      // Fallback: run sequentially
      let s = await analyzeRequest(req);
      s = await proposeFiles(s);
      s = await synthesizeContent(s);
      s = await verifyTypes(s);
      await applyTools(tools, s.synthesized);
      return s;
    }
  };
}
