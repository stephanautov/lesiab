"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@trpc+server@11.5.0_typescript@5.9.2";
exports.ids = ["vendor-chunks/@trpc+server@11.5.0_typescript@5.9.2"];
exports.modules = {
  /***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs":
    /*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs ***!
  \***************************************************************************************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTP_CODE_TO_JSONRPC2: () => (/* binding */ HTTP_CODE_TO_JSONRPC2),\n/* harmony export */   JSONRPC2_TO_HTTP_CODE: () => (/* binding */ JSONRPC2_TO_HTTP_CODE),\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __toESM: () => (/* binding */ __toESM),\n/* harmony export */   createFlatProxy: () => (/* binding */ createFlatProxy),\n/* harmony export */   createRecursiveProxy: () => (/* binding */ createRecursiveProxy),\n/* harmony export */   getErrorShape: () => (/* binding */ getErrorShape),\n/* harmony export */   getHTTPStatusCode: () => (/* binding */ getHTTPStatusCode),\n/* harmony export */   getHTTPStatusCodeFromError: () => (/* binding */ getHTTPStatusCodeFromError),\n/* harmony export */   getStatusCodeFromKey: () => (/* binding */ getStatusCodeFromKey),\n/* harmony export */   getStatusKeyFromCode: () => (/* binding */ getStatusKeyFromCode),\n/* harmony export */   require_defineProperty: () => (/* binding */ require_defineProperty),\n/* harmony export */   require_objectSpread2: () => (/* binding */ require_objectSpread2)\n/* harmony export */ });\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs");\n\n\n//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function() {\n\treturn mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\n//#region src/unstable-core-do-not-import/createProxy.ts\nconst noop = () => {};\nconst freezeIfAvailable = (obj) => {\n\tif (Object.freeze) Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n\tvar _memo$cacheKey;\n\tconst cacheKey = path.join(".");\n\t(_memo$cacheKey = memo[cacheKey]) !== null && _memo$cacheKey !== void 0 || (memo[cacheKey] = new Proxy(noop, {\n\t\tget(_obj, key) {\n\t\t\tif (typeof key !== "string" || key === "then") return void 0;\n\t\t\treturn createInnerProxy(callback, [...path, key], memo);\n\t\t},\n\t\tapply(_1, _2, args) {\n\t\t\tconst lastOfPath = path[path.length - 1];\n\t\t\tlet opts = {\n\t\t\t\targs,\n\t\t\t\tpath\n\t\t\t};\n\t\t\tif (lastOfPath === "call") opts = {\n\t\t\t\targs: args.length >= 2 ? [args[1]] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\telse if (lastOfPath === "apply") opts = {\n\t\t\t\targs: args.length >= 2 ? args[1] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\tfreezeIfAvailable(opts.args);\n\t\t\tfreezeIfAvailable(opts.path);\n\t\t\treturn callback(opts);\n\t\t}\n\t}));\n\treturn memo[cacheKey];\n}\n/**\n* Creates a proxy that calls the callback with the path and arguments\n*\n* @internal\n*/\nconst createRecursiveProxy = (callback) => createInnerProxy(callback, [], Object.create(null));\n/**\n* Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n*\n* @internal\n*/\nconst createFlatProxy = (callback) => {\n\treturn new Proxy(noop, { get(_obj, name) {\n\t\tif (name === "then") return void 0;\n\t\treturn callback(name);\n\t} });\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/getHTTPStatusCode.ts\nconst JSONRPC2_TO_HTTP_CODE = {\n\tPARSE_ERROR: 400,\n\tBAD_REQUEST: 400,\n\tUNAUTHORIZED: 401,\n\tPAYMENT_REQUIRED: 402,\n\tFORBIDDEN: 403,\n\tNOT_FOUND: 404,\n\tMETHOD_NOT_SUPPORTED: 405,\n\tTIMEOUT: 408,\n\tCONFLICT: 409,\n\tPRECONDITION_FAILED: 412,\n\tPAYLOAD_TOO_LARGE: 413,\n\tUNSUPPORTED_MEDIA_TYPE: 415,\n\tUNPROCESSABLE_CONTENT: 422,\n\tTOO_MANY_REQUESTS: 429,\n\tCLIENT_CLOSED_REQUEST: 499,\n\tINTERNAL_SERVER_ERROR: 500,\n\tNOT_IMPLEMENTED: 501,\n\tBAD_GATEWAY: 502,\n\tSERVICE_UNAVAILABLE: 503,\n\tGATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n\t400: "BAD_REQUEST",\n\t401: "UNAUTHORIZED",\n\t402: "PAYMENT_REQUIRED",\n\t403: "FORBIDDEN",\n\t404: "NOT_FOUND",\n\t405: "METHOD_NOT_SUPPORTED",\n\t408: "TIMEOUT",\n\t409: "CONFLICT",\n\t412: "PRECONDITION_FAILED",\n\t413: "PAYLOAD_TOO_LARGE",\n\t415: "UNSUPPORTED_MEDIA_TYPE",\n\t422: "UNPROCESSABLE_CONTENT",\n\t429: "TOO_MANY_REQUESTS",\n\t499: "CLIENT_CLOSED_REQUEST",\n\t500: "INTERNAL_SERVER_ERROR",\n\t501: "NOT_IMPLEMENTED",\n\t502: "BAD_GATEWAY",\n\t503: "SERVICE_UNAVAILABLE",\n\t504: "GATEWAY_TIMEOUT"\n};\nfunction getStatusCodeFromKey(code) {\n\tvar _JSONRPC2_TO_HTTP_COD;\n\treturn (_JSONRPC2_TO_HTTP_COD = JSONRPC2_TO_HTTP_CODE[code]) !== null && _JSONRPC2_TO_HTTP_COD !== void 0 ? _JSONRPC2_TO_HTTP_COD : 500;\n}\nfunction getStatusKeyFromCode(code) {\n\tvar _HTTP_CODE_TO_JSONRPC;\n\treturn (_HTTP_CODE_TO_JSONRPC = HTTP_CODE_TO_JSONRPC2[code]) !== null && _HTTP_CODE_TO_JSONRPC !== void 0 ? _HTTP_CODE_TO_JSONRPC : "INTERNAL_SERVER_ERROR";\n}\nfunction getHTTPStatusCode(json) {\n\tconst arr = Array.isArray(json) ? json : [json];\n\tconst httpStatuses = new Set(arr.map((res) => {\n\t\tif ("error" in res && (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(res.error.data)) {\n\t\t\tvar _res$error$data;\n\t\t\tif (typeof ((_res$error$data = res.error.data) === null || _res$error$data === void 0 ? void 0 : _res$error$data["httpStatus"]) === "number") return res.error.data["httpStatus"];\n\t\t\tconst code = _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n\t\t\treturn getStatusCodeFromKey(code);\n\t\t}\n\t\treturn 200;\n\t}));\n\tif (httpStatuses.size !== 1) return 207;\n\tconst httpStatus = httpStatuses.values().next().value;\n\treturn httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n\treturn getStatusCodeFromKey(error.code);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\nvar require_typeof = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js"(exports, module) {\n\tfunction _typeof$2(o) {\n\t\t"@babel/helpers - typeof";\n\t\treturn module.exports = _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {\n\t\t\treturn typeof o$1;\n\t\t} : function(o$1) {\n\t\t\treturn o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;\n\t\t}, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof$2(o);\n\t}\n\tmodule.exports = _typeof$2, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\nvar require_toPrimitive = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js"(exports, module) {\n\tvar _typeof$1 = require_typeof()["default"];\n\tfunction toPrimitive$1(t, r) {\n\t\tif ("object" != _typeof$1(t) || !t) return t;\n\t\tvar e = t[Symbol.toPrimitive];\n\t\tif (void 0 !== e) {\n\t\t\tvar i = e.call(t, r || "default");\n\t\t\tif ("object" != _typeof$1(i)) return i;\n\t\t\tthrow new TypeError("@@toPrimitive must return a primitive value.");\n\t\t}\n\t\treturn ("string" === r ? String : Number)(t);\n\t}\n\tmodule.exports = toPrimitive$1, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\nvar require_toPropertyKey = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js"(exports, module) {\n\tvar _typeof = require_typeof()["default"];\n\tvar toPrimitive = require_toPrimitive();\n\tfunction toPropertyKey$1(t) {\n\t\tvar i = toPrimitive(t, "string");\n\t\treturn "symbol" == _typeof(i) ? i : i + "";\n\t}\n\tmodule.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\nvar require_defineProperty = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js"(exports, module) {\n\tvar toPropertyKey = require_toPropertyKey();\n\tfunction _defineProperty(e, r, t) {\n\t\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\t\tvalue: t,\n\t\t\tenumerable: !0,\n\t\t\tconfigurable: !0,\n\t\t\twritable: !0\n\t\t}) : e[r] = t, e;\n\t}\n\tmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\nvar require_objectSpread2 = __commonJS({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js"(exports, module) {\n\tvar defineProperty = require_defineProperty();\n\tfunction ownKeys(e, r) {\n\t\tvar t = Object.keys(e);\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tvar o = Object.getOwnPropertySymbols(e);\n\t\t\tr && (o = o.filter(function(r$1) {\n\t\t\t\treturn Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n\t\t\t})), t.push.apply(t, o);\n\t\t}\n\t\treturn t;\n\t}\n\tfunction _objectSpread2(e) {\n\t\tfor (var r = 1; r < arguments.length; r++) {\n\t\t\tvar t = null != arguments[r] ? arguments[r] : {};\n\t\t\tr % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n\t\t\t\tdefineProperty(e, r$1, t[r$1]);\n\t\t\t}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n\t\t\t\tObject.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n\t\t\t});\n\t\t}\n\t\treturn e;\n\t}\n\tmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/error/getErrorShape.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* @internal\n*/\nfunction getErrorShape(opts) {\n\tconst { path, error, config } = opts;\n\tconst { code } = opts.error;\n\tconst shape = {\n\t\tmessage: error.message,\n\t\tcode: _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_KEY[code],\n\t\tdata: {\n\t\t\tcode,\n\t\t\thttpStatus: getHTTPStatusCodeFromError(error)\n\t\t}\n\t};\n\tif (config.isDev && typeof opts.error.stack === "string") shape.data.stack = opts.error.stack;\n\tif (typeof path === "string") shape.data.path = path;\n\treturn config.errorFormatter((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, { shape }));\n}\n\n//#endregion\n\n//# sourceMappingURL=getErrorShape-Uhlrl4Bk.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9nZXRFcnJvclNoYXBlLVVobHJsNEJrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRzs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQSwySUFBMkksT0FBTztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZEQUFRO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQixTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBLFFBQVEsd0VBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLFdBQVcsSUFBSSxPQUFPO0FBQzFIOztBQUVBO0FBQzZRO0FBQzdRIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNlZ2d1XFxMRVNpQUJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB0cnBjK3NlcnZlckAxMS41LjBfdHlwZXNjcmlwdEA1LjkuMlxcbm9kZV9tb2R1bGVzXFxAdHJwY1xcc2VydmVyXFxkaXN0XFxnZXRFcnJvclNoYXBlLVVobHJsNEJrLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSwgVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVIsIGlzT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHMtRGRiYnJEa3UubWpzXCI7XG5cbi8vI3JlZ2lvbiByb2xsZG93bjpydW50aW1lXG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG5cdGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGtleXMgPSBfX2dldE93blByb3BOYW1lcyhmcm9tKSwgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbjsgaSsrKSB7XG5cdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KSBfX2RlZlByb3AodG8sIGtleSwge1xuXHRcdFx0Z2V0OiAoKGspID0+IGZyb21ba10pLmJpbmQobnVsbCwga2V5KSxcblx0XHRcdGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7XG5cdHZhbHVlOiBtb2QsXG5cdGVudW1lcmFibGU6IHRydWVcbn0pIDogdGFyZ2V0LCBtb2QpKTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9jcmVhdGVQcm94eS50c1xuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuY29uc3QgZnJlZXplSWZBdmFpbGFibGUgPSAob2JqKSA9PiB7XG5cdGlmIChPYmplY3QuZnJlZXplKSBPYmplY3QuZnJlZXplKG9iaik7XG59O1xuZnVuY3Rpb24gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgcGF0aCwgbWVtbykge1xuXHR2YXIgX21lbW8kY2FjaGVLZXk7XG5cdGNvbnN0IGNhY2hlS2V5ID0gcGF0aC5qb2luKFwiLlwiKTtcblx0KF9tZW1vJGNhY2hlS2V5ID0gbWVtb1tjYWNoZUtleV0pICE9PSBudWxsICYmIF9tZW1vJGNhY2hlS2V5ICE9PSB2b2lkIDAgfHwgKG1lbW9bY2FjaGVLZXldID0gbmV3IFByb3h5KG5vb3AsIHtcblx0XHRnZXQoX29iaiwga2V5KSB7XG5cdFx0XHRpZiAodHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIiB8fCBrZXkgPT09IFwidGhlblwiKSByZXR1cm4gdm9pZCAwO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUlubmVyUHJveHkoY2FsbGJhY2ssIFsuLi5wYXRoLCBrZXldLCBtZW1vKTtcblx0XHR9LFxuXHRcdGFwcGx5KF8xLCBfMiwgYXJncykge1xuXHRcdFx0Y29uc3QgbGFzdE9mUGF0aCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblx0XHRcdGxldCBvcHRzID0ge1xuXHRcdFx0XHRhcmdzLFxuXHRcdFx0XHRwYXRoXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGxhc3RPZlBhdGggPT09IFwiY2FsbFwiKSBvcHRzID0ge1xuXHRcdFx0XHRhcmdzOiBhcmdzLmxlbmd0aCA+PSAyID8gW2FyZ3NbMV1dIDogW10sXG5cdFx0XHRcdHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpXG5cdFx0XHR9O1xuXHRcdFx0ZWxzZSBpZiAobGFzdE9mUGF0aCA9PT0gXCJhcHBseVwiKSBvcHRzID0ge1xuXHRcdFx0XHRhcmdzOiBhcmdzLmxlbmd0aCA+PSAyID8gYXJnc1sxXSA6IFtdLFxuXHRcdFx0XHRwYXRoOiBwYXRoLnNsaWNlKDAsIC0xKVxuXHRcdFx0fTtcblx0XHRcdGZyZWV6ZUlmQXZhaWxhYmxlKG9wdHMuYXJncyk7XG5cdFx0XHRmcmVlemVJZkF2YWlsYWJsZShvcHRzLnBhdGgpO1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG9wdHMpO1xuXHRcdH1cblx0fSkpO1xuXHRyZXR1cm4gbWVtb1tjYWNoZUtleV07XG59XG4vKipcbiogQ3JlYXRlcyBhIHByb3h5IHRoYXQgY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHBhdGggYW5kIGFyZ3VtZW50c1xuKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBjcmVhdGVSZWN1cnNpdmVQcm94eSA9IChjYWxsYmFjaykgPT4gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgW10sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuLyoqXG4qIFVzZWQgaW4gcGxhY2Ugb2YgYG5ldyBQcm94eWAgd2hlcmUgZWFjaCBoYW5kbGVyIHdpbGwgbWFwIDEgbGV2ZWwgZGVlcCB0byBhbm90aGVyIHZhbHVlLlxuKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBjcmVhdGVGbGF0UHJveHkgPSAoY2FsbGJhY2spID0+IHtcblx0cmV0dXJuIG5ldyBQcm94eShub29wLCB7IGdldChfb2JqLCBuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09IFwidGhlblwiKSByZXR1cm4gdm9pZCAwO1xuXHRcdHJldHVybiBjYWxsYmFjayhuYW1lKTtcblx0fSB9KTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9nZXRIVFRQU3RhdHVzQ29kZS50c1xuY29uc3QgSlNPTlJQQzJfVE9fSFRUUF9DT0RFID0ge1xuXHRQQVJTRV9FUlJPUjogNDAwLFxuXHRCQURfUkVRVUVTVDogNDAwLFxuXHRVTkFVVEhPUklaRUQ6IDQwMSxcblx0UEFZTUVOVF9SRVFVSVJFRDogNDAyLFxuXHRGT1JCSURERU46IDQwMyxcblx0Tk9UX0ZPVU5EOiA0MDQsXG5cdE1FVEhPRF9OT1RfU1VQUE9SVEVEOiA0MDUsXG5cdFRJTUVPVVQ6IDQwOCxcblx0Q09ORkxJQ1Q6IDQwOSxcblx0UFJFQ09ORElUSU9OX0ZBSUxFRDogNDEyLFxuXHRQQVlMT0FEX1RPT19MQVJHRTogNDEzLFxuXHRVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiA0MTUsXG5cdFVOUFJPQ0VTU0FCTEVfQ09OVEVOVDogNDIyLFxuXHRUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuXHRDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IDQ5OSxcblx0SU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG5cdE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuXHRCQURfR0FURVdBWTogNTAyLFxuXHRTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG5cdEdBVEVXQVlfVElNRU9VVDogNTA0XG59O1xuY29uc3QgSFRUUF9DT0RFX1RPX0pTT05SUEMyID0ge1xuXHQ0MDA6IFwiQkFEX1JFUVVFU1RcIixcblx0NDAxOiBcIlVOQVVUSE9SSVpFRFwiLFxuXHQ0MDI6IFwiUEFZTUVOVF9SRVFVSVJFRFwiLFxuXHQ0MDM6IFwiRk9SQklEREVOXCIsXG5cdDQwNDogXCJOT1RfRk9VTkRcIixcblx0NDA1OiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdDQwODogXCJUSU1FT1VUXCIsXG5cdDQwOTogXCJDT05GTElDVFwiLFxuXHQ0MTI6IFwiUFJFQ09ORElUSU9OX0ZBSUxFRFwiLFxuXHQ0MTM6IFwiUEFZTE9BRF9UT09fTEFSR0VcIixcblx0NDE1OiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0NDIyOiBcIlVOUFJPQ0VTU0FCTEVfQ09OVEVOVFwiLFxuXHQ0Mjk6IFwiVE9PX01BTllfUkVRVUVTVFNcIixcblx0NDk5OiBcIkNMSUVOVF9DTE9TRURfUkVRVUVTVFwiLFxuXHQ1MDA6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG5cdDUwMTogXCJOT1RfSU1QTEVNRU5URURcIixcblx0NTAyOiBcIkJBRF9HQVRFV0FZXCIsXG5cdDUwMzogXCJTRVJWSUNFX1VOQVZBSUxBQkxFXCIsXG5cdDUwNDogXCJHQVRFV0FZX1RJTUVPVVRcIlxufTtcbmZ1bmN0aW9uIGdldFN0YXR1c0NvZGVGcm9tS2V5KGNvZGUpIHtcblx0dmFyIF9KU09OUlBDMl9UT19IVFRQX0NPRDtcblx0cmV0dXJuIChfSlNPTlJQQzJfVE9fSFRUUF9DT0QgPSBKU09OUlBDMl9UT19IVFRQX0NPREVbY29kZV0pICE9PSBudWxsICYmIF9KU09OUlBDMl9UT19IVFRQX0NPRCAhPT0gdm9pZCAwID8gX0pTT05SUEMyX1RPX0hUVFBfQ09EIDogNTAwO1xufVxuZnVuY3Rpb24gZ2V0U3RhdHVzS2V5RnJvbUNvZGUoY29kZSkge1xuXHR2YXIgX0hUVFBfQ09ERV9UT19KU09OUlBDO1xuXHRyZXR1cm4gKF9IVFRQX0NPREVfVE9fSlNPTlJQQyA9IEhUVFBfQ09ERV9UT19KU09OUlBDMltjb2RlXSkgIT09IG51bGwgJiYgX0hUVFBfQ09ERV9UT19KU09OUlBDICE9PSB2b2lkIDAgPyBfSFRUUF9DT0RFX1RPX0pTT05SUEMgOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiO1xufVxuZnVuY3Rpb24gZ2V0SFRUUFN0YXR1c0NvZGUoanNvbikge1xuXHRjb25zdCBhcnIgPSBBcnJheS5pc0FycmF5KGpzb24pID8ganNvbiA6IFtqc29uXTtcblx0Y29uc3QgaHR0cFN0YXR1c2VzID0gbmV3IFNldChhcnIubWFwKChyZXMpID0+IHtcblx0XHRpZiAoXCJlcnJvclwiIGluIHJlcyAmJiBpc09iamVjdChyZXMuZXJyb3IuZGF0YSkpIHtcblx0XHRcdHZhciBfcmVzJGVycm9yJGRhdGE7XG5cdFx0XHRpZiAodHlwZW9mICgoX3JlcyRlcnJvciRkYXRhID0gcmVzLmVycm9yLmRhdGEpID09PSBudWxsIHx8IF9yZXMkZXJyb3IkZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvciRkYXRhW1wiaHR0cFN0YXR1c1wiXSkgPT09IFwibnVtYmVyXCIpIHJldHVybiByZXMuZXJyb3IuZGF0YVtcImh0dHBTdGF0dXNcIl07XG5cdFx0XHRjb25zdCBjb2RlID0gVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVJbcmVzLmVycm9yLmNvZGVdO1xuXHRcdFx0cmV0dXJuIGdldFN0YXR1c0NvZGVGcm9tS2V5KGNvZGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gMjAwO1xuXHR9KSk7XG5cdGlmIChodHRwU3RhdHVzZXMuc2l6ZSAhPT0gMSkgcmV0dXJuIDIwNztcblx0Y29uc3QgaHR0cFN0YXR1cyA9IGh0dHBTdGF0dXNlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cdHJldHVybiBodHRwU3RhdHVzO1xufVxuZnVuY3Rpb24gZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIGdldFN0YXR1c0NvZGVGcm9tS2V5KGVycm9yLmNvZGUpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90eXBlb2YuanNcbnZhciByZXF1aXJlX3R5cGVvZiA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3R5cGVvZi5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHRmdW5jdGlvbiBfdHlwZW9mJDIobykge1xuXHRcdFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mJDIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvJDEpIHtcblx0XHRcdHJldHVybiB0eXBlb2YgbyQxO1xuXHRcdH0gOiBmdW5jdGlvbihvJDEpIHtcblx0XHRcdHJldHVybiBvJDEgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgbyQxLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyQxICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvJDE7XG5cdFx0fSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfdHlwZW9mJDIobyk7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mJDIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXG52YXIgcmVxdWlyZV90b1ByaW1pdGl2ZSA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBfdHlwZW9mJDEgPSByZXF1aXJlX3R5cGVvZigpW1wiZGVmYXVsdFwiXTtcblx0ZnVuY3Rpb24gdG9QcmltaXRpdmUkMSh0LCByKSB7XG5cdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZiQxKHQpIHx8ICF0KSByZXR1cm4gdDtcblx0XHR2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblx0XHRpZiAodm9pZCAwICE9PSBlKSB7XG5cdFx0XHR2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcblx0XHRcdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YkMShpKSkgcmV0dXJuIGk7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG5cdFx0fVxuXHRcdHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSB0b1ByaW1pdGl2ZSQxLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXG52YXIgcmVxdWlyZV90b1Byb3BlcnR5S2V5ID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgX3R5cGVvZiA9IHJlcXVpcmVfdHlwZW9mKClbXCJkZWZhdWx0XCJdO1xuXHR2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlX3RvUHJpbWl0aXZlKCk7XG5cdGZ1bmN0aW9uIHRvUHJvcGVydHlLZXkkMSh0KSB7XG5cdFx0dmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcblx0XHRyZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gdG9Qcm9wZXJ0eUtleSQxLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xudmFyIHJlcXVpcmVfZGVmaW5lUHJvcGVydHkgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmVfdG9Qcm9wZXJ0eUtleSgpO1xuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuXHRcdHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuXHRcdFx0dmFsdWU6IHQsXG5cdFx0XHRlbnVtZXJhYmxlOiAhMCxcblx0XHRcdGNvbmZpZ3VyYWJsZTogITAsXG5cdFx0XHR3cml0YWJsZTogITBcblx0XHR9KSA6IGVbcl0gPSB0LCBlO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzXG52YXIgcmVxdWlyZV9vYmplY3RTcHJlYWQyID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvb2JqZWN0U3ByZWFkMi5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlX2RlZmluZVByb3BlcnR5KCk7XG5cdGZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuXHRcdHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcblx0XHRcdHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgciQxKS5lbnVtZXJhYmxlO1xuXHRcdFx0fSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG5cdFx0fVxuXHRcdHJldHVybiB0O1xuXHR9XG5cdGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcblx0XHRmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuXHRcdFx0dmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuXHRcdFx0ciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KGUsIHIkMSwgdFtyJDFdKTtcblx0XHRcdH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIkMSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByJDEpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gZTtcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RTcHJlYWQyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL2dldEVycm9yU2hhcGUudHNcbnZhciBpbXBvcnRfb2JqZWN0U3ByZWFkMiA9IF9fdG9FU00ocmVxdWlyZV9vYmplY3RTcHJlYWQyKCksIDEpO1xuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGdldEVycm9yU2hhcGUob3B0cykge1xuXHRjb25zdCB7IHBhdGgsIGVycm9yLCBjb25maWcgfSA9IG9wdHM7XG5cdGNvbnN0IHsgY29kZSB9ID0gb3B0cy5lcnJvcjtcblx0Y29uc3Qgc2hhcGUgPSB7XG5cdFx0bWVzc2FnZTogZXJyb3IubWVzc2FnZSxcblx0XHRjb2RlOiBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWVtjb2RlXSxcblx0XHRkYXRhOiB7XG5cdFx0XHRjb2RlLFxuXHRcdFx0aHR0cFN0YXR1czogZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3IpXG5cdFx0fVxuXHR9O1xuXHRpZiAoY29uZmlnLmlzRGV2ICYmIHR5cGVvZiBvcHRzLmVycm9yLnN0YWNrID09PSBcInN0cmluZ1wiKSBzaGFwZS5kYXRhLnN0YWNrID0gb3B0cy5lcnJvci5zdGFjaztcblx0aWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKSBzaGFwZS5kYXRhLnBhdGggPSBwYXRoO1xuXHRyZXR1cm4gY29uZmlnLmVycm9yRm9ybWF0dGVyKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIG9wdHMpLCB7fSwgeyBzaGFwZSB9KSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgSFRUUF9DT0RFX1RPX0pTT05SUEMyLCBKU09OUlBDMl9UT19IVFRQX0NPREUsIF9fY29tbW9uSlMsIF9fdG9FU00sIGNyZWF0ZUZsYXRQcm94eSwgY3JlYXRlUmVjdXJzaXZlUHJveHksIGdldEVycm9yU2hhcGUsIGdldEhUVFBTdGF0dXNDb2RlLCBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvciwgZ2V0U3RhdHVzQ29kZUZyb21LZXksIGdldFN0YXR1c0tleUZyb21Db2RlLCByZXF1aXJlX2RlZmluZVByb3BlcnR5LCByZXF1aXJlX29iamVjdFNwcmVhZDIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEVycm9yU2hhcGUtVWhscmw0QmsubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\n',
      );

      /***/
    },

  /***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs":
    /*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs ***!
  \************************************************************************************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   behaviorSubject: () => (/* binding */ behaviorSubject),\n/* harmony export */   distinctUntilChanged: () => (/* binding */ distinctUntilChanged),\n/* harmony export */   distinctUntilDeepChanged: () => (/* binding */ distinctUntilDeepChanged),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   share: () => (/* binding */ share),\n/* harmony export */   tap: () => (/* binding */ tap)\n/* harmony export */ });\n/* harmony import */ var _observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observable-UMO3vUa_.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs");\n\n\n//#region src/observable/operators.ts\nfunction map(project) {\n\treturn (source) => {\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\tlet index = 0;\n\t\t\tconst subscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tdestination.next(project(value, index++));\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn subscription;\n\t\t});\n\t};\n}\nfunction share(_opts) {\n\treturn (source) => {\n\t\tlet refCount = 0;\n\t\tlet subscription = null;\n\t\tconst observers = [];\n\t\tfunction startIfNeeded() {\n\t\t\tif (subscription) return;\n\t\t\tsubscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$next;\n\t\t\t\t\t\t(_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$error;\n\t\t\t\t\t\t(_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$complete;\n\t\t\t\t\t\t(_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction resetIfNeeded() {\n\t\t\tif (refCount === 0 && subscription) {\n\t\t\t\tconst _sub = subscription;\n\t\t\t\tsubscription = null;\n\t\t\t\t_sub.unsubscribe();\n\t\t\t}\n\t\t}\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((subscriber) => {\n\t\t\trefCount++;\n\t\t\tobservers.push(subscriber);\n\t\t\tstartIfNeeded();\n\t\t\treturn { unsubscribe() {\n\t\t\t\trefCount--;\n\t\t\t\tresetIfNeeded();\n\t\t\t\tconst index = observers.findIndex((v) => v === subscriber);\n\t\t\t\tif (index > -1) observers.splice(index, 1);\n\t\t\t} };\n\t\t});\n\t};\n}\nfunction tap(observer) {\n\treturn (source) => {\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tvar _observer$next2;\n\t\t\t\t\t(_observer$next2 = observer.next) === null || _observer$next2 === void 0 || _observer$next2.call(observer, value);\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tvar _observer$error2;\n\t\t\t\t\t(_observer$error2 = observer.error) === null || _observer$error2 === void 0 || _observer$error2.call(observer, error);\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tvar _observer$complete2;\n\t\t\t\t\t(_observer$complete2 = observer.complete) === null || _observer$complete2 === void 0 || _observer$complete2.call(observer);\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst distinctUnsetMarker = Symbol();\nfunction distinctUntilChanged(compare = (a, b) => a === b) {\n\treturn (source) => {\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\tlet lastValue = distinctUnsetMarker;\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tif (lastValue !== distinctUnsetMarker && compare(lastValue, value)) return;\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst isDeepEqual = (a, b) => {\n\tif (a === b) return true;\n\tconst bothAreObjects = a && b && typeof a === "object" && typeof b === "object";\n\treturn !!bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v]) => isDeepEqual(v, b[k]));\n};\nfunction distinctUntilDeepChanged() {\n\treturn distinctUntilChanged(isDeepEqual);\n}\n\n//#endregion\n//#region src/observable/behaviorSubject.ts\n/**\n* @internal\n* An observable that maintains and provides a "current value" to subscribers\n* @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n*/\nfunction behaviorSubject(initialValue) {\n\tlet value = initialValue;\n\tconst observerList = [];\n\tconst addObserver = (observer) => {\n\t\tif (value !== void 0) observer.next(value);\n\t\tobserverList.push(observer);\n\t};\n\tconst removeObserver = (observer) => {\n\t\tobserverList.splice(observerList.indexOf(observer), 1);\n\t};\n\tconst obs = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((observer) => {\n\t\taddObserver(observer);\n\t\treturn () => {\n\t\t\tremoveObserver(observer);\n\t\t};\n\t});\n\tobs.next = (nextValue) => {\n\t\tif (value === nextValue) return;\n\t\tvalue = nextValue;\n\t\tfor (const observer of observerList) observer.next(nextValue);\n\t};\n\tobs.get = () => value;\n\treturn obs;\n}\n\n//#endregion\n\n//# sourceMappingURL=observable-CUiPknO-.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLUNVaVBrbk8tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1FQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1FQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEY7QUFDNUYiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2VnZ3VcXExFU2lBQlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yXFxub2RlX21vZHVsZXNcXEB0cnBjXFxzZXJ2ZXJcXGRpc3RcXG9ic2VydmFibGUtQ1VpUGtuTy0ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9ic2VydmFibGUgfSBmcm9tIFwiLi9vYnNlcnZhYmxlLVVNTzN2VWFfLm1qc1wiO1xuXG4vLyNyZWdpb24gc3JjL29ic2VydmFibGUvb3BlcmF0b3JzLnRzXG5mdW5jdGlvbiBtYXAocHJvamVjdCkge1xuXHRyZXR1cm4gKHNvdXJjZSkgPT4ge1xuXHRcdHJldHVybiBvYnNlcnZhYmxlKChkZXN0aW5hdGlvbikgPT4ge1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoe1xuXHRcdFx0XHRuZXh0KHZhbHVlKSB7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24ubmV4dChwcm9qZWN0KHZhbHVlLCBpbmRleCsrKSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yKGVycm9yKSB7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzdWJzY3JpcHRpb247XG5cdFx0fSk7XG5cdH07XG59XG5mdW5jdGlvbiBzaGFyZShfb3B0cykge1xuXHRyZXR1cm4gKHNvdXJjZSkgPT4ge1xuXHRcdGxldCByZWZDb3VudCA9IDA7XG5cdFx0bGV0IHN1YnNjcmlwdGlvbiA9IG51bGw7XG5cdFx0Y29uc3Qgb2JzZXJ2ZXJzID0gW107XG5cdFx0ZnVuY3Rpb24gc3RhcnRJZk5lZWRlZCgpIHtcblx0XHRcdGlmIChzdWJzY3JpcHRpb24pIHJldHVybjtcblx0XHRcdHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoe1xuXHRcdFx0XHRuZXh0KHZhbHVlKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpIHtcblx0XHRcdFx0XHRcdHZhciBfb2JzZXJ2ZXIkbmV4dDtcblx0XHRcdFx0XHRcdChfb2JzZXJ2ZXIkbmV4dCA9IG9ic2VydmVyLm5leHQpID09PSBudWxsIHx8IF9vYnNlcnZlciRuZXh0ID09PSB2b2lkIDAgfHwgX29ic2VydmVyJG5leHQuY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycykge1xuXHRcdFx0XHRcdFx0dmFyIF9vYnNlcnZlciRlcnJvcjtcblx0XHRcdFx0XHRcdChfb2JzZXJ2ZXIkZXJyb3IgPSBvYnNlcnZlci5lcnJvcikgPT09IG51bGwgfHwgX29ic2VydmVyJGVycm9yID09PSB2b2lkIDAgfHwgX29ic2VydmVyJGVycm9yLmNhbGwob2JzZXJ2ZXIsIGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2Ygb2JzZXJ2ZXJzKSB7XG5cdFx0XHRcdFx0XHR2YXIgX29ic2VydmVyJGNvbXBsZXRlO1xuXHRcdFx0XHRcdFx0KF9vYnNlcnZlciRjb21wbGV0ZSA9IG9ic2VydmVyLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkY29tcGxldGUgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkY29tcGxldGUuY2FsbChvYnNlcnZlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gcmVzZXRJZk5lZWRlZCgpIHtcblx0XHRcdGlmIChyZWZDb3VudCA9PT0gMCAmJiBzdWJzY3JpcHRpb24pIHtcblx0XHRcdFx0Y29uc3QgX3N1YiA9IHN1YnNjcmlwdGlvbjtcblx0XHRcdFx0c3Vic2NyaXB0aW9uID0gbnVsbDtcblx0XHRcdFx0X3N1Yi51bnN1YnNjcmliZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb2JzZXJ2YWJsZSgoc3Vic2NyaWJlcikgPT4ge1xuXHRcdFx0cmVmQ291bnQrKztcblx0XHRcdG9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuXHRcdFx0c3RhcnRJZk5lZWRlZCgpO1xuXHRcdFx0cmV0dXJuIHsgdW5zdWJzY3JpYmUoKSB7XG5cdFx0XHRcdHJlZkNvdW50LS07XG5cdFx0XHRcdHJlc2V0SWZOZWVkZWQoKTtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBvYnNlcnZlcnMuZmluZEluZGV4KCh2KSA9PiB2ID09PSBzdWJzY3JpYmVyKTtcblx0XHRcdFx0aWYgKGluZGV4ID4gLTEpIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fSB9O1xuXHRcdH0pO1xuXHR9O1xufVxuZnVuY3Rpb24gdGFwKG9ic2VydmVyKSB7XG5cdHJldHVybiAoc291cmNlKSA9PiB7XG5cdFx0cmV0dXJuIG9ic2VydmFibGUoKGRlc3RpbmF0aW9uKSA9PiB7XG5cdFx0XHRyZXR1cm4gc291cmNlLnN1YnNjcmliZSh7XG5cdFx0XHRcdG5leHQodmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgX29ic2VydmVyJG5leHQyO1xuXHRcdFx0XHRcdChfb2JzZXJ2ZXIkbmV4dDIgPSBvYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkbmV4dDIgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkbmV4dDIuY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcihlcnJvcikge1xuXHRcdFx0XHRcdHZhciBfb2JzZXJ2ZXIkZXJyb3IyO1xuXHRcdFx0XHRcdChfb2JzZXJ2ZXIkZXJyb3IyID0gb2JzZXJ2ZXIuZXJyb3IpID09PSBudWxsIHx8IF9vYnNlcnZlciRlcnJvcjIgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkZXJyb3IyLmNhbGwob2JzZXJ2ZXIsIGVycm9yKTtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdHZhciBfb2JzZXJ2ZXIkY29tcGxldGUyO1xuXHRcdFx0XHRcdChfb2JzZXJ2ZXIkY29tcGxldGUyID0gb2JzZXJ2ZXIuY29tcGxldGUpID09PSBudWxsIHx8IF9vYnNlcnZlciRjb21wbGV0ZTIgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkY29tcGxldGUyLmNhbGwob2JzZXJ2ZXIpO1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xufVxuY29uc3QgZGlzdGluY3RVbnNldE1hcmtlciA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbENoYW5nZWQoY29tcGFyZSA9IChhLCBiKSA9PiBhID09PSBiKSB7XG5cdHJldHVybiAoc291cmNlKSA9PiB7XG5cdFx0cmV0dXJuIG9ic2VydmFibGUoKGRlc3RpbmF0aW9uKSA9PiB7XG5cdFx0XHRsZXQgbGFzdFZhbHVlID0gZGlzdGluY3RVbnNldE1hcmtlcjtcblx0XHRcdHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dCh2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChsYXN0VmFsdWUgIT09IGRpc3RpbmN0VW5zZXRNYXJrZXIgJiYgY29tcGFyZShsYXN0VmFsdWUsIHZhbHVlKSkgcmV0dXJuO1xuXHRcdFx0XHRcdGxhc3RWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcihlcnJvcikge1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29tcGxldGUoKSB7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24uY29tcGxldGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH07XG59XG5jb25zdCBpc0RlZXBFcXVhbCA9IChhLCBiKSA9PiB7XG5cdGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblx0Y29uc3QgYm90aEFyZU9iamVjdHMgPSBhICYmIGIgJiYgdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT09IFwib2JqZWN0XCI7XG5cdHJldHVybiAhIWJvdGhBcmVPYmplY3RzICYmIE9iamVjdC5rZXlzKGEpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMoYikubGVuZ3RoICYmIE9iamVjdC5lbnRyaWVzKGEpLmV2ZXJ5KChbaywgdl0pID0+IGlzRGVlcEVxdWFsKHYsIGJba10pKTtcbn07XG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsRGVlcENoYW5nZWQoKSB7XG5cdHJldHVybiBkaXN0aW5jdFVudGlsQ2hhbmdlZChpc0RlZXBFcXVhbCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9vYnNlcnZhYmxlL2JlaGF2aW9yU3ViamVjdC50c1xuLyoqXG4qIEBpbnRlcm5hbFxuKiBBbiBvYnNlcnZhYmxlIHRoYXQgbWFpbnRhaW5zIGFuZCBwcm92aWRlcyBhIFwiY3VycmVudCB2YWx1ZVwiIHRvIHN1YnNjcmliZXJzXG4qIEBzZWUgaHR0cHM6Ly93d3cubGVhcm5yeGpzLmlvL2xlYXJuLXJ4anMvc3ViamVjdHMvYmVoYXZpb3JzdWJqZWN0XG4qL1xuZnVuY3Rpb24gYmVoYXZpb3JTdWJqZWN0KGluaXRpYWxWYWx1ZSkge1xuXHRsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cdGNvbnN0IG9ic2VydmVyTGlzdCA9IFtdO1xuXHRjb25zdCBhZGRPYnNlcnZlciA9IChvYnNlcnZlcikgPT4ge1xuXHRcdGlmICh2YWx1ZSAhPT0gdm9pZCAwKSBvYnNlcnZlci5uZXh0KHZhbHVlKTtcblx0XHRvYnNlcnZlckxpc3QucHVzaChvYnNlcnZlcik7XG5cdH07XG5cdGNvbnN0IHJlbW92ZU9ic2VydmVyID0gKG9ic2VydmVyKSA9PiB7XG5cdFx0b2JzZXJ2ZXJMaXN0LnNwbGljZShvYnNlcnZlckxpc3QuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuXHR9O1xuXHRjb25zdCBvYnMgPSBvYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuXHRcdGFkZE9ic2VydmVyKG9ic2VydmVyKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0cmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuXHRcdH07XG5cdH0pO1xuXHRvYnMubmV4dCA9IChuZXh0VmFsdWUpID0+IHtcblx0XHRpZiAodmFsdWUgPT09IG5leHRWYWx1ZSkgcmV0dXJuO1xuXHRcdHZhbHVlID0gbmV4dFZhbHVlO1xuXHRcdGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2Ygb2JzZXJ2ZXJMaXN0KSBvYnNlcnZlci5uZXh0KG5leHRWYWx1ZSk7XG5cdH07XG5cdG9icy5nZXQgPSAoKSA9PiB2YWx1ZTtcblx0cmV0dXJuIG9icztcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBiZWhhdmlvclN1YmplY3QsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBkaXN0aW5jdFVudGlsRGVlcENoYW5nZWQsIG1hcCwgc2hhcmUsIHRhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS1DVWlQa25PLS5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs\n',
      );

      /***/
    },

  /***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs":
    /*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs ***!
  \************************************************************************************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observableToAsyncIterable: () => (/* binding */ observableToAsyncIterable),\n/* harmony export */   observableToPromise: () => (/* binding */ observableToPromise)\n/* harmony export */ });\n//#region src/observable/observable.ts\n/** @public */\nfunction isObservable(x) {\n\treturn typeof x === "object" && x !== null && "subscribe" in x;\n}\n/** @public */\nfunction observable(subscribe) {\n\tconst self = {\n\t\tsubscribe(observer) {\n\t\t\tlet teardownRef = null;\n\t\t\tlet isDone = false;\n\t\t\tlet unsubscribed = false;\n\t\t\tlet teardownImmediately = false;\n\t\t\tfunction unsubscribe() {\n\t\t\t\tif (teardownRef === null) {\n\t\t\t\t\tteardownImmediately = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (unsubscribed) return;\n\t\t\t\tunsubscribed = true;\n\t\t\t\tif (typeof teardownRef === "function") teardownRef();\n\t\t\t\telse if (teardownRef) teardownRef.unsubscribe();\n\t\t\t}\n\t\t\tteardownRef = subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tvar _observer$next;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\t(_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n\t\t\t\t},\n\t\t\t\terror(err) {\n\t\t\t\t\tvar _observer$error;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\t(_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, err);\n\t\t\t\t\tunsubscribe();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tvar _observer$complete;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\t(_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n\t\t\t\t\tunsubscribe();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (teardownImmediately) unsubscribe();\n\t\t\treturn { unsubscribe };\n\t\t},\n\t\tpipe(...operations) {\n\t\t\treturn operations.reduce(pipeReducer, self);\n\t\t}\n\t};\n\treturn self;\n}\nfunction pipeReducer(prev, fn) {\n\treturn fn(prev);\n}\n/** @internal */\nfunction observableToPromise(observable$1) {\n\tconst ac = new AbortController();\n\tconst promise = new Promise((resolve, reject) => {\n\t\tlet isDone = false;\n\t\tfunction onDone() {\n\t\t\tif (isDone) return;\n\t\t\tisDone = true;\n\t\t\tobs$.unsubscribe();\n\t\t}\n\t\tac.signal.addEventListener("abort", () => {\n\t\t\treject(ac.signal.reason);\n\t\t});\n\t\tconst obs$ = observable$1.subscribe({\n\t\t\tnext(data) {\n\t\t\t\tisDone = true;\n\t\t\t\tresolve(data);\n\t\t\t\tonDone();\n\t\t\t},\n\t\t\terror(data) {\n\t\t\t\treject(data);\n\t\t\t},\n\t\t\tcomplete() {\n\t\t\t\tac.abort();\n\t\t\t\tonDone();\n\t\t\t}\n\t\t});\n\t});\n\treturn promise;\n}\n/**\n* @internal\n*/\nfunction observableToReadableStream(observable$1, signal) {\n\tlet unsub = null;\n\tconst onAbort = () => {\n\t\tunsub === null || unsub === void 0 || unsub.unsubscribe();\n\t\tunsub = null;\n\t\tsignal.removeEventListener("abort", onAbort);\n\t};\n\treturn new ReadableStream({\n\t\tstart(controller) {\n\t\t\tunsub = observable$1.subscribe({\n\t\t\t\tnext(data) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: true,\n\t\t\t\t\t\tvalue: data\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: false,\n\t\t\t\t\t\terror\n\t\t\t\t\t});\n\t\t\t\t\tcontroller.close();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener("abort", onAbort, { once: true });\n\t\t},\n\t\tcancel() {\n\t\t\tonAbort();\n\t\t}\n\t});\n}\n/** @internal */\nfunction observableToAsyncIterable(observable$1, signal) {\n\tconst stream = observableToReadableStream(observable$1, signal);\n\tconst reader = stream.getReader();\n\tconst iterator = {\n\t\tasync next() {\n\t\t\tconst value = await reader.read();\n\t\t\tif (value.done) return {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t\tconst { value: result } = value;\n\t\t\tif (!result.ok) throw result.error;\n\t\t\treturn {\n\t\t\t\tvalue: result.value,\n\t\t\t\tdone: false\n\t\t\t};\n\t\t},\n\t\tasync return() {\n\t\t\tawait reader.cancel();\n\t\t\treturn {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\t};\n\treturn { [Symbol.asyncIterator]() {\n\t\treturn iterator;\n\t} };\n}\n\n//#endregion\n\n//# sourceMappingURL=observable-UMO3vUa_.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLVVNTzN2VWFfLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ29GO0FBQ3BGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNlZ2d1XFxMRVNpQUJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB0cnBjK3NlcnZlckAxMS41LjBfdHlwZXNjcmlwdEA1LjkuMlxcbm9kZV9tb2R1bGVzXFxAdHJwY1xcc2VydmVyXFxkaXN0XFxvYnNlcnZhYmxlLVVNTzN2VWFfLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL29ic2VydmFibGUvb2JzZXJ2YWJsZS50c1xuLyoqIEBwdWJsaWMgKi9cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh4KSB7XG5cdHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsICYmIFwic3Vic2NyaWJlXCIgaW4geDtcbn1cbi8qKiBAcHVibGljICovXG5mdW5jdGlvbiBvYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuXHRjb25zdCBzZWxmID0ge1xuXHRcdHN1YnNjcmliZShvYnNlcnZlcikge1xuXHRcdFx0bGV0IHRlYXJkb3duUmVmID0gbnVsbDtcblx0XHRcdGxldCBpc0RvbmUgPSBmYWxzZTtcblx0XHRcdGxldCB1bnN1YnNjcmliZWQgPSBmYWxzZTtcblx0XHRcdGxldCB0ZWFyZG93bkltbWVkaWF0ZWx5ID0gZmFsc2U7XG5cdFx0XHRmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcblx0XHRcdFx0aWYgKHRlYXJkb3duUmVmID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGVhcmRvd25JbW1lZGlhdGVseSA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh1bnN1YnNjcmliZWQpIHJldHVybjtcblx0XHRcdFx0dW5zdWJzY3JpYmVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHR5cGVvZiB0ZWFyZG93blJlZiA9PT0gXCJmdW5jdGlvblwiKSB0ZWFyZG93blJlZigpO1xuXHRcdFx0XHRlbHNlIGlmICh0ZWFyZG93blJlZikgdGVhcmRvd25SZWYudW5zdWJzY3JpYmUoKTtcblx0XHRcdH1cblx0XHRcdHRlYXJkb3duUmVmID0gc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dCh2YWx1ZSkge1xuXHRcdFx0XHRcdHZhciBfb2JzZXJ2ZXIkbmV4dDtcblx0XHRcdFx0XHRpZiAoaXNEb25lKSByZXR1cm47XG5cdFx0XHRcdFx0KF9vYnNlcnZlciRuZXh0ID0gb2JzZXJ2ZXIubmV4dCkgPT09IG51bGwgfHwgX29ic2VydmVyJG5leHQgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkbmV4dC5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yKGVycikge1xuXHRcdFx0XHRcdHZhciBfb2JzZXJ2ZXIkZXJyb3I7XG5cdFx0XHRcdFx0aWYgKGlzRG9uZSkgcmV0dXJuO1xuXHRcdFx0XHRcdGlzRG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0KF9vYnNlcnZlciRlcnJvciA9IG9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkZXJyb3IgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkZXJyb3IuY2FsbChvYnNlcnZlciwgZXJyKTtcblx0XHRcdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHR2YXIgX29ic2VydmVyJGNvbXBsZXRlO1xuXHRcdFx0XHRcdGlmIChpc0RvbmUpIHJldHVybjtcblx0XHRcdFx0XHRpc0RvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdChfb2JzZXJ2ZXIkY29tcGxldGUgPSBvYnNlcnZlci5jb21wbGV0ZSkgPT09IG51bGwgfHwgX29ic2VydmVyJGNvbXBsZXRlID09PSB2b2lkIDAgfHwgX29ic2VydmVyJGNvbXBsZXRlLmNhbGwob2JzZXJ2ZXIpO1xuXHRcdFx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0aWYgKHRlYXJkb3duSW1tZWRpYXRlbHkpIHVuc3Vic2NyaWJlKCk7XG5cdFx0XHRyZXR1cm4geyB1bnN1YnNjcmliZSB9O1xuXHRcdH0sXG5cdFx0cGlwZSguLi5vcGVyYXRpb25zKSB7XG5cdFx0XHRyZXR1cm4gb3BlcmF0aW9ucy5yZWR1Y2UocGlwZVJlZHVjZXIsIHNlbGYpO1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBwaXBlUmVkdWNlcihwcmV2LCBmbikge1xuXHRyZXR1cm4gZm4ocHJldik7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBvYnNlcnZhYmxlVG9Qcm9taXNlKG9ic2VydmFibGUkMSkge1xuXHRjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0Y29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRsZXQgaXNEb25lID0gZmFsc2U7XG5cdFx0ZnVuY3Rpb24gb25Eb25lKCkge1xuXHRcdFx0aWYgKGlzRG9uZSkgcmV0dXJuO1xuXHRcdFx0aXNEb25lID0gdHJ1ZTtcblx0XHRcdG9icyQudW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdFx0YWMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG5cdFx0XHRyZWplY3QoYWMuc2lnbmFsLnJlYXNvbik7XG5cdFx0fSk7XG5cdFx0Y29uc3Qgb2JzJCA9IG9ic2VydmFibGUkMS5zdWJzY3JpYmUoe1xuXHRcdFx0bmV4dChkYXRhKSB7XG5cdFx0XHRcdGlzRG9uZSA9IHRydWU7XG5cdFx0XHRcdHJlc29sdmUoZGF0YSk7XG5cdFx0XHRcdG9uRG9uZSgpO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yKGRhdGEpIHtcblx0XHRcdFx0cmVqZWN0KGRhdGEpO1xuXHRcdFx0fSxcblx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRhYy5hYm9ydCgpO1xuXHRcdFx0XHRvbkRvbmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIG9ic2VydmFibGVUb1JlYWRhYmxlU3RyZWFtKG9ic2VydmFibGUkMSwgc2lnbmFsKSB7XG5cdGxldCB1bnN1YiA9IG51bGw7XG5cdGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG5cdFx0dW5zdWIgPT09IG51bGwgfHwgdW5zdWIgPT09IHZvaWQgMCB8fCB1bnN1Yi51bnN1YnNjcmliZSgpO1xuXHRcdHVuc3ViID0gbnVsbDtcblx0XHRzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuXHR9O1xuXHRyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHR1bnN1YiA9IG9ic2VydmFibGUkMS5zdWJzY3JpYmUoe1xuXHRcdFx0XHRuZXh0KGRhdGEpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdFx0b2s6IHRydWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogZGF0YVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcihlcnJvcikge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG5cdFx0XHRcdFx0XHRvazogZmFsc2UsXG5cdFx0XHRcdFx0XHRlcnJvclxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29tcGxldGUoKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGlmIChzaWduYWwuYWJvcnRlZCkgb25BYm9ydCgpO1xuXHRcdFx0ZWxzZSBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQsIHsgb25jZTogdHJ1ZSB9KTtcblx0XHR9LFxuXHRcdGNhbmNlbCgpIHtcblx0XHRcdG9uQWJvcnQoKTtcblx0XHR9XG5cdH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZShvYnNlcnZhYmxlJDEsIHNpZ25hbCkge1xuXHRjb25zdCBzdHJlYW0gPSBvYnNlcnZhYmxlVG9SZWFkYWJsZVN0cmVhbShvYnNlcnZhYmxlJDEsIHNpZ25hbCk7XG5cdGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0Y29uc3QgaXRlcmF0b3IgPSB7XG5cdFx0YXN5bmMgbmV4dCgpIHtcblx0XHRcdGNvbnN0IHZhbHVlID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblx0XHRcdGlmICh2YWx1ZS5kb25lKSByZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogdm9pZCAwLFxuXHRcdFx0XHRkb25lOiB0cnVlXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgeyB2YWx1ZTogcmVzdWx0IH0gPSB2YWx1ZTtcblx0XHRcdGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHQuZXJyb3I7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogcmVzdWx0LnZhbHVlLFxuXHRcdFx0XHRkb25lOiBmYWxzZVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGFzeW5jIHJldHVybigpIHtcblx0XHRcdGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHZhbHVlOiB2b2lkIDAsXG5cdFx0XHRcdGRvbmU6IHRydWVcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4geyBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuXHRcdHJldHVybiBpdGVyYXRvcjtcblx0fSB9O1xufVxuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGlzT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZSwgb2JzZXJ2YWJsZVRvUHJvbWlzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS1VTU8zdlVhXy5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\n',
      );

      /***/
    },

  /***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/resolveResponse-Hga1xOO1.mjs":
    /*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/resolveResponse-Hga1xOO1.mjs ***!
  \*****************************************************************************************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Unpromise: () => (/* binding */ Unpromise),\n/* harmony export */   createDeferred: () => (/* binding */ createDeferred),\n/* harmony export */   getRequestInfo: () => (/* binding */ getRequestInfo),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   iteratorResource: () => (/* binding */ iteratorResource),\n/* harmony export */   jsonlStreamConsumer: () => (/* binding */ jsonlStreamConsumer),\n/* harmony export */   jsonlStreamProducer: () => (/* binding */ jsonlStreamProducer),\n/* harmony export */   makeAsyncResource: () => (/* binding */ makeAsyncResource),\n/* harmony export */   makeResource: () => (/* binding */ makeResource),\n/* harmony export */   parseConnectionParamsFromString: () => (/* binding */ parseConnectionParamsFromString),\n/* harmony export */   parseConnectionParamsFromUnknown: () => (/* binding */ parseConnectionParamsFromUnknown),\n/* harmony export */   require_usingCtx: () => (/* binding */ require_usingCtx),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   sseHeaders: () => (/* binding */ sseHeaders),\n/* harmony export */   sseStreamConsumer: () => (/* binding */ sseStreamConsumer),\n/* harmony export */   sseStreamProducer: () => (/* binding */ sseStreamProducer),\n/* harmony export */   takeWithGrace: () => (/* binding */ takeWithGrace),\n/* harmony export */   throwAbortError: () => (/* binding */ throwAbortError),\n/* harmony export */   withMaxDuration: () => (/* binding */ withMaxDuration)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getErrorShape-Uhlrl4Bk.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs");\n/* harmony import */ var _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracked-Bp72jHif.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/tracked-Bp72jHif.mjs");\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs");\n/* harmony import */ var _observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable-UMO3vUa_.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs");\n\n\n\n\n\n//#region src/unstable-core-do-not-import/http/parseConnectionParams.ts\nfunction parseConnectionParamsFromUnknown(parsed) {\n\ttry {\n\t\tif (parsed === null) return null;\n\t\tif (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(parsed)) throw new Error("Expected object");\n\t\tconst nonStringValues = Object.entries(parsed).filter(([_key, value]) => typeof value !== "string");\n\t\tif (nonStringValues.length > 0) throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value]) => `${key}: ${typeof value}`).join(", ")}`);\n\t\treturn parsed;\n\t} catch (cause) {\n\t\tthrow new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: "PARSE_ERROR",\n\t\t\tmessage: "Invalid connection params shape",\n\t\t\tcause\n\t\t});\n\t}\n}\nfunction parseConnectionParamsFromString(str) {\n\tlet parsed;\n\ttry {\n\t\tparsed = JSON.parse(str);\n\t} catch (cause) {\n\t\tthrow new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: "PARSE_ERROR",\n\t\t\tmessage: "Not JSON-parsable query params",\n\t\t\tcause\n\t\t});\n\t}\n\treturn parseConnectionParamsFromUnknown(parsed);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/contentType.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\n/**\n* Memoize a function that takes no arguments\n* @internal\n*/\nfunction memo(fn) {\n\tlet promise = null;\n\tconst sym = Symbol.for("@trpc/server/http/memo");\n\tlet value = sym;\n\treturn {\n\t\tread: async () => {\n\t\t\tvar _promise;\n\t\t\tif (value !== sym) return value;\n\t\t\t(_promise = promise) !== null && _promise !== void 0 || (promise = fn().catch((cause) => {\n\t\t\t\tif (cause instanceof _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError) throw cause;\n\t\t\t\tthrow new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: "BAD_REQUEST",\n\t\t\t\t\tmessage: cause instanceof Error ? cause.message : "Invalid input",\n\t\t\t\t\tcause\n\t\t\t\t});\n\t\t\t}));\n\t\t\tvalue = await promise;\n\t\t\tpromise = null;\n\t\t\treturn value;\n\t\t},\n\t\tresult: () => {\n\t\t\treturn value !== sym ? value : void 0;\n\t\t}\n\t};\n}\nconst jsonContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get;\n\t\treturn !!((_req$headers$get = req.headers.get("content-type")) === null || _req$headers$get === void 0 ? void 0 : _req$headers$get.startsWith("application/json"));\n\t},\n\tasync parse(opts) {\n\t\tvar _types$values$next$va;\n\t\tconst { req } = opts;\n\t\tconst isBatchCall = opts.searchParams.get("batch") === "1";\n\t\tconst paths = isBatchCall ? opts.path.split(",") : [opts.path];\n\t\tconst getInputs = memo(async () => {\n\t\t\tlet inputs = void 0;\n\t\t\tif (req.method === "GET") {\n\t\t\t\tconst queryInput = opts.searchParams.get("input");\n\t\t\t\tif (queryInput) inputs = JSON.parse(queryInput);\n\t\t\t} else inputs = await req.json();\n\t\t\tif (inputs === void 0) return {};\n\t\t\tif (!isBatchCall) return { 0: opts.router._def._config.transformer.input.deserialize(inputs) };\n\t\t\tif (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(inputs)) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\tcode: "BAD_REQUEST",\n\t\t\t\tmessage: "\\"input\\" needs to be an object when doing a batch call"\n\t\t\t});\n\t\t\tconst acc = {};\n\t\t\tfor (const index of paths.keys()) {\n\t\t\t\tconst input = inputs[index];\n\t\t\t\tif (input !== void 0) acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n\t\t\t}\n\t\t\treturn acc;\n\t\t});\n\t\tconst calls = await Promise.all(paths.map(async (path, index) => {\n\t\t\tconst procedure = await (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, path);\n\t\t\treturn {\n\t\t\t\tpath,\n\t\t\t\tprocedure,\n\t\t\t\tgetRawInput: async () => {\n\t\t\t\t\tconst inputs = await getInputs.read();\n\t\t\t\t\tlet input = inputs[index];\n\t\t\t\t\tif ((procedure === null || procedure === void 0 ? void 0 : procedure._def.type) === "subscription") {\n\t\t\t\t\t\tvar _ref, _opts$headers$get;\n\t\t\t\t\t\tconst lastEventId = (_ref = (_opts$headers$get = opts.headers.get("last-event-id")) !== null && _opts$headers$get !== void 0 ? _opts$headers$get : opts.searchParams.get("lastEventId")) !== null && _ref !== void 0 ? _ref : opts.searchParams.get("Last-Event-Id");\n\t\t\t\t\t\tif (lastEventId) if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) input = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, input), {}, { lastEventId });\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar _input;\n\t\t\t\t\t\t\t(_input = input) !== null && _input !== void 0 || (input = { lastEventId });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn input;\n\t\t\t\t},\n\t\t\t\tresult: () => {\n\t\t\t\t\tvar _getInputs$result;\n\t\t\t\t\treturn (_getInputs$result = getInputs.result()) === null || _getInputs$result === void 0 ? void 0 : _getInputs$result[index];\n\t\t\t\t}\n\t\t\t};\n\t\t}));\n\t\tconst types = new Set(calls.map((call) => {\n\t\t\tvar _call$procedure;\n\t\t\treturn (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n\t\t}).filter(Boolean));\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (types.size > 1) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: "BAD_REQUEST",\n\t\t\tmessage: `Cannot mix procedure types in call: ${Array.from(types).join(", ")}`\n\t\t});\n\t\tconst type = (_types$values$next$va = types.values().next().value) !== null && _types$values$next$va !== void 0 ? _types$values$next$va : "unknown";\n\t\tconst connectionParamsStr = opts.searchParams.get("connectionParams");\n\t\tconst info = {\n\t\t\tisBatchCall,\n\t\t\taccept: req.headers.get("trpc-accept"),\n\t\t\tcalls,\n\t\t\ttype,\n\t\t\tconnectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t\treturn info;\n\t}\n};\nconst formDataContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get2;\n\t\treturn !!((_req$headers$get2 = req.headers.get("content-type")) === null || _req$headers$get2 === void 0 ? void 0 : _req$headers$get2.startsWith("multipart/form-data"));\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== "POST") throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: "METHOD_NOT_SUPPORTED",\n\t\t\tmessage: "Only POST requests are supported for multipart/form-data requests"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\tconst fd = await req.formData();\n\t\t\treturn fd;\n\t\t});\n\t\tconst procedure = await (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path);\n\t\treturn {\n\t\t\taccept: null,\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\ttype: "mutation",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst octetStreamContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get3;\n\t\treturn !!((_req$headers$get3 = req.headers.get("content-type")) === null || _req$headers$get3 === void 0 ? void 0 : _req$headers$get3.startsWith("application/octet-stream"));\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== "POST") throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: "METHOD_NOT_SUPPORTED",\n\t\t\tmessage: "Only POST requests are supported for application/octet-stream requests"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\treturn req.body;\n\t\t});\n\t\treturn {\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure: await (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path)\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\taccept: null,\n\t\t\ttype: "mutation",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst handlers = [\n\tjsonContentTypeHandler,\n\tformDataContentTypeHandler,\n\toctetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n\tconst handler = handlers.find((handler$1) => handler$1.isMatch(req));\n\tif (handler) return handler;\n\tif (!handler && req.method === "GET") return jsonContentTypeHandler;\n\tthrow new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\tcode: "UNSUPPORTED_MEDIA_TYPE",\n\t\tmessage: req.headers.has("content-type") ? `Unsupported content-type "${req.headers.get("content-type")}` : "Missing content-type header"\n\t});\n}\nasync function getRequestInfo(opts) {\n\tconst handler = getContentTypeHandler(opts.req);\n\treturn await handler.parse(opts);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/abortError.ts\nfunction isAbortError(error) {\n\treturn (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(error) && error["name"] === "AbortError";\n}\nfunction throwAbortError(message = "AbortError") {\n\tthrow new DOMException(message, "AbortError");\n}\n\n//#endregion\n//#region src/vendor/is-plain-object.ts\n/*!\n* is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n*\n* Copyright (c) 2014-2017, Jon Schlinkert.\n* Released under the MIT License.\n*/\nfunction isObject$1(o) {\n\treturn Object.prototype.toString.call(o) === "[object Object]";\n}\nfunction isPlainObject(o) {\n\tvar ctor, prot;\n\tif (isObject$1(o) === false) return false;\n\tctor = o.constructor;\n\tif (ctor === void 0) return true;\n\tprot = ctor.prototype;\n\tif (isObject$1(prot) === false) return false;\n\tif (prot.hasOwnProperty("isPrototypeOf") === false) return false;\n\treturn true;\n}\n\n//#endregion\n//#region src/vendor/unpromise/unpromise.ts\nvar import_defineProperty = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_defineProperty)(), 1);\nlet _Symbol$toStringTag;\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n* which is retained for the lifetime of the original Promise.\n*/\nconst subscribableCache = /* @__PURE__ */ new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n* SubscribedPromises (settled promises are not subscribed - they resolve\n* immediately). */\nconst NOOP = () => {};\n_Symbol$toStringTag = Symbol.toStringTag;\n/**\n* Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n* created once, cached and reused throughout the lifetime of the Promise. Get a\n* Promise\'s ProxyPromise using `Unpromise.proxy(promise)`.\n*\n* The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n* `.then()` and `.catch()` just once. Promises derived from it use a\n* subscription- (and unsubscription-) based mechanism that monitors these\n* handlers.\n*\n* Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n* `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n* `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n* from the original, potentially long-lived Promise, eliminating memory leaks.\n*\n* This approach can eliminate the memory leaks that otherwise come about from\n* repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n* times on the same long-lived native Promise (subscriptions which can never be\n* cleaned up).\n*\n* `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n* any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n* the scenes, `resolve` is implemented simply as\n* `Unpromise.proxy(promise).subscribe()`. Don\'t forget to call `.unsubscribe()`\n* to tidy up!\n*\n*/\nvar Unpromise = class Unpromise {\n\tconstructor(arg) {\n\t\t(0, import_defineProperty.default)(this, "promise", void 0);\n\t\t(0, import_defineProperty.default)(this, "subscribers", []);\n\t\t(0, import_defineProperty.default)(this, "settlement", null);\n\t\t(0, import_defineProperty.default)(this, _Symbol$toStringTag, "Unpromise");\n\t\tif (typeof arg === "function") this.promise = new Promise(arg);\n\t\telse this.promise = arg;\n\t\tconst thenReturn = this.promise.then((value) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: "fulfilled",\n\t\t\t\tvalue\n\t\t\t};\n\t\t\tsubscribers === null || subscribers === void 0 || subscribers.forEach(({ resolve }) => {\n\t\t\t\tresolve(value);\n\t\t\t});\n\t\t});\n\t\tif ("catch" in thenReturn) thenReturn.catch((reason) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: "rejected",\n\t\t\t\treason\n\t\t\t};\n\t\t\tsubscribers === null || subscribers === void 0 || subscribers.forEach(({ reject }) => {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t});\n\t}\n\t/** Create a promise that mitigates uncontrolled subscription to a long-lived\n\t* Promise via .then() and .catch() - otherwise a source of memory leaks.\n\t*\n\t* The returned promise has an `unsubscribe()` method which can be called when\n\t* the Promise is no longer being tracked by application logic, and which\n\t* ensures that there is no reference chain from the original promise to the\n\t* new one, and therefore no memory leak.\n\t*\n\t* If original promise has not yet settled, this adds a new unique promise\n\t* that listens to then/catch events, along with an `unsubscribe()` method to\n\t* detach it.\n\t*\n\t* If original promise has settled, then creates a new Promise.resolve() or\n\t* Promise.reject() and provided unsubscribe is a noop.\n\t*\n\t* If you call `unsubscribe()` before the returned Promise has settled, it\n\t* will never settle.\n\t*/\n\tsubscribe() {\n\t\tlet promise;\n\t\tlet unsubscribe;\n\t\tconst { settlement } = this;\n\t\tif (settlement === null) {\n\t\t\tif (this.subscribers === null) throw new Error("Unpromise settled but still has subscribers");\n\t\t\tconst subscriber = withResolvers();\n\t\t\tthis.subscribers = listWithMember(this.subscribers, subscriber);\n\t\t\tpromise = subscriber.promise;\n\t\t\tunsubscribe = () => {\n\t\t\t\tif (this.subscribers !== null) this.subscribers = listWithoutMember(this.subscribers, subscriber);\n\t\t\t};\n\t\t} else {\n\t\t\tconst { status } = settlement;\n\t\t\tif (status === "fulfilled") promise = Promise.resolve(settlement.value);\n\t\t\telse promise = Promise.reject(settlement.reason);\n\t\t\tunsubscribe = NOOP;\n\t\t}\n\t\treturn Object.assign(promise, { unsubscribe });\n\t}\n\t/** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */\n\tthen(onfulfilled, onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.then(onfulfilled, onrejected), { unsubscribe });\n\t}\n\tcatch(onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.catch(onrejected), { unsubscribe });\n\t}\n\tfinally(onfinally) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.finally(onfinally), { unsubscribe });\n\t}\n\t/** Unpromise STATIC METHODS */\n\t/** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n\t* of the provided Promise reference) */\n\tstatic proxy(promise) {\n\t\tconst cached = Unpromise.getSubscribablePromise(promise);\n\t\treturn typeof cached !== "undefined" ? cached : Unpromise.createSubscribablePromise(promise);\n\t}\n\t/** Create and store an Unpromise keyed by an original Promise. */\n\tstatic createSubscribablePromise(promise) {\n\t\tconst created = new Unpromise(promise);\n\t\tsubscribableCache.set(promise, created);\n\t\tsubscribableCache.set(created, created);\n\t\treturn created;\n\t}\n\t/** Retrieve a previously-created Unpromise keyed by an original Promise. */\n\tstatic getSubscribablePromise(promise) {\n\t\treturn subscribableCache.get(promise);\n\t}\n\t/** Promise STATIC METHODS */\n\t/** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n\t* it (that can be later unsubscribed to eliminate Memory leaks) */\n\tstatic resolve(value) {\n\t\tconst promise = typeof value === "object" && value !== null && "then" in value && typeof value.then === "function" ? value : Promise.resolve(value);\n\t\treturn Unpromise.proxy(promise).subscribe();\n\t}\n\tstatic async any(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.any(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\tstatic async race(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.race(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\t/** Create a race of SubscribedPromises that will fulfil to a single winning\n\t* Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n\t* accumulating .then() and .catch() subscribers. Allows simple logic to\n\t* consume the result, like...\n\t* ```ts\n\t* const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n\t* if(winner === promiseB){\n\t*   const result = await promiseB;\n\t*   // do the thing\n\t* }\n\t* ```\n\t* */\n\tstatic async raceReferences(promises) {\n\t\tconst selfPromises = promises.map(resolveSelfTuple);\n\t\ttry {\n\t\t\treturn await Promise.race(selfPromises);\n\t\t} finally {\n\t\t\tfor (const promise of selfPromises) promise.unsubscribe();\n\t\t}\n\t}\n};\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n* awaiting the eventual Promise ***reference*** (easy to destructure and\n* exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n* may be ambiguous and therefore hard to identify as the winner of a race).\n* You can call unsubscribe on the Promise to mitigate memory leaks.\n* */\nfunction resolveSelfTuple(promise) {\n\treturn Unpromise.proxy(promise).then(() => [promise]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */\n/** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */\nfunction withResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n/** IMMUTABLE LIST OPERATIONS */\nfunction listWithMember(arr, member) {\n\treturn [...arr, member];\n}\nfunction listWithoutIndex(arr, index) {\n\treturn [...arr.slice(0, index), ...arr.slice(index + 1)];\n}\nfunction listWithoutMember(arr, member) {\n\tconst index = arr.indexOf(member);\n\tif (index !== -1) return listWithoutIndex(arr, index);\n\treturn arr;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/disposable.ts\nvar _Symbol, _Symbol$dispose, _Symbol2, _Symbol2$asyncDispose;\n(_Symbol$dispose = (_Symbol = Symbol).dispose) !== null && _Symbol$dispose !== void 0 || (_Symbol.dispose = Symbol());\n(_Symbol2$asyncDispose = (_Symbol2 = Symbol).asyncDispose) !== null && _Symbol2$asyncDispose !== void 0 || (_Symbol2.asyncDispose = Symbol());\n/**\n* Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n* The returned object is the original value augmented with a Symbol.dispose method.\n* @param thing The value to make disposable\n* @param dispose Function to call when disposing the resource\n* @returns The original value with Symbol.dispose method added\n*/\nfunction makeResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.dispose];\n\tit[Symbol.dispose] = () => {\n\t\tdispose();\n\t\texisting === null || existing === void 0 || existing();\n\t};\n\treturn it;\n}\n/**\n* Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n* The returned object is the original value augmented with a Symbol.asyncDispose method.\n* @param thing The value to make async disposable\n* @param dispose Async function to call when disposing the resource\n* @returns The original value with Symbol.asyncDispose method added\n*/\nfunction makeAsyncResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.asyncDispose];\n\tit[Symbol.asyncDispose] = async () => {\n\t\tawait dispose();\n\t\tawait (existing === null || existing === void 0 ? void 0 : existing());\n\t};\n\treturn it;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/timerResource.ts\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n\tlet timer = null;\n\treturn makeResource({ start() {\n\t\tif (timer) throw new Error("Timer already started");\n\t\tconst promise = new Promise((resolve) => {\n\t\t\ttimer = setTimeout(() => resolve(disposablePromiseTimerResult), ms);\n\t\t});\n\t\treturn promise;\n\t} }, () => {\n\t\tif (timer) clearTimeout(timer);\n\t});\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js"(exports, module) {\n\tfunction _usingCtx() {\n\t\tvar r = "function" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n\t\t\tvar n$1 = Error();\n\t\t\treturn n$1.name = "SuppressedError", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n\t\t}, e = {}, n = [];\n\t\tfunction using(r$1, e$1) {\n\t\t\tif (null != e$1) {\n\t\t\t\tif (Object(e$1) !== e$1) throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");\n\t\t\t\tif (r$1) var o = e$1[Symbol.asyncDispose || Symbol["for"]("Symbol.asyncDispose")];\n\t\t\t\tif (void 0 === o && (o = e$1[Symbol.dispose || Symbol["for"]("Symbol.dispose")], r$1)) var t = o;\n\t\t\t\tif ("function" != typeof o) throw new TypeError("Object is not disposable.");\n\t\t\t\tt && (o = function o$1() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.call(e$1);\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn Promise.reject(r$2);\n\t\t\t\t\t}\n\t\t\t\t}), n.push({\n\t\t\t\t\tv: e$1,\n\t\t\t\t\td: o,\n\t\t\t\t\ta: r$1\n\t\t\t\t});\n\t\t\t} else r$1 && n.push({\n\t\t\t\td: e$1,\n\t\t\t\ta: r$1\n\t\t\t});\n\t\t\treturn e$1;\n\t\t}\n\t\treturn {\n\t\t\te,\n\t\t\tu: using.bind(null, !1),\n\t\t\ta: using.bind(null, !0),\n\t\t\td: function d() {\n\t\t\t\tvar o, t = this.e, s = 0;\n\t\t\t\tfunction next() {\n\t\t\t\t\tfor (; o = n.pop();) try {\n\t\t\t\t\t\tif (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n\t\t\t\t\t\tif (o.d) {\n\t\t\t\t\t\t\tvar r$1 = o.d.call(o.v);\n\t\t\t\t\t\t\tif (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n\t\t\t\t\t\t} else s |= 1;\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn err(r$2);\n\t\t\t\t\t}\n\t\t\t\t\tif (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n\t\t\t\t\tif (t !== e) throw t;\n\t\t\t\t}\n\t\t\t\tfunction err(n$1) {\n\t\t\t\t\treturn t = t !== e ? new r(n$1, t) : n$1, next();\n\t\t\t\t}\n\t\t\t\treturn next();\n\t\t\t}\n\t\t};\n\t}\n\tmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\nvar require_OverloadYield = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js"(exports, module) {\n\tfunction _OverloadYield(e, d) {\n\t\tthis.v = e, this.k = d;\n\t}\n\tmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\nvar require_awaitAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js"(exports, module) {\n\tvar OverloadYield$2 = require_OverloadYield();\n\tfunction _awaitAsyncGenerator$5(e) {\n\t\treturn new OverloadYield$2(e, 0);\n\t}\n\tmodule.exports = _awaitAsyncGenerator$5, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\nvar require_wrapAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js"(exports, module) {\n\tvar OverloadYield$1 = require_OverloadYield();\n\tfunction _wrapAsyncGenerator$6(e) {\n\t\treturn function() {\n\t\t\treturn new AsyncGenerator(e.apply(this, arguments));\n\t\t};\n\t}\n\tfunction AsyncGenerator(e) {\n\t\tvar r, t;\n\t\tfunction resume(r$1, t$1) {\n\t\t\ttry {\n\t\t\t\tvar n = e[r$1](t$1), o = n.value, u = o instanceof OverloadYield$1;\n\t\t\t\tPromise.resolve(u ? o.v : o).then(function(t$2) {\n\t\t\t\t\tif (u) {\n\t\t\t\t\t\tvar i = "return" === r$1 ? "return" : "next";\n\t\t\t\t\t\tif (!o.k || t$2.done) return resume(i, t$2);\n\t\t\t\t\t\tt$2 = e[i](t$2).value;\n\t\t\t\t\t}\n\t\t\t\t\tsettle(n.done ? "return" : "normal", t$2);\n\t\t\t\t}, function(e$1) {\n\t\t\t\t\tresume("throw", e$1);\n\t\t\t\t});\n\t\t\t} catch (e$1) {\n\t\t\t\tsettle("throw", e$1);\n\t\t\t}\n\t\t}\n\t\tfunction settle(e$1, n) {\n\t\t\tswitch (e$1) {\n\t\t\t\tcase "return":\n\t\t\t\t\tr.resolve({\n\t\t\t\t\t\tvalue: n,\n\t\t\t\t\t\tdone: !0\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase "throw":\n\t\t\t\t\tr.reject(n);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: r.resolve({\n\t\t\t\t\tvalue: n,\n\t\t\t\t\tdone: !1\n\t\t\t\t});\n\t\t\t}\n\t\t\t(r = r.next) ? resume(r.key, r.arg) : t = null;\n\t\t}\n\t\tthis._invoke = function(e$1, n) {\n\t\t\treturn new Promise(function(o, u) {\n\t\t\t\tvar i = {\n\t\t\t\t\tkey: e$1,\n\t\t\t\t\targ: n,\n\t\t\t\t\tresolve: o,\n\t\t\t\t\treject: u,\n\t\t\t\t\tnext: null\n\t\t\t\t};\n\t\t\t\tt ? t = t.next = i : (r = t = i, resume(e$1, n));\n\t\t\t});\n\t\t}, "function" != typeof e["return"] && (this["return"] = void 0);\n\t}\n\tAsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {\n\t\treturn this;\n\t}, AsyncGenerator.prototype.next = function(e) {\n\t\treturn this._invoke("next", e);\n\t}, AsyncGenerator.prototype["throw"] = function(e) {\n\t\treturn this._invoke("throw", e);\n\t}, AsyncGenerator.prototype["return"] = function(e) {\n\t\treturn this._invoke("return", e);\n\t};\n\tmodule.exports = _wrapAsyncGenerator$6, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/asyncIterable.ts\nvar import_usingCtx$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$5 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction iteratorResource(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tif (iterator[Symbol.asyncDispose]) return iterator;\n\treturn makeAsyncResource(iterator, async () => {\n\t\tvar _iterator$return;\n\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t});\n}\n/**\n* Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically aborts after the specified duration.\n*/\nfunction withMaxDuration(_x, _x2) {\n\treturn _withMaxDuration.apply(this, arguments);\n}\nfunction _withMaxDuration() {\n\t_withMaxDuration = (0, import_wrapAsyncGenerator$5.default)(function* (iterable, opts) {\n\t\ttry {\n\t\t\tvar _usingCtx$1 = (0, import_usingCtx$4.default)();\n\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\t\tconst timer = _usingCtx$1.u(timerResource(opts.maxDurationMs));\n\t\t\tconst timerPromise = timer.start();\n\t\t\tlet result;\n\t\t\twhile (true) {\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([iterator.next(), timerPromise]));\n\t\t\t\tif (result === disposablePromiseTimerResult) throwAbortError();\n\t\t\t\tif (result.done) return result;\n\t\t\t\tyield result.value;\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx$1.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$4.default)(_usingCtx$1.d());\n\t\t}\n\t});\n\treturn _withMaxDuration.apply(this, arguments);\n}\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n* {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n* values may still come through. After this period, the generator aborts.\n*/\nfunction takeWithGrace(_x3, _x4) {\n\treturn _takeWithGrace.apply(this, arguments);\n}\nfunction _takeWithGrace() {\n\t_takeWithGrace = (0, import_wrapAsyncGenerator$5.default)(function* (iterable, opts) {\n\t\ttry {\n\t\t\tvar _usingCtx3 = (0, import_usingCtx$4.default)();\n\t\t\tconst iterator = _usingCtx3.a(iteratorResource(iterable));\n\t\t\tlet result;\n\t\t\tconst timer = _usingCtx3.u(timerResource(opts.gracePeriodMs));\n\t\t\tlet count = opts.count;\n\t\t\tlet timerPromise = new Promise(() => {});\n\t\t\twhile (true) {\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([iterator.next(), timerPromise]));\n\t\t\t\tif (result === disposablePromiseTimerResult) throwAbortError();\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tyield result.value;\n\t\t\t\tif (--count === 0) timerPromise = timer.start();\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx3.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$4.default)(_usingCtx3.d());\n\t\t}\n\t});\n\treturn _takeWithGrace.apply(this, arguments);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/createDeferred.ts\nfunction createDeferred() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts\nvar import_usingCtx$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction createManagedIterator(iterable, onResult) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tlet state = "idle";\n\tfunction cleanup() {\n\t\tstate = "done";\n\t\tonResult = () => {};\n\t}\n\tfunction pull() {\n\t\tif (state !== "idle") return;\n\t\tstate = "pending";\n\t\tconst next = iterator.next();\n\t\tnext.then((result) => {\n\t\t\tif (result.done) {\n\t\t\t\tstate = "done";\n\t\t\t\tonResult({\n\t\t\t\t\tstatus: "return",\n\t\t\t\t\tvalue: result.value\n\t\t\t\t});\n\t\t\t\tcleanup();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate = "idle";\n\t\t\tonResult({\n\t\t\t\tstatus: "yield",\n\t\t\t\tvalue: result.value\n\t\t\t});\n\t\t}).catch((cause) => {\n\t\t\tonResult({\n\t\t\t\tstatus: "error",\n\t\t\t\terror: cause\n\t\t\t});\n\t\t\tcleanup();\n\t\t});\n\t}\n\treturn {\n\t\tpull,\n\t\tdestroy: async () => {\n\t\t\tvar _iterator$return;\n\t\t\tcleanup();\n\t\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t\t}\n\t};\n}\n/**\n* Creates a new async iterable that merges multiple async iterables into a single stream.\n* Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n*\n* New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n*\n* If any of the input iterables throws an error, that error will be propagated through the merged stream.\n* Other iterables will not continue to be processed.\n*\n* @template TYield The type of values yielded by the input iterables\n*/\nfunction mergeAsyncIterables() {\n\tlet state = "idle";\n\tlet flushSignal = createDeferred();\n\t/**\n\t* used while {@link state} is `idle`\n\t*/\n\tconst iterables = [];\n\t/**\n\t* used while {@link state} is `pending`\n\t*/\n\tconst iterators = /* @__PURE__ */ new Set();\n\tconst buffer = [];\n\tfunction initIterable(iterable) {\n\t\tif (state !== "pending") return;\n\t\tconst iterator = createManagedIterator(iterable, (result) => {\n\t\t\tif (state !== "pending") return;\n\t\t\tswitch (result.status) {\n\t\t\t\tcase "yield":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase "return":\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t\tcase "error":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflushSignal.resolve();\n\t\t});\n\t\titerators.add(iterator);\n\t\titerator.pull();\n\t}\n\treturn {\n\t\tadd(iterable) {\n\t\t\tswitch (state) {\n\t\t\t\tcase "idle":\n\t\t\t\t\titerables.push(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase "pending":\n\t\t\t\t\tinitIterable(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase "done": break;\n\t\t\t}\n\t\t},\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn (0, import_wrapAsyncGenerator$4.default)(function* () {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$3.default)();\n\t\t\t\t\tif (state !== "idle") throw new Error("Cannot iterate twice");\n\t\t\t\t\tstate = "pending";\n\t\t\t\t\tconst _finally = _usingCtx$1.a(makeAsyncResource({}, async () => {\n\t\t\t\t\t\tstate = "done";\n\t\t\t\t\t\tconst errors = [];\n\t\t\t\t\t\tawait Promise.all(Array.from(iterators.values()).map(async (it) => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait it.destroy();\n\t\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\t\terrors.push(cause);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tbuffer.length = 0;\n\t\t\t\t\t\titerators.clear();\n\t\t\t\t\t\tflushSignal.resolve();\n\t\t\t\t\t\tif (errors.length > 0) throw new AggregateError(errors);\n\t\t\t\t\t}));\n\t\t\t\t\twhile (iterables.length > 0) initIterable(iterables.shift());\n\t\t\t\t\twhile (iterators.size > 0) {\n\t\t\t\t\t\tyield (0, import_awaitAsyncGenerator$3.default)(flushSignal.promise);\n\t\t\t\t\t\twhile (buffer.length > 0) {\n\t\t\t\t\t\t\tconst [iterator, result] = buffer.shift();\n\t\t\t\t\t\t\tswitch (result.status) {\n\t\t\t\t\t\t\t\tcase "yield":\n\t\t\t\t\t\t\t\t\tyield result.value;\n\t\t\t\t\t\t\t\t\titerator.pull();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase "error": throw result.error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflushSignal = createDeferred();\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx$1.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\tyield (0, import_awaitAsyncGenerator$3.default)(_usingCtx$1.d());\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts\n/**\n* Creates a ReadableStream from an AsyncIterable.\n*\n* @param iterable - The source AsyncIterable to stream from\n* @returns A ReadableStream that yields values from the AsyncIterable\n*/\nfunction readableStreamFrom(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\treturn new ReadableStream({\n\t\tasync cancel() {\n\t\t\tvar _iterator$return;\n\t\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t\t},\n\t\tasync pull(controller) {\n\t\t\tconst result = await iterator.next();\n\t\t\tif (result.done) {\n\t\t\t\tcontroller.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontroller.enqueue(result.value);\n\t\t}\n\t});\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/withPing.ts\nvar import_usingCtx$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nconst PING_SYM = Symbol("ping");\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n* whenever no value has been yielded for {@link pingIntervalMs}.\n*/\nfunction withPing(_x, _x2) {\n\treturn _withPing.apply(this, arguments);\n}\nfunction _withPing() {\n\t_withPing = (0, import_wrapAsyncGenerator$3.default)(function* (iterable, pingIntervalMs) {\n\t\ttry {\n\t\t\tvar _usingCtx$1 = (0, import_usingCtx$2.default)();\n\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\t\tlet result;\n\t\t\tlet nextPromise = iterator.next();\n\t\t\twhile (true) try {\n\t\t\t\tvar _usingCtx3 = (0, import_usingCtx$2.default)();\n\t\t\t\tconst pingPromise = _usingCtx3.u(timerResource(pingIntervalMs));\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$2.default)(Unpromise.race([nextPromise, pingPromise.start()]));\n\t\t\t\tif (result === disposablePromiseTimerResult) {\n\t\t\t\t\tyield PING_SYM;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tnextPromise = iterator.next();\n\t\t\t\tyield result.value;\n\t\t\t\tresult = null;\n\t\t\t} catch (_) {\n\t\t\t\t_usingCtx3.e = _;\n\t\t\t} finally {\n\t\t\t\t_usingCtx3.d();\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx$1.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$2.default)(_usingCtx$1.d());\n\t\t}\n\t});\n\treturn _withPing.apply(this, arguments);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\nvar require_asyncIterator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js"(exports, module) {\n\tfunction _asyncIterator$2(r) {\n\t\tvar n, t, o, e = 2;\n\t\tfor ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n\t\t\tif (t && null != (n = r[t])) return n.call(r);\n\t\t\tif (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n\t\t\tt = "@@asyncIterator", o = "@@iterator";\n\t\t}\n\t\tthrow new TypeError("Object is not async iterable");\n\t}\n\tfunction AsyncFromSyncIterator(r) {\n\t\tfunction AsyncFromSyncIteratorContinuation(r$1) {\n\t\t\tif (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + " is not an object."));\n\t\t\tvar n = r$1.done;\n\t\t\treturn Promise.resolve(r$1.value).then(function(r$2) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: r$2,\n\t\t\t\t\tdone: n\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn AsyncFromSyncIterator = function AsyncFromSyncIterator$1(r$1) {\n\t\t\tthis.s = r$1, this.n = r$1.next;\n\t\t}, AsyncFromSyncIterator.prototype = {\n\t\t\ts: null,\n\t\t\tn: null,\n\t\t\tnext: function next() {\n\t\t\t\treturn AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t"return": function _return(r$1) {\n\t\t\t\tvar n = this.s["return"];\n\t\t\t\treturn void 0 === n ? Promise.resolve({\n\t\t\t\t\tvalue: r$1,\n\t\t\t\t\tdone: !0\n\t\t\t\t}) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t"throw": function _throw(r$1) {\n\t\t\t\tvar n = this.s["return"];\n\t\t\t\treturn void 0 === n ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t}\n\t\t}, new AsyncFromSyncIterator(r);\n\t}\n\tmodule.exports = _asyncIterator$2, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/jsonl.ts\nvar import_awaitAsyncGenerator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_usingCtx$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_asyncIterator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n\treturn ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) && typeof (value === null || value === void 0 ? void 0 : value["then"]) === "function" && typeof (value === null || value === void 0 ? void 0 : value["catch"]) === "function";\n}\nvar MaxDepthError = class extends Error {\n\tconstructor(path) {\n\t\tsuper("Max depth reached at path: " + path.join("."));\n\t\tthis.path = path;\n\t}\n};\nfunction createBatchStreamProducer(_x3) {\n\treturn _createBatchStreamProducer.apply(this, arguments);\n}\nfunction _createBatchStreamProducer() {\n\t_createBatchStreamProducer = (0, import_wrapAsyncGenerator$2.default)(function* (opts) {\n\t\tconst { data } = opts;\n\t\tlet counter = 0;\n\t\tconst placeholder = 0;\n\t\tconst mergedIterables = mergeAsyncIterables();\n\t\tfunction registerAsync(callback) {\n\t\t\tconst idx = counter++;\n\t\t\tconst iterable$1 = callback(idx);\n\t\t\tmergedIterables.add(iterable$1);\n\t\t\treturn idx;\n\t\t}\n\t\tfunction encodePromise(promise, path) {\n\t\t\treturn registerAsync(/* @__PURE__ */ function() {\n\t\t\t\tvar _ref = (0, import_wrapAsyncGenerator$2.default)(function* (idx) {\n\t\t\t\t\tconst error = checkMaxDepth(path);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tpromise.catch((cause) => {\n\t\t\t\t\t\t\tvar _opts$onError;\n\t\t\t\t\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpromise = Promise.reject(error);\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst next = yield (0, import_awaitAsyncGenerator$1.default)(promise);\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\tPROMISE_STATUS_FULFILLED,\n\t\t\t\t\t\t\tencode(next, path)\n\t\t\t\t\t\t];\n\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\tvar _opts$onError2, _opts$formatError;\n\t\t\t\t\t\t(_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t});\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\tPROMISE_STATUS_REJECTED,\n\t\t\t\t\t\t\t(_opts$formatError = opts.formatError) === null || _opts$formatError === void 0 ? void 0 : _opts$formatError.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function(_x) {\n\t\t\t\t\treturn _ref.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}());\n\t\t}\n\t\tfunction encodeAsyncIterable(iterable$1, path) {\n\t\t\treturn registerAsync(/* @__PURE__ */ function() {\n\t\t\t\tvar _ref2 = (0, import_wrapAsyncGenerator$2.default)(function* (idx) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$1.default)();\n\t\t\t\t\t\tconst error = checkMaxDepth(path);\n\t\t\t\t\t\tif (error) throw error;\n\t\t\t\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable$1));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst next = yield (0, import_awaitAsyncGenerator$1.default)(iterator.next());\n\t\t\t\t\t\t\t\tif (next.done) {\n\t\t\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_RETURN,\n\t\t\t\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_YIELD,\n\t\t\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\tvar _opts$onError3, _opts$formatError2;\n\t\t\t\t\t\t\t(_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_ERROR,\n\t\t\t\t\t\t\t\t(_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, {\n\t\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (_) {\n\t\t\t\t\t\t_usingCtx$1.e = _;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tyield (0, import_awaitAsyncGenerator$1.default)(_usingCtx$1.d());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function(_x2) {\n\t\t\t\t\treturn _ref2.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}());\n\t\t}\n\t\tfunction checkMaxDepth(path) {\n\t\t\tif (opts.maxDepth && path.length > opts.maxDepth) return new MaxDepthError(path);\n\t\t\treturn null;\n\t\t}\n\t\tfunction encodeAsync(value, path) {\n\t\t\tif (isPromise(value)) return [CHUNK_VALUE_TYPE_PROMISE, encodePromise(value, path)];\n\t\t\tif ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(value)) {\n\t\t\t\tif (opts.maxDepth && path.length >= opts.maxDepth) throw new Error("Max depth reached");\n\t\t\t\treturn [CHUNK_VALUE_TYPE_ASYNC_ITERABLE, encodeAsyncIterable(value, path)];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tfunction encode(value, path) {\n\t\t\tif (value === void 0) return [[]];\n\t\t\tconst reg = encodeAsync(value, path);\n\t\t\tif (reg) return [[placeholder], [null, ...reg]];\n\t\t\tif (!isPlainObject(value)) return [[value]];\n\t\t\tconst newObj = {};\n\t\t\tconst asyncValues = [];\n\t\t\tfor (const [key, item] of Object.entries(value)) {\n\t\t\t\tconst transformed = encodeAsync(item, [...path, key]);\n\t\t\t\tif (!transformed) {\n\t\t\t\t\tnewObj[key] = item;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewObj[key] = placeholder;\n\t\t\t\tasyncValues.push([key, ...transformed]);\n\t\t\t}\n\t\t\treturn [[newObj], ...asyncValues];\n\t\t}\n\t\tconst newHead = {};\n\t\tfor (const [key, item] of Object.entries(data)) newHead[key] = encode(item, [key]);\n\t\tyield newHead;\n\t\tlet iterable = mergedIterables;\n\t\tif (opts.pingMs) iterable = withPing(mergedIterables, opts.pingMs);\n\t\tvar _iteratorAbruptCompletion = false;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError;\n\t\ttry {\n\t\t\tfor (var _iterator = (0, import_asyncIterator$1.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator$1.default)(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n\t\t\t\tconst value = _step.value;\n\t\t\t\tyield value;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator$1.default)(_iterator.return());\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) throw _iteratorError;\n\t\t\t}\n\t\t}\n\t});\n\treturn _createBatchStreamProducer.apply(this, arguments);\n}\n/**\n* JSON Lines stream producer\n* @see https://jsonlines.org/\n*/\nfunction jsonlStreamProducer(opts) {\n\tlet stream = readableStreamFrom(createBatchStreamProducer(opts));\n\tconst { serialize } = opts;\n\tif (serialize) stream = stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(PING_SYM);\n\t\telse controller.enqueue(serialize(chunk));\n\t} }));\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(" ");\n\t\telse controller.enqueue(JSON.stringify(chunk) + "\\n");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nvar AsyncError = class extends Error {\n\tconstructor(data) {\n\t\tsuper("Received error from server");\n\t\tthis.data = data;\n\t}\n};\nconst nodeJsStreamToReaderEsque = (source) => {\n\treturn { getReader() {\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\tsource.on("data", (chunk) => {\n\t\t\t\tcontroller.enqueue(chunk);\n\t\t\t});\n\t\t\tsource.on("end", () => {\n\t\t\t\tcontroller.close();\n\t\t\t});\n\t\t\tsource.on("error", (error) => {\n\t\t\t\tcontroller.error(error);\n\t\t\t});\n\t\t} });\n\t\treturn stream.getReader();\n\t} };\n};\nfunction createLineAccumulator(from) {\n\tconst reader = "getReader" in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n\tlet lineAggregate = "";\n\treturn new ReadableStream({\n\t\tasync pull(controller) {\n\t\t\tconst { done, value } = await reader.read();\n\t\t\tif (done) controller.close();\n\t\t\telse controller.enqueue(value);\n\t\t},\n\t\tcancel() {\n\t\t\treturn reader.cancel();\n\t\t}\n\t}).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tvar _parts$pop;\n\t\tlineAggregate += chunk;\n\t\tconst parts = lineAggregate.split("\\n");\n\t\tlineAggregate = (_parts$pop = parts.pop()) !== null && _parts$pop !== void 0 ? _parts$pop : "";\n\t\tfor (const part of parts) controller.enqueue(part);\n\t} }));\n}\nfunction createConsumerStream(from) {\n\tconst stream = createLineAccumulator(from);\n\tlet sentHead = false;\n\treturn stream.pipeThrough(new TransformStream({ transform(line, controller) {\n\t\tif (!sentHead) {\n\t\t\tconst head = JSON.parse(line);\n\t\t\tcontroller.enqueue(head);\n\t\t\tsentHead = true;\n\t\t} else {\n\t\t\tconst chunk = JSON.parse(line);\n\t\t\tcontroller.enqueue(chunk);\n\t\t}\n\t} }));\n}\n/**\n* Creates a handler for managing stream controllers and their lifecycle\n*/\nfunction createStreamsManager(abortController) {\n\tconst controllerMap = /* @__PURE__ */ new Map();\n\t/**\n\t* Checks if there are no pending controllers or deferred promises\n\t*/\n\tfunction isEmpty() {\n\t\treturn Array.from(controllerMap.values()).every((c) => c.closed);\n\t}\n\t/**\n\t* Creates a stream controller\n\t*/\n\tfunction createStreamController() {\n\t\tlet originalController;\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\toriginalController = controller;\n\t\t} });\n\t\tconst streamController = {\n\t\t\tenqueue: (v) => originalController.enqueue(v),\n\t\t\tclose: () => {\n\t\t\t\toriginalController.close();\n\t\t\t\tclear();\n\t\t\t\tif (isEmpty()) abortController.abort();\n\t\t\t},\n\t\t\tclosed: false,\n\t\t\tgetReaderResource: () => {\n\t\t\t\tconst reader = stream.getReader();\n\t\t\t\treturn makeResource(reader, () => {\n\t\t\t\t\treader.releaseLock();\n\t\t\t\t\tstreamController.close();\n\t\t\t\t});\n\t\t\t},\n\t\t\terror: (reason) => {\n\t\t\t\toriginalController.error(reason);\n\t\t\t\tclear();\n\t\t\t}\n\t\t};\n\t\tfunction clear() {\n\t\t\tObject.assign(streamController, {\n\t\t\t\tclosed: true,\n\t\t\t\tclose: () => {},\n\t\t\t\tenqueue: () => {},\n\t\t\t\tgetReaderResource: null,\n\t\t\t\terror: () => {}\n\t\t\t});\n\t\t}\n\t\treturn streamController;\n\t}\n\t/**\n\t* Gets or creates a stream controller\n\t*/\n\tfunction getOrCreate(chunkId) {\n\t\tlet c = controllerMap.get(chunkId);\n\t\tif (!c) {\n\t\t\tc = createStreamController();\n\t\t\tcontrollerMap.set(chunkId, c);\n\t\t}\n\t\treturn c;\n\t}\n\t/**\n\t* Cancels all pending controllers and rejects deferred promises\n\t*/\n\tfunction cancelAll(reason) {\n\t\tfor (const controller of controllerMap.values()) controller.error(reason);\n\t}\n\treturn {\n\t\tgetOrCreate,\n\t\tisEmpty,\n\t\tcancelAll\n\t};\n}\n/**\n* JSON Lines stream consumer\n* @see https://jsonlines.org/\n*/\nasync function jsonlStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet source = createConsumerStream(opts.from);\n\tif (deserialize) source = source.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tcontroller.enqueue(deserialize(chunk));\n\t} }));\n\tlet headDeferred = createDeferred();\n\tconst streamManager = createStreamsManager(opts.abortController);\n\tfunction decodeChunkDefinition(value) {\n\t\tconst [_path, type, chunkId] = value;\n\t\tconst controller = streamManager.getOrCreate(chunkId);\n\t\tswitch (type) {\n\t\t\tcase CHUNK_VALUE_TYPE_PROMISE: return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx3 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx3.u(controller.getReaderResource());\n\t\t\t\t\tconst { value: value$1 } = await reader.read();\n\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase PROMISE_STATUS_FULFILLED: return decode(data);\n\t\t\t\t\t\tcase PROMISE_STATUS_REJECTED:\n\t\t\t\t\t\t\tvar _opts$formatError3, _opts$formatError4;\n\t\t\t\t\t\t\tthrow (_opts$formatError3 = (_opts$formatError4 = opts.formatError) === null || _opts$formatError4 === void 0 ? void 0 : _opts$formatError4.call(opts, { error: data })) !== null && _opts$formatError3 !== void 0 ? _opts$formatError3 : new AsyncError(data);\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx3.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx3.d();\n\t\t\t\t}\n\t\t\t});\n\t\t\tcase CHUNK_VALUE_TYPE_ASYNC_ITERABLE: return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$2.default)(function* () {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx4 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx4.u(controller.getReaderResource());\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tconst { value: value$1 } = yield (0, import_awaitAsyncGenerator$1.default)(reader.read());\n\t\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_YIELD:\n\t\t\t\t\t\t\t\tyield decode(data);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_RETURN: return decode(data);\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_ERROR:\n\t\t\t\t\t\t\t\tvar _opts$formatError5, _opts$formatError6;\n\t\t\t\t\t\t\t\tthrow (_opts$formatError5 = (_opts$formatError6 = opts.formatError) === null || _opts$formatError6 === void 0 ? void 0 : _opts$formatError6.call(opts, { error: data })) !== null && _opts$formatError5 !== void 0 ? _opts$formatError5 : new AsyncError(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx4.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx4.d();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\tfunction decode(value) {\n\t\tconst [[data], ...asyncProps] = value;\n\t\tfor (const value$1 of asyncProps) {\n\t\t\tconst [key] = value$1;\n\t\t\tconst decoded = decodeChunkDefinition(value$1);\n\t\t\tif (key === null) return decoded;\n\t\t\tdata[key] = decoded;\n\t\t}\n\t\treturn data;\n\t}\n\tconst closeOrAbort = (reason) => {\n\t\theadDeferred === null || headDeferred === void 0 || headDeferred.reject(reason);\n\t\tstreamManager.cancelAll(reason);\n\t};\n\tsource.pipeTo(new WritableStream({\n\t\twrite(chunkOrHead) {\n\t\t\tif (headDeferred) {\n\t\t\t\tconst head = chunkOrHead;\n\t\t\t\tfor (const [key, value] of Object.entries(chunkOrHead)) {\n\t\t\t\t\tconst parsed = decode(value);\n\t\t\t\t\thead[key] = parsed;\n\t\t\t\t}\n\t\t\t\theadDeferred.resolve(head);\n\t\t\t\theadDeferred = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst chunk = chunkOrHead;\n\t\t\tconst [idx] = chunk;\n\t\t\tconst controller = streamManager.getOrCreate(idx);\n\t\t\tcontroller.enqueue(chunk);\n\t\t},\n\t\tclose: () => closeOrAbort(new Error("Stream closed")),\n\t\tabort: closeOrAbort\n\t}), { signal: opts.abortController.signal }).catch((error) => {\n\t\tvar _opts$onError4;\n\t\t(_opts$onError4 = opts.onError) === null || _opts$onError4 === void 0 || _opts$onError4.call(opts, { error });\n\t\tcloseOrAbort(error);\n\t});\n\treturn [await headDeferred.promise, streamManager];\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\nvar require_asyncGeneratorDelegate = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js"(exports, module) {\n\tvar OverloadYield = require_OverloadYield();\n\tfunction _asyncGeneratorDelegate$1(t) {\n\t\tvar e = {}, n = !1;\n\t\tfunction pump(e$1, r) {\n\t\t\treturn n = !0, r = new Promise(function(n$1) {\n\t\t\t\tn$1(t[e$1](r));\n\t\t\t}), {\n\t\t\t\tdone: !1,\n\t\t\t\tvalue: new OverloadYield(r, 1)\n\t\t\t};\n\t\t}\n\t\treturn e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function() {\n\t\t\treturn this;\n\t\t}, e.next = function(t$1) {\n\t\t\treturn n ? (n = !1, t$1) : pump("next", t$1);\n\t\t}, "function" == typeof t["throw"] && (e["throw"] = function(t$1) {\n\t\t\tif (n) throw n = !1, t$1;\n\t\t\treturn pump("throw", t$1);\n\t\t}), "function" == typeof t["return"] && (e["return"] = function(t$1) {\n\t\t\treturn n ? (n = !1, t$1) : pump("return", t$1);\n\t\t}), e;\n\t}\n\tmodule.exports = _asyncGeneratorDelegate$1, module.exports.__esModule = true, module.exports["default"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/sse.ts\nvar import_asyncIterator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nvar import_awaitAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_asyncGeneratorDelegate = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncGeneratorDelegate(), 1);\nvar import_usingCtx = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nconst PING_EVENT = "ping";\nconst SERIALIZED_ERROR_EVENT = "serialized-error";\nconst CONNECTED_EVENT = "connected";\nconst RETURN_EVENT = "return";\n/**\n*\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamProducer(opts) {\n\tvar _opts$ping$enabled, _opts$ping, _opts$ping$intervalMs, _opts$ping2, _opts$client;\n\tconst { serialize = _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.identity } = opts;\n\tconst ping = {\n\t\tenabled: (_opts$ping$enabled = (_opts$ping = opts.ping) === null || _opts$ping === void 0 ? void 0 : _opts$ping.enabled) !== null && _opts$ping$enabled !== void 0 ? _opts$ping$enabled : false,\n\t\tintervalMs: (_opts$ping$intervalMs = (_opts$ping2 = opts.ping) === null || _opts$ping2 === void 0 ? void 0 : _opts$ping2.intervalMs) !== null && _opts$ping$intervalMs !== void 0 ? _opts$ping$intervalMs : 1e3\n\t};\n\tconst client = (_opts$client = opts.client) !== null && _opts$client !== void 0 ? _opts$client : {};\n\tif (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n\tfunction generator() {\n\t\treturn _generator.apply(this, arguments);\n\t}\n\tfunction _generator() {\n\t\t_generator = (0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\t\tyield {\n\t\t\t\tevent: CONNECTED_EVENT,\n\t\t\t\tdata: JSON.stringify(client)\n\t\t\t};\n\t\t\tlet iterable = opts.data;\n\t\t\tif (opts.emitAndEndImmediately) iterable = takeWithGrace(iterable, {\n\t\t\t\tcount: 1,\n\t\t\t\tgracePeriodMs: 1\n\t\t\t});\n\t\t\tif (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) iterable = withMaxDuration(iterable, { maxDurationMs: opts.maxDurationMs });\n\t\t\tif (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) iterable = withPing(iterable, ping.intervalMs);\n\t\t\tlet value;\n\t\t\tlet chunk;\n\t\t\tvar _iteratorAbruptCompletion = false;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError;\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = (0, import_asyncIterator.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator.default)(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n\t\t\t\t\tvalue = _step.value;\n\t\t\t\t\t{\n\t\t\t\t\t\tif (value === PING_SYM) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tevent: PING_EVENT,\n\t\t\t\t\t\t\t\tdata: ""\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchunk = (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.isTrackedEnvelope)(value) ? {\n\t\t\t\t\t\t\tid: value[0],\n\t\t\t\t\t\t\tdata: value[1]\n\t\t\t\t\t\t} : { data: value };\n\t\t\t\t\t\tchunk.data = JSON.stringify(serialize(chunk.data));\n\t\t\t\t\t\tyield chunk;\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t\tchunk = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator.default)(_iterator.return());\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) throw _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn _generator.apply(this, arguments);\n\t}\n\tfunction generatorWithErrorHandling() {\n\t\treturn _generatorWithErrorHandling.apply(this, arguments);\n\t}\n\tfunction _generatorWithErrorHandling() {\n\t\t_generatorWithErrorHandling = (0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\t\ttry {\n\t\t\t\tyield* (0, import_asyncGeneratorDelegate.default)((0, import_asyncIterator.default)(generator()));\n\t\t\t\tyield {\n\t\t\t\t\tevent: RETURN_EVENT,\n\t\t\t\t\tdata: ""\n\t\t\t\t};\n\t\t\t} catch (cause) {\n\t\t\t\tvar _opts$formatError, _opts$formatError2;\n\t\t\t\tif (isAbortError(cause)) return;\n\t\t\t\tconst error = (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\t\t\t\tconst data = (_opts$formatError = (_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, { error })) !== null && _opts$formatError !== void 0 ? _opts$formatError : null;\n\t\t\t\tyield {\n\t\t\t\t\tevent: SERIALIZED_ERROR_EVENT,\n\t\t\t\t\tdata: JSON.stringify(serialize(data))\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\treturn _generatorWithErrorHandling.apply(this, arguments);\n\t}\n\tconst stream = readableStreamFrom(generatorWithErrorHandling());\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif ("event" in chunk) controller.enqueue(`event: ${chunk.event}\\n`);\n\t\tif ("data" in chunk) controller.enqueue(`data: ${chunk.data}\\n`);\n\t\tif ("id" in chunk) controller.enqueue(`id: ${chunk.id}\\n`);\n\t\tif ("comment" in chunk) controller.enqueue(`: ${chunk.comment}\\n`);\n\t\tcontroller.enqueue("\\n\\n");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n\ttry {\n\t\tvar _usingCtx$1 = (0, import_usingCtx.default)();\n\t\tconst timeoutPromise = _usingCtx$1.u(timerResource(opts.timeoutMs));\n\t\tconst res = await Unpromise.race([opts.promise, timeoutPromise.start()]);\n\t\tif (res === disposablePromiseTimerResult) return await opts.onTimeout();\n\t\treturn res;\n\t} catch (_) {\n\t\t_usingCtx$1.e = _;\n\t} finally {\n\t\t_usingCtx$1.d();\n\t}\n}\n/**\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet clientOptions = {};\n\tconst signal = opts.signal;\n\tlet _es = null;\n\tconst createStream = () => new ReadableStream({\n\t\tasync start(controller) {\n\t\t\tconst [url, init] = await Promise.all([opts.url(), opts.init()]);\n\t\t\tconst eventSource = _es = new opts.EventSource(url, init);\n\t\t\tcontroller.enqueue({\n\t\t\t\ttype: "connecting",\n\t\t\t\teventSource: _es,\n\t\t\t\tevent: null\n\t\t\t});\n\t\t\teventSource.addEventListener(CONNECTED_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst options = JSON.parse(msg.data);\n\t\t\t\tclientOptions = options;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: "connected",\n\t\t\t\t\toptions,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: "serialized-error",\n\t\t\t\t\terror: deserialize(JSON.parse(msg.data)),\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(PING_EVENT, () => {\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: "ping",\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(RETURN_EVENT, () => {\n\t\t\t\teventSource.close();\n\t\t\t\tcontroller.close();\n\t\t\t\t_es = null;\n\t\t\t});\n\t\t\teventSource.addEventListener("error", (event) => {\n\t\t\t\tif (eventSource.readyState === eventSource.CLOSED) controller.error(event);\n\t\t\t\telse controller.enqueue({\n\t\t\t\t\ttype: "connecting",\n\t\t\t\t\teventSource,\n\t\t\t\t\tevent\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener("message", (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst chunk = deserialize(JSON.parse(msg.data));\n\t\t\t\tconst def = { data: chunk };\n\t\t\t\tif (msg.lastEventId) def.id = msg.lastEventId;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: "data",\n\t\t\t\t\tdata: def,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\tconst onAbort = () => {\n\t\t\t\ttry {\n\t\t\t\t\teventSource.close();\n\t\t\t\t\tcontroller.close();\n\t\t\t\t} catch (_unused) {}\n\t\t\t};\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener("abort", onAbort);\n\t\t},\n\t\tcancel() {\n\t\t\t_es === null || _es === void 0 || _es.close();\n\t\t}\n\t});\n\tconst getStreamResource = () => {\n\t\tlet stream = createStream();\n\t\tlet reader = stream.getReader();\n\t\tasync function dispose() {\n\t\t\tawait reader.cancel();\n\t\t\t_es = null;\n\t\t}\n\t\treturn makeAsyncResource({\n\t\t\tread() {\n\t\t\t\treturn reader.read();\n\t\t\t},\n\t\t\tasync recreate() {\n\t\t\t\tawait dispose();\n\t\t\t\tstream = createStream();\n\t\t\t\treader = stream.getReader();\n\t\t\t}\n\t\t}, dispose);\n\t};\n\treturn (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\ttry {\n\t\t\tvar _usingCtx3 = (0, import_usingCtx.default)();\n\t\t\tconst stream = _usingCtx3.a(getStreamResource());\n\t\t\twhile (true) {\n\t\t\t\tlet promise = stream.read();\n\t\t\t\tconst timeoutMs = clientOptions.reconnectAfterInactivityMs;\n\t\t\t\tif (timeoutMs) promise = withTimeout({\n\t\t\t\t\tpromise,\n\t\t\t\t\ttimeoutMs,\n\t\t\t\t\tonTimeout: async () => {\n\t\t\t\t\t\tconst res = {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: "timeout",\n\t\t\t\t\t\t\t\tms: timeoutMs,\n\t\t\t\t\t\t\t\teventSource: _es\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdone: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tawait stream.recreate();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst result = yield (0, import_awaitAsyncGenerator.default)(promise);\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tyield result.value;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx3.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator.default)(_usingCtx3.d());\n\t\t}\n\t}));\n}\nconst sseHeaders = {\n\t"Content-Type": "text/event-stream",\n\t"Cache-Control": "no-cache, no-transform",\n\t"X-Accel-Buffering": "no",\n\tConnection: "keep-alive"\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/resolveResponse.ts\nvar import_wrapAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\nfunction errorToAsyncIterable(err) {\n\treturn (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator.default)(function* () {\n\t\tthrow err;\n\t}));\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n\tmutation: ["POST"],\n\tquery: ["GET"],\n\tsubscription: ["GET"]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n\tmutation: ["POST"],\n\tquery: ["GET", "POST"],\n\tsubscription: ["GET", "POST"]\n};\nfunction initResponse(initOpts) {\n\tvar _responseMeta, _info$calls$find$proc, _info$calls$find;\n\tconst { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n\tlet status = untransformedJSON ? (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getHTTPStatusCode)(untransformedJSON) : 200;\n\tconst eagerGeneration = !untransformedJSON;\n\tconst data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [untransformedJSON];\n\tconst meta = (_responseMeta = responseMeta === null || responseMeta === void 0 ? void 0 : responseMeta({\n\t\tctx,\n\t\tinfo,\n\t\tpaths: info === null || info === void 0 ? void 0 : info.calls.map((call) => call.path),\n\t\tdata,\n\t\terrors,\n\t\teagerGeneration,\n\t\ttype: (_info$calls$find$proc = info === null || info === void 0 || (_info$calls$find = info.calls.find((call) => {\n\t\t\tvar _call$procedure;\n\t\t\treturn (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n\t\t})) === null || _info$calls$find === void 0 || (_info$calls$find = _info$calls$find.procedure) === null || _info$calls$find === void 0 ? void 0 : _info$calls$find._def.type) !== null && _info$calls$find$proc !== void 0 ? _info$calls$find$proc : "unknown"\n\t})) !== null && _responseMeta !== void 0 ? _responseMeta : {};\n\tif (meta.headers) {\n\t\tif (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries()) headers.append(key, value);\n\t\telse\n /**\n\t\t* @deprecated, delete in v12\n\t\t*/\n\t\tfor (const [key, value] of Object.entries(meta.headers)) if (Array.isArray(value)) for (const v of value) headers.append(key, v);\n\t\telse if (typeof value === "string") headers.set(key, value);\n\t}\n\tif (meta.status) status = meta.status;\n\treturn { status };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n\tconst { router, req, onError } = errorOpts.opts;\n\tconst error = (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\tonError === null || onError === void 0 || onError({\n\t\terror,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx,\n\t\ttype: errorOpts.type,\n\t\treq\n\t});\n\tconst untransformedJSON = { error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\tconfig: router._def._config,\n\t\terror,\n\t\ttype: errorOpts.type,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx\n\t}) };\n\tconst transformedJSON = (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(router._def._config, untransformedJSON);\n\tconst body = JSON.stringify(transformedJSON);\n\treturn {\n\t\terror,\n\t\tuntransformedJSON,\n\t\tbody\n\t};\n}\n/**\n* Check if a value is a stream-like object\n* - if it\'s an async iterable\n* - if it\'s an object with async iterables or promises\n*/\nfunction isDataStream(v) {\n\tif (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(v)) return false;\n\tif ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(v)) return true;\n\treturn Object.values(v).some(isPromise) || Object.values(v).some(_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n\tvar _ref, _opts$allowBatching, _opts$batching, _opts$allowMethodOver, _config$sse$enabled, _config$sse;\n\tconst { router, req } = opts;\n\tconst headers = new Headers([["vary", "trpc-accept"]]);\n\tconst config = router._def._config;\n\tconst url = new URL(req.url);\n\tif (req.method === "HEAD") return new Response(null, { status: 204 });\n\tconst allowBatching = (_ref = (_opts$allowBatching = opts.allowBatching) !== null && _opts$allowBatching !== void 0 ? _opts$allowBatching : (_opts$batching = opts.batching) === null || _opts$batching === void 0 ? void 0 : _opts$batching.enabled) !== null && _ref !== void 0 ? _ref : true;\n\tconst allowMethodOverride = ((_opts$allowMethodOver = opts.allowMethodOverride) !== null && _opts$allowMethodOver !== void 0 ? _opts$allowMethodOver : false) && req.method === "POST";\n\tconst infoTuple = await (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async () => {\n\t\ttry {\n\t\t\treturn [void 0, await getRequestInfo({\n\t\t\t\treq,\n\t\t\t\tpath: decodeURIComponent(opts.path),\n\t\t\t\trouter,\n\t\t\t\tsearchParams: url.searchParams,\n\t\t\t\theaders: opts.req.headers,\n\t\t\t\turl\n\t\t\t})];\n\t\t} catch (cause) {\n\t\t\treturn [(0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause), void 0];\n\t\t}\n\t});\n\tconst ctxManager = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(() => {\n\t\tlet result = void 0;\n\t\treturn {\n\t\t\tvalueOrUndefined: () => {\n\t\t\t\tif (!result) return void 0;\n\t\t\t\treturn result[1];\n\t\t\t},\n\t\t\tvalue: () => {\n\t\t\t\tconst [err, ctx] = result;\n\t\t\t\tif (err) throw err;\n\t\t\t\treturn ctx;\n\t\t\t},\n\t\t\tcreate: async (info) => {\n\t\t\t\tif (result) throw new Error("This should only be called once - report a bug in tRPC");\n\t\t\t\ttry {\n\t\t\t\t\tconst ctx = await opts.createContext({ info });\n\t\t\t\t\tresult = [void 0, ctx];\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tresult = [(0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause), void 0];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\tconst methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n\t/**\n\t* @deprecated\n\t*/\n\tconst isStreamCall = req.headers.get("trpc-accept") === "application/jsonl";\n\tconst experimentalSSE = (_config$sse$enabled = (_config$sse = config.sse) === null || _config$sse === void 0 ? void 0 : _config$sse.enabled) !== null && _config$sse$enabled !== void 0 ? _config$sse$enabled : true;\n\ttry {\n\t\tconst [infoError, info] = infoTuple;\n\t\tif (infoError) throw infoError;\n\t\tif (info.isBatchCall && !allowBatching) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: "BAD_REQUEST",\n\t\t\tmessage: `Batching is not enabled on the server`\n\t\t});\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (isStreamCall && !info.isBatchCall) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tmessage: `Streaming requests must be batched (you can do a batch of 1)`,\n\t\t\tcode: "BAD_REQUEST"\n\t\t});\n\t\tawait ctxManager.create(info);\n\t\tconst rpcCalls = info.calls.map(async (call) => {\n\t\t\tconst proc = call.procedure;\n\t\t\ttry {\n\t\t\t\tif (opts.error) throw opts.error;\n\t\t\t\tif (!proc) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: "NOT_FOUND",\n\t\t\t\t\tmessage: `No procedure found on path "${call.path}"`\n\t\t\t\t});\n\t\t\t\tif (!methodMapper[proc._def.type].includes(req.method)) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: "METHOD_NOT_SUPPORTED",\n\t\t\t\t\tmessage: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path "${call.path}"`\n\t\t\t\t});\n\t\t\t\tif (proc._def.type === "subscription") {\n\t\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\t\tif (info.isBatchCall) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\tcode: "BAD_REQUEST",\n\t\t\t\t\t\tmessage: `Cannot batch subscription calls`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst data = await proc({\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tgetRawInput: call.getRawInput,\n\t\t\t\t\tctx: ctxManager.value(),\n\t\t\t\t\ttype: proc._def.type,\n\t\t\t\t\tsignal: opts.req.signal\n\t\t\t\t});\n\t\t\t\treturn [void 0, { data }];\n\t\t\t} catch (cause) {\n\t\t\t\tvar _opts$onError, _call$procedure$_def$, _call$procedure2;\n\t\t\t\tconst error = (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\t\t\t\tconst input = call.result();\n\t\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\terror,\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tinput,\n\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\ttype: (_call$procedure$_def$ = (_call$procedure2 = call.procedure) === null || _call$procedure2 === void 0 ? void 0 : _call$procedure2._def.type) !== null && _call$procedure$_def$ !== void 0 ? _call$procedure$_def$ : "unknown",\n\t\t\t\t\treq: opts.req\n\t\t\t\t});\n\t\t\t\treturn [error, void 0];\n\t\t\t}\n\t\t});\n\t\tif (!info.isBatchCall) {\n\t\t\tconst [call] = info.calls;\n\t\t\tconst [error, result] = await rpcCalls[0];\n\t\t\tswitch (info.type) {\n\t\t\t\tcase "unknown":\n\t\t\t\tcase "mutation":\n\t\t\t\tcase "query": {\n\t\t\t\t\theaders.set("content-type", "application/json");\n\t\t\t\t\tif (isDataStream(result === null || result === void 0 ? void 0 : result.data)) throw new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\tcode: "UNSUPPORTED_MEDIA_TYPE",\n\t\t\t\t\t\tmessage: "Cannot use stream-like response in non-streaming request - use httpBatchStreamLink"\n\t\t\t\t\t});\n\t\t\t\t\tconst res = error ? { error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\ttype: info.type\n\t\t\t\t\t}) } : { result: { data: result.data } };\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: error ? [error] : [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: [res]\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(JSON.stringify((0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, res)), {\n\t\t\t\t\t\tstatus: headResponse$1.status,\n\t\t\t\t\t\theaders\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcase "subscription": {\n\t\t\t\t\tconst iterable = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(() => {\n\t\t\t\t\t\tif (error) return errorToAsyncIterable(error);\n\t\t\t\t\t\tif (!experimentalSSE) return errorToAsyncIterable(new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\t\tcode: "METHOD_NOT_SUPPORTED",\n\t\t\t\t\t\t\tmessage: "Missing experimental flag \\"sseSubscriptions\\""\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (!(0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) && !(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(result.data)) return errorToAsyncIterable(new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\t\tmessage: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n\t\t\t\t\t\t\tcode: "INTERNAL_SERVER_ERROR"\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tconst dataAsIterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : result.data;\n\t\t\t\t\t\treturn dataAsIterable;\n\t\t\t\t\t});\n\t\t\t\t\tconst stream = sseStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.sse), {}, {\n\t\t\t\t\t\tdata: iterable,\n\t\t\t\t\t\tserialize: (v) => config.transformer.output.serialize(v),\n\t\t\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\t\t\tvar _call$procedure$_def$2, _call$procedure3, _opts$onError2;\n\t\t\t\t\t\t\tconst error$1 = (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n\t\t\t\t\t\t\tconst input = call === null || call === void 0 ? void 0 : call.result();\n\t\t\t\t\t\t\tconst path = call === null || call === void 0 ? void 0 : call.path;\n\t\t\t\t\t\t\tconst type = (_call$procedure$_def$2 = call === null || call === void 0 || (_call$procedure3 = call.procedure) === null || _call$procedure3 === void 0 ? void 0 : _call$procedure3._def.type) !== null && _call$procedure$_def$2 !== void 0 ? _call$procedure$_def$2 : "unknown";\n\t\t\t\t\t\t\t(_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst shape = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t\tfor (const [key, value] of Object.entries(sseHeaders)) headers.set(key, value);\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: null\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(stream, {\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tstatus: headResponse$1.status\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info.accept === "application/jsonl") {\n\t\t\theaders.set("content-type", "application/json");\n\t\t\theaders.set("transfer-encoding", "chunked");\n\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\tinfo,\n\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\terrors: [],\n\t\t\t\theaders,\n\t\t\t\tuntransformedJSON: null\n\t\t\t});\n\t\t\tconst stream = jsonlStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.jsonl), {}, {\n\t\t\t\tmaxDepth: Infinity,\n\t\t\t\tdata: rpcCalls.map(async (res) => {\n\t\t\t\t\tconst [error, result] = await res;\n\t\t\t\t\tconst call = info.calls[0];\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tvar _procedure$_def$type, _procedure;\n\t\t\t\t\t\treturn { error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\t\ttype: (_procedure$_def$type = (_procedure = call.procedure) === null || _procedure === void 0 ? void 0 : _procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : "unknown"\n\t\t\t\t\t\t}) };\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t* Not very pretty, but we need to wrap nested data in promises\n\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t*/\n\t\t\t\t\tconst iterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : Promise.resolve(result.data);\n\t\t\t\t\treturn { result: Promise.resolve({ data: iterable }) };\n\t\t\t\t}),\n\t\t\t\tserialize: (data) => config.transformer.output.serialize(data),\n\t\t\t\tonError: (cause) => {\n\t\t\t\t\tvar _opts$onError3, _info$type;\n\t\t\t\t\t(_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n\t\t\t\t\t\terror: (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n\t\t\t\t\t\tpath: void 0,\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\ttype: (_info$type = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type !== void 0 ? _info$type : "unknown"\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\tvar _call$procedure$_def$3, _call$procedure4;\n\t\t\t\t\tconst call = info === null || info === void 0 ? void 0 : info.calls[errorOpts.path[0]];\n\t\t\t\t\tconst error = (0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n\t\t\t\t\tconst input = call === null || call === void 0 ? void 0 : call.result();\n\t\t\t\t\tconst path = call === null || call === void 0 ? void 0 : call.path;\n\t\t\t\t\tconst type = (_call$procedure$_def$3 = call === null || call === void 0 || (_call$procedure4 = call.procedure) === null || _call$procedure4 === void 0 ? void 0 : _call$procedure4._def.type) !== null && _call$procedure$_def$3 !== void 0 ? _call$procedure$_def$3 : "unknown";\n\t\t\t\t\tconst shape = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\ttype\n\t\t\t\t\t});\n\t\t\t\t\treturn shape;\n\t\t\t\t}\n\t\t\t}));\n\t\t\treturn new Response(stream, {\n\t\t\t\theaders,\n\t\t\t\tstatus: headResponse$1.status\n\t\t\t});\n\t\t}\n\t\t/**\n\t\t* Non-streaming response:\n\t\t* - await all responses in parallel, blocking on the slowest one\n\t\t* - create headers with known response body\n\t\t* - return a complete HTTPResponse\n\t\t*/\n\t\theaders.set("content-type", "application/json");\n\t\tconst results = (await Promise.all(rpcCalls)).map((res) => {\n\t\t\tconst [error, result] = res;\n\t\t\tif (error) return res;\n\t\t\tif (isDataStream(result.data)) return [new _tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\tcode: "UNSUPPORTED_MEDIA_TYPE",\n\t\t\t\tmessage: "Cannot use stream-like response in non-streaming request - use httpBatchStreamLink"\n\t\t\t}), void 0];\n\t\t\treturn res;\n\t\t});\n\t\tconst resultAsRPCResponse = results.map(([error, result], index) => {\n\t\t\tconst call = info.calls[index];\n\t\t\tif (error) {\n\t\t\t\tvar _call$procedure$_def$4, _call$procedure5;\n\t\t\t\treturn { error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\tconfig,\n\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\terror,\n\t\t\t\t\tinput: call.result(),\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\ttype: (_call$procedure$_def$4 = (_call$procedure5 = call.procedure) === null || _call$procedure5 === void 0 ? void 0 : _call$procedure5._def.type) !== null && _call$procedure$_def$4 !== void 0 ? _call$procedure$_def$4 : "unknown"\n\t\t\t\t}) };\n\t\t\t}\n\t\t\treturn { result: { data: result.data } };\n\t\t});\n\t\tconst errors = results.map(([error]) => error).filter(Boolean);\n\t\tconst headResponse = initResponse({\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON: resultAsRPCResponse,\n\t\t\terrors,\n\t\t\theaders\n\t\t});\n\t\treturn new Response(JSON.stringify((0,_tracked_Bp72jHif_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, resultAsRPCResponse)), {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t} catch (cause) {\n\t\tvar _info$type2;\n\t\tconst [_infoError, info] = infoTuple;\n\t\tconst ctx = ctxManager.valueOrUndefined();\n\t\tconst { error, untransformedJSON, body } = caughtErrorToData(cause, {\n\t\t\topts,\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\ttype: (_info$type2 = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type2 !== void 0 ? _info$type2 : "unknown"\n\t\t});\n\t\tconst headResponse = initResponse({\n\t\t\tctx,\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON,\n\t\t\terrors: [error],\n\t\t\theaders\n\t\t});\n\t\treturn new Response(body, {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t}\n}\n\n//#endregion\n\n//# sourceMappingURL=resolveResponse-Hga1xOO1.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9yZXNvbHZlUmVzcG9uc2UtSGdhMXhPTzEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvSjtBQUNWO0FBQzlDO0FBQ1I7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2REFBUTtBQUNmO0FBQ0Esd0dBQXdHLHlDQUF5QyxJQUFJLElBQUksYUFBYSxjQUFjO0FBQ3BMO0FBQ0EsR0FBRztBQUNILFlBQVksNERBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDREQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixvRUFBTyxDQUFDLGtGQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0REFBUztBQUNsQyxjQUFjLDREQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCO0FBQzlCLFFBQVEsNkRBQVEsb0JBQW9CLDREQUFTO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMkJBQTJCLHlFQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQVEsMkZBQTJGLFlBQVksSUFBSSxhQUFhO0FBQzNKO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsNERBQVM7QUFDekM7QUFDQSxtREFBbUQsNkJBQTZCO0FBQ2hGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxVQUFVLE1BQU07QUFDaEIsdUNBQXVDLDREQUFTO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQix5RUFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLHVDQUF1Qyw0REFBUztBQUNoRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5RUFBa0I7QUFDdkMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQVM7QUFDcEI7QUFDQSwwRUFBMEUsZ0NBQWdDO0FBQzFHLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQU8sQ0FBQyxtRkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxTQUFTO0FBQ3JGO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFFBQVE7QUFDcEY7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4Qix3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpQ0FBaUMsYUFBYTtBQUM5QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpQ0FBaUMsYUFBYTtBQUM5QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVFQUFVLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFFBQVE7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDRCQUE0Qix1RUFBVSxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esa0NBQWtDLHVFQUFVLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGlDQUFpQyx1RUFBVSxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esd0JBQXdCLG9FQUFPO0FBQy9CLG1DQUFtQyxvRUFBTztBQUMxQyxrQ0FBa0Msb0VBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCLFVBQVUsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0IsVUFBVSxlQUFlO0FBQ2hFLEdBQUcsYUFBYSxpQ0FBaUMscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isb0VBQU87QUFDL0IsbUNBQW1DLG9FQUFPO0FBQzFDLGtDQUFrQyxvRUFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQ0FBZ0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixvRUFBTztBQUMvQixtQ0FBbUMsb0VBQU87QUFDMUMsa0NBQWtDLG9FQUFPO0FBQ3pDO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCLFVBQVUsZUFBZSxlQUFlO0FBQy9FLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHVFQUFVLEdBQUc7QUFDekM7QUFDQTtBQUNBLHdGQUF3RixJQUFJO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG1DQUFtQyxvRUFBTztBQUMxQyxrQ0FBa0Msb0VBQU87QUFDekMsd0JBQXdCLG9FQUFPO0FBQy9CLDZCQUE2QixvRUFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBUSxXQUFXLCtEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvRUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLCtHQUErRztBQUM3TDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRSx5RUFBeUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHdEQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnS0FBZ0ssYUFBYTtBQUM3SztBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdEQUFnRCx3REFBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUssYUFBYTtBQUM5SztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxLQUFLLHFDQUFxQztBQUM1QztBQUNBLHVHQUF1RyxPQUFPO0FBQzlHO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyx1RUFBVSxHQUFHO0FBQ2xEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQU87QUFDbEMsaUNBQWlDLG9FQUFPO0FBQ3hDLGtDQUFrQyxvRUFBTztBQUN6QyxvQ0FBb0Msb0VBQU87QUFDM0Msc0JBQXNCLG9FQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZLHlEQUFRLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1QQUFtUCxpQkFBaUIscUNBQXFDLGtDQUFrQztBQUMzVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwrSEFBK0gsbUNBQW1DO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDZHQUE2RztBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdFQUFpQjtBQUMvQjtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQiw4RUFBdUI7QUFDekMsbUtBQW1LLE9BQU87QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQscURBQXFELFlBQVk7QUFDakUsbURBQW1ELFdBQVc7QUFDOUQsK0NBQStDLFNBQVM7QUFDeEQsa0RBQWtELGNBQWM7QUFDaEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsUUFBUSx3REFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxvRUFBTztBQUN2QywyQkFBMkIsb0VBQU8sQ0FBQyxrRkFBcUI7QUFDeEQ7QUFDQSxRQUFRLHdEQUFHO0FBQ1g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1FQUFtRTtBQUM1RSxrQ0FBa0MsOEVBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsdUJBQXVCO0FBQ2hDLGVBQWUsOEVBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDZCQUE2QixPQUFPLDBFQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRix5QkFBeUIsNEVBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2REFBUTtBQUNkLEtBQUssb0VBQWU7QUFDcEIsa0VBQWtFLGdFQUFlO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0EseUJBQXlCLHdEQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKLFdBQVcsOEVBQXVCO0FBQ2xDO0FBQ0EsRUFBRTtBQUNGLG9CQUFvQix3REFBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0EsTUFBTTtBQUNOLGVBQWUsOEVBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNERBQVM7QUFDN0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1EQUFtRCw0REFBUztBQUM1RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQVM7QUFDbEM7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RCxLQUFLO0FBQ0wsc0VBQXNFLDREQUFTO0FBQy9FO0FBQ0EsNkJBQTZCLFdBQVcsY0FBYyxnQkFBZ0IscUJBQXFCLFVBQVU7QUFDckcsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUMsNERBQVM7QUFDOUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsTUFBTTtBQUM1QixLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsOEVBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDREQUFTO0FBQ3ZHO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLE9BQU8sMEVBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJLElBQUksVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0MsNEVBQXFCO0FBQzdEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQix3REFBRztBQUN6QjtBQUNBLDREQUE0RCw0REFBUztBQUNyRTtBQUNBO0FBQ0EsT0FBTztBQUNQLFdBQVcscUVBQVksa0JBQWtCLG9FQUFlLCtDQUErQyw0REFBUztBQUNoSCxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBLE9BQU87QUFDUCw2QkFBNkIscUVBQVksZ0JBQWdCLGtGQUF5QjtBQUNsRjtBQUNBLE1BQU07QUFDTiw0R0FBNEcsaUJBQWlCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhFQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixxQkFBcUIsMEVBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNEdBQTRHLG1CQUFtQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sMEVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUVBQVksZ0JBQWdCLGtGQUF5QjtBQUMzRSxjQUFjLDBCQUEwQixnQkFBZ0I7QUFDeEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RUFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhFQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEVBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNERBQVM7QUFDdkQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTywwRUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLFVBQVU7QUFDdEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLDRFQUFxQjtBQUMxRDtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDb1g7QUFDcFgiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2VnZ3VcXExFU2lBQlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yXFxub2RlX21vZHVsZXNcXEB0cnBjXFxzZXJ2ZXJcXGRpc3RcXHJlc29sdmVSZXNwb25zZS1IZ2ExeE9PMS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19jb21tb25KUywgX190b0VTTSwgZ2V0RXJyb3JTaGFwZSwgZ2V0SFRUUFN0YXR1c0NvZGUsIHJlcXVpcmVfZGVmaW5lUHJvcGVydHksIHJlcXVpcmVfb2JqZWN0U3ByZWFkMiB9IGZyb20gXCIuL2dldEVycm9yU2hhcGUtVWhscmw0QmsubWpzXCI7XG5pbXBvcnQgeyBUUlBDRXJyb3IsIGdldFByb2NlZHVyZUF0UGF0aCwgZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24sIGlzVHJhY2tlZEVudmVsb3BlLCB0cmFuc2Zvcm1UUlBDUmVzcG9uc2UgfSBmcm9tIFwiLi90cmFja2VkLUJwNzJqSGlmLm1qc1wiO1xuaW1wb3J0IHsgaWRlbnRpdHksIGlzQXN5bmNJdGVyYWJsZSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIHJ1biB9IGZyb20gXCIuL3V0aWxzLURkYmJyRGt1Lm1qc1wiO1xuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBvYnNlcnZhYmxlVG9Bc3luY0l0ZXJhYmxlIH0gZnJvbSBcIi4vb2JzZXJ2YWJsZS1VTU8zdlVhXy5tanNcIjtcblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9wYXJzZUNvbm5lY3Rpb25QYXJhbXMudHNcbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21Vbmtub3duKHBhcnNlZCkge1xuXHR0cnkge1xuXHRcdGlmIChwYXJzZWQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXHRcdGlmICghaXNPYmplY3QocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb2JqZWN0XCIpO1xuXHRcdGNvbnN0IG5vblN0cmluZ1ZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHBhcnNlZCkuZmlsdGVyKChbX2tleSwgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpO1xuXHRcdGlmIChub25TdHJpbmdWYWx1ZXMubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBjb25uZWN0aW9uUGFyYW1zIHRvIGJlIHN0cmluZyB2YWx1ZXMuIEdvdCAke25vblN0cmluZ1ZhbHVlcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fTogJHt0eXBlb2YgdmFsdWV9YCkuam9pbihcIiwgXCIpfWApO1xuXHRcdHJldHVybiBwYXJzZWQ7XG5cdH0gY2F0Y2ggKGNhdXNlKSB7XG5cdFx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRjb2RlOiBcIlBBUlNFX0VSUk9SXCIsXG5cdFx0XHRtZXNzYWdlOiBcIkludmFsaWQgY29ubmVjdGlvbiBwYXJhbXMgc2hhcGVcIixcblx0XHRcdGNhdXNlXG5cdFx0fSk7XG5cdH1cbn1cbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoc3RyKSB7XG5cdGxldCBwYXJzZWQ7XG5cdHRyeSB7XG5cdFx0cGFyc2VkID0gSlNPTi5wYXJzZShzdHIpO1xuXHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJQQVJTRV9FUlJPUlwiLFxuXHRcdFx0bWVzc2FnZTogXCJOb3QgSlNPTi1wYXJzYWJsZSBxdWVyeSBwYXJhbXNcIixcblx0XHRcdGNhdXNlXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21Vbmtub3duKHBhcnNlZCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9jb250ZW50VHlwZS50c1xudmFyIGltcG9ydF9vYmplY3RTcHJlYWQyJDEgPSBfX3RvRVNNKHJlcXVpcmVfb2JqZWN0U3ByZWFkMigpLCAxKTtcbi8qKlxuKiBNZW1vaXplIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBubyBhcmd1bWVudHNcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gbWVtbyhmbikge1xuXHRsZXQgcHJvbWlzZSA9IG51bGw7XG5cdGNvbnN0IHN5bSA9IFN5bWJvbC5mb3IoXCJAdHJwYy9zZXJ2ZXIvaHR0cC9tZW1vXCIpO1xuXHRsZXQgdmFsdWUgPSBzeW07XG5cdHJldHVybiB7XG5cdFx0cmVhZDogYXN5bmMgKCkgPT4ge1xuXHRcdFx0dmFyIF9wcm9taXNlO1xuXHRcdFx0aWYgKHZhbHVlICE9PSBzeW0pIHJldHVybiB2YWx1ZTtcblx0XHRcdChfcHJvbWlzZSA9IHByb21pc2UpICE9PSBudWxsICYmIF9wcm9taXNlICE9PSB2b2lkIDAgfHwgKHByb21pc2UgPSBmbigpLmNhdGNoKChjYXVzZSkgPT4ge1xuXHRcdFx0XHRpZiAoY2F1c2UgaW5zdGFuY2VvZiBUUlBDRXJyb3IpIHRocm93IGNhdXNlO1xuXHRcdFx0XHR0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG5cdFx0XHRcdFx0bWVzc2FnZTogY2F1c2UgaW5zdGFuY2VvZiBFcnJvciA/IGNhdXNlLm1lc3NhZ2UgOiBcIkludmFsaWQgaW5wdXRcIixcblx0XHRcdFx0XHRjYXVzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pKTtcblx0XHRcdHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcblx0XHRcdHByb21pc2UgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0sXG5cdFx0cmVzdWx0OiAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHN5bSA/IHZhbHVlIDogdm9pZCAwO1xuXHRcdH1cblx0fTtcbn1cbmNvbnN0IGpzb25Db250ZW50VHlwZUhhbmRsZXIgPSB7XG5cdGlzTWF0Y2gocmVxKSB7XG5cdFx0dmFyIF9yZXEkaGVhZGVycyRnZXQ7XG5cdFx0cmV0dXJuICEhKChfcmVxJGhlYWRlcnMkZ2V0ID0gcmVxLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSA9PT0gbnVsbCB8fCBfcmVxJGhlYWRlcnMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVxJGhlYWRlcnMkZ2V0LnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9qc29uXCIpKTtcblx0fSxcblx0YXN5bmMgcGFyc2Uob3B0cykge1xuXHRcdHZhciBfdHlwZXMkdmFsdWVzJG5leHQkdmE7XG5cdFx0Y29uc3QgeyByZXEgfSA9IG9wdHM7XG5cdFx0Y29uc3QgaXNCYXRjaENhbGwgPSBvcHRzLnNlYXJjaFBhcmFtcy5nZXQoXCJiYXRjaFwiKSA9PT0gXCIxXCI7XG5cdFx0Y29uc3QgcGF0aHMgPSBpc0JhdGNoQ2FsbCA/IG9wdHMucGF0aC5zcGxpdChcIixcIikgOiBbb3B0cy5wYXRoXTtcblx0XHRjb25zdCBnZXRJbnB1dHMgPSBtZW1vKGFzeW5jICgpID0+IHtcblx0XHRcdGxldCBpbnB1dHMgPSB2b2lkIDA7XG5cdFx0XHRpZiAocmVxLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuXHRcdFx0XHRjb25zdCBxdWVyeUlucHV0ID0gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiaW5wdXRcIik7XG5cdFx0XHRcdGlmIChxdWVyeUlucHV0KSBpbnB1dHMgPSBKU09OLnBhcnNlKHF1ZXJ5SW5wdXQpO1xuXHRcdFx0fSBlbHNlIGlucHV0cyA9IGF3YWl0IHJlcS5qc29uKCk7XG5cdFx0XHRpZiAoaW5wdXRzID09PSB2b2lkIDApIHJldHVybiB7fTtcblx0XHRcdGlmICghaXNCYXRjaENhbGwpIHJldHVybiB7IDA6IG9wdHMucm91dGVyLl9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lci5pbnB1dC5kZXNlcmlhbGl6ZShpbnB1dHMpIH07XG5cdFx0XHRpZiAoIWlzT2JqZWN0KGlucHV0cykpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0XHRjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG5cdFx0XHRcdG1lc3NhZ2U6IFwiXFxcImlucHV0XFxcIiBuZWVkcyB0byBiZSBhbiBvYmplY3Qgd2hlbiBkb2luZyBhIGJhdGNoIGNhbGxcIlxuXHRcdFx0fSk7XG5cdFx0XHRjb25zdCBhY2MgPSB7fTtcblx0XHRcdGZvciAoY29uc3QgaW5kZXggb2YgcGF0aHMua2V5cygpKSB7XG5cdFx0XHRcdGNvbnN0IGlucHV0ID0gaW5wdXRzW2luZGV4XTtcblx0XHRcdFx0aWYgKGlucHV0ICE9PSB2b2lkIDApIGFjY1tpbmRleF0gPSBvcHRzLnJvdXRlci5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIuaW5wdXQuZGVzZXJpYWxpemUoaW5wdXQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9KTtcblx0XHRjb25zdCBjYWxscyA9IGF3YWl0IFByb21pc2UuYWxsKHBhdGhzLm1hcChhc3luYyAocGF0aCwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgcGF0aCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRwcm9jZWR1cmUsXG5cdFx0XHRcdGdldFJhd0lucHV0OiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaW5wdXRzID0gYXdhaXQgZ2V0SW5wdXRzLnJlYWQoKTtcblx0XHRcdFx0XHRsZXQgaW5wdXQgPSBpbnB1dHNbaW5kZXhdO1xuXHRcdFx0XHRcdGlmICgocHJvY2VkdXJlID09PSBudWxsIHx8IHByb2NlZHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2VkdXJlLl9kZWYudHlwZSkgPT09IFwic3Vic2NyaXB0aW9uXCIpIHtcblx0XHRcdFx0XHRcdHZhciBfcmVmLCBfb3B0cyRoZWFkZXJzJGdldDtcblx0XHRcdFx0XHRcdGNvbnN0IGxhc3RFdmVudElkID0gKF9yZWYgPSAoX29wdHMkaGVhZGVycyRnZXQgPSBvcHRzLmhlYWRlcnMuZ2V0KFwibGFzdC1ldmVudC1pZFwiKSkgIT09IG51bGwgJiYgX29wdHMkaGVhZGVycyRnZXQgIT09IHZvaWQgMCA/IF9vcHRzJGhlYWRlcnMkZ2V0IDogb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwibGFzdEV2ZW50SWRcIikpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBvcHRzLnNlYXJjaFBhcmFtcy5nZXQoXCJMYXN0LUV2ZW50LUlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKGxhc3RFdmVudElkKSBpZiAoaXNPYmplY3QoaW5wdXQpKSBpbnB1dCA9ICgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKHt9LCBpbnB1dCksIHt9LCB7IGxhc3RFdmVudElkIH0pO1xuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBfaW5wdXQ7XG5cdFx0XHRcdFx0XHRcdChfaW5wdXQgPSBpbnB1dCkgIT09IG51bGwgJiYgX2lucHV0ICE9PSB2b2lkIDAgfHwgKGlucHV0ID0geyBsYXN0RXZlbnRJZCB9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXN1bHQ6ICgpID0+IHtcblx0XHRcdFx0XHR2YXIgX2dldElucHV0cyRyZXN1bHQ7XG5cdFx0XHRcdFx0cmV0dXJuIChfZ2V0SW5wdXRzJHJlc3VsdCA9IGdldElucHV0cy5yZXN1bHQoKSkgPT09IG51bGwgfHwgX2dldElucHV0cyRyZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRJbnB1dHMkcmVzdWx0W2luZGV4XTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9KSk7XG5cdFx0Y29uc3QgdHlwZXMgPSBuZXcgU2V0KGNhbGxzLm1hcCgoY2FsbCkgPT4ge1xuXHRcdFx0dmFyIF9jYWxsJHByb2NlZHVyZTtcblx0XHRcdHJldHVybiAoX2NhbGwkcHJvY2VkdXJlID0gY2FsbC5wcm9jZWR1cmUpID09PSBudWxsIHx8IF9jYWxsJHByb2NlZHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NhbGwkcHJvY2VkdXJlLl9kZWYudHlwZTtcblx0XHR9KS5maWx0ZXIoQm9vbGVhbikpO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0XHRpZiAodHlwZXMuc2l6ZSA+IDEpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0bWVzc2FnZTogYENhbm5vdCBtaXggcHJvY2VkdXJlIHR5cGVzIGluIGNhbGw6ICR7QXJyYXkuZnJvbSh0eXBlcykuam9pbihcIiwgXCIpfWBcblx0XHR9KTtcblx0XHRjb25zdCB0eXBlID0gKF90eXBlcyR2YWx1ZXMkbmV4dCR2YSA9IHR5cGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkgIT09IG51bGwgJiYgX3R5cGVzJHZhbHVlcyRuZXh0JHZhICE9PSB2b2lkIDAgPyBfdHlwZXMkdmFsdWVzJG5leHQkdmEgOiBcInVua25vd25cIjtcblx0XHRjb25zdCBjb25uZWN0aW9uUGFyYW1zU3RyID0gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiY29ubmVjdGlvblBhcmFtc1wiKTtcblx0XHRjb25zdCBpbmZvID0ge1xuXHRcdFx0aXNCYXRjaENhbGwsXG5cdFx0XHRhY2NlcHQ6IHJlcS5oZWFkZXJzLmdldChcInRycGMtYWNjZXB0XCIpLFxuXHRcdFx0Y2FsbHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0Y29ubmVjdGlvblBhcmFtczogY29ubmVjdGlvblBhcmFtc1N0ciA9PT0gbnVsbCA/IG51bGwgOiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tU3RyaW5nKGNvbm5lY3Rpb25QYXJhbXNTdHIpLFxuXHRcdFx0c2lnbmFsOiByZXEuc2lnbmFsLFxuXHRcdFx0dXJsOiBvcHRzLnVybFxuXHRcdH07XG5cdFx0cmV0dXJuIGluZm87XG5cdH1cbn07XG5jb25zdCBmb3JtRGF0YUNvbnRlbnRUeXBlSGFuZGxlciA9IHtcblx0aXNNYXRjaChyZXEpIHtcblx0XHR2YXIgX3JlcSRoZWFkZXJzJGdldDI7XG5cdFx0cmV0dXJuICEhKChfcmVxJGhlYWRlcnMkZ2V0MiA9IHJlcS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgPT09IG51bGwgfHwgX3JlcSRoZWFkZXJzJGdldDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXEkaGVhZGVycyRnZXQyLnN0YXJ0c1dpdGgoXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpKTtcblx0fSxcblx0YXN5bmMgcGFyc2Uob3B0cykge1xuXHRcdGNvbnN0IHsgcmVxIH0gPSBvcHRzO1xuXHRcdGlmIChyZXEubWV0aG9kICE9PSBcIlBPU1RcIikgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRjb2RlOiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdFx0XHRtZXNzYWdlOiBcIk9ubHkgUE9TVCByZXF1ZXN0cyBhcmUgc3VwcG9ydGVkIGZvciBtdWx0aXBhcnQvZm9ybS1kYXRhIHJlcXVlc3RzXCJcblx0XHR9KTtcblx0XHRjb25zdCBnZXRJbnB1dHMgPSBtZW1vKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IGZkID0gYXdhaXQgcmVxLmZvcm1EYXRhKCk7XG5cdFx0XHRyZXR1cm4gZmQ7XG5cdFx0fSk7XG5cdFx0Y29uc3QgcHJvY2VkdXJlID0gYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKG9wdHMucm91dGVyLCBvcHRzLnBhdGgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhY2NlcHQ6IG51bGwsXG5cdFx0XHRjYWxsczogW3tcblx0XHRcdFx0cGF0aDogb3B0cy5wYXRoLFxuXHRcdFx0XHRnZXRSYXdJbnB1dDogZ2V0SW5wdXRzLnJlYWQsXG5cdFx0XHRcdHJlc3VsdDogZ2V0SW5wdXRzLnJlc3VsdCxcblx0XHRcdFx0cHJvY2VkdXJlXG5cdFx0XHR9XSxcblx0XHRcdGlzQmF0Y2hDYWxsOiBmYWxzZSxcblx0XHRcdHR5cGU6IFwibXV0YXRpb25cIixcblx0XHRcdGNvbm5lY3Rpb25QYXJhbXM6IG51bGwsXG5cdFx0XHRzaWduYWw6IHJlcS5zaWduYWwsXG5cdFx0XHR1cmw6IG9wdHMudXJsXG5cdFx0fTtcblx0fVxufTtcbmNvbnN0IG9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyID0ge1xuXHRpc01hdGNoKHJlcSkge1xuXHRcdHZhciBfcmVxJGhlYWRlcnMkZ2V0Mztcblx0XHRyZXR1cm4gISEoKF9yZXEkaGVhZGVycyRnZXQzID0gcmVxLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSA9PT0gbnVsbCB8fCBfcmVxJGhlYWRlcnMkZ2V0MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcSRoZWFkZXJzJGdldDMuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSk7XG5cdH0sXG5cdGFzeW5jIHBhcnNlKG9wdHMpIHtcblx0XHRjb25zdCB7IHJlcSB9ID0gb3B0cztcblx0XHRpZiAocmVxLm1ldGhvZCAhPT0gXCJQT1NUXCIpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0bWVzc2FnZTogXCJPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIHJlcXVlc3RzXCJcblx0XHR9KTtcblx0XHRjb25zdCBnZXRJbnB1dHMgPSBtZW1vKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiByZXEuYm9keTtcblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2FsbHM6IFt7XG5cdFx0XHRcdHBhdGg6IG9wdHMucGF0aCxcblx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGdldElucHV0cy5yZWFkLFxuXHRcdFx0XHRyZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG5cdFx0XHRcdHByb2NlZHVyZTogYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKG9wdHMucm91dGVyLCBvcHRzLnBhdGgpXG5cdFx0XHR9XSxcblx0XHRcdGlzQmF0Y2hDYWxsOiBmYWxzZSxcblx0XHRcdGFjY2VwdDogbnVsbCxcblx0XHRcdHR5cGU6IFwibXV0YXRpb25cIixcblx0XHRcdGNvbm5lY3Rpb25QYXJhbXM6IG51bGwsXG5cdFx0XHRzaWduYWw6IHJlcS5zaWduYWwsXG5cdFx0XHR1cmw6IG9wdHMudXJsXG5cdFx0fTtcblx0fVxufTtcbmNvbnN0IGhhbmRsZXJzID0gW1xuXHRqc29uQ29udGVudFR5cGVIYW5kbGVyLFxuXHRmb3JtRGF0YUNvbnRlbnRUeXBlSGFuZGxlcixcblx0b2N0ZXRTdHJlYW1Db250ZW50VHlwZUhhbmRsZXJcbl07XG5mdW5jdGlvbiBnZXRDb250ZW50VHlwZUhhbmRsZXIocmVxKSB7XG5cdGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVycy5maW5kKChoYW5kbGVyJDEpID0+IGhhbmRsZXIkMS5pc01hdGNoKHJlcSkpO1xuXHRpZiAoaGFuZGxlcikgcmV0dXJuIGhhbmRsZXI7XG5cdGlmICghaGFuZGxlciAmJiByZXEubWV0aG9kID09PSBcIkdFVFwiKSByZXR1cm4ganNvbkNvbnRlbnRUeXBlSGFuZGxlcjtcblx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0Y29kZTogXCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFXCIsXG5cdFx0bWVzc2FnZTogcmVxLmhlYWRlcnMuaGFzKFwiY29udGVudC10eXBlXCIpID8gYFVuc3VwcG9ydGVkIGNvbnRlbnQtdHlwZSBcIiR7cmVxLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpfWAgOiBcIk1pc3NpbmcgY29udGVudC10eXBlIGhlYWRlclwiXG5cdH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVxdWVzdEluZm8ob3B0cykge1xuXHRjb25zdCBoYW5kbGVyID0gZ2V0Q29udGVudFR5cGVIYW5kbGVyKG9wdHMucmVxKTtcblx0cmV0dXJuIGF3YWl0IGhhbmRsZXIucGFyc2Uob3B0cyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9hYm9ydEVycm9yLnRzXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIGlzT2JqZWN0KGVycm9yKSAmJiBlcnJvcltcIm5hbWVcIl0gPT09IFwiQWJvcnRFcnJvclwiO1xufVxuZnVuY3Rpb24gdGhyb3dBYm9ydEVycm9yKG1lc3NhZ2UgPSBcIkFib3J0RXJyb3JcIikge1xuXHR0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIFwiQWJvcnRFcnJvclwiKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3ZlbmRvci9pcy1wbGFpbi1vYmplY3QudHNcbi8qIVxuKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbipcbiogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuZnVuY3Rpb24gaXNPYmplY3QkMShvKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcblx0dmFyIGN0b3IsIHByb3Q7XG5cdGlmIChpc09iamVjdCQxKG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0aWYgKGN0b3IgPT09IHZvaWQgMCkgcmV0dXJuIHRydWU7XG5cdHByb3QgPSBjdG9yLnByb3RvdHlwZTtcblx0aWYgKGlzT2JqZWN0JDEocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdGlmIChwcm90Lmhhc093blByb3BlcnR5KFwiaXNQcm90b3R5cGVPZlwiKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy92ZW5kb3IvdW5wcm9taXNlL3VucHJvbWlzZS50c1xudmFyIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSA9IF9fdG9FU00ocmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSgpLCAxKTtcbmxldCBfU3ltYm9sJHRvU3RyaW5nVGFnO1xuLyoqIE1lbW9yeSBzYWZlICh3ZWFrbWFwcGVkKSBjYWNoZSBvZiB0aGUgUHJveHlQcm9taXNlIGZvciBlYWNoIFByb21pc2UsXG4qIHdoaWNoIGlzIHJldGFpbmVkIGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIG9yaWdpbmFsIFByb21pc2UuXG4qL1xuY29uc3Qgc3Vic2NyaWJhYmxlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbi8qKiBBIE5PT1AgZnVuY3Rpb24gYWxsb3dpbmcgYSBjb25zaXN0ZW50IGludGVyZmFjZSBmb3Igc2V0dGxlZFxuKiBTdWJzY3JpYmVkUHJvbWlzZXMgKHNldHRsZWQgcHJvbWlzZXMgYXJlIG5vdCBzdWJzY3JpYmVkIC0gdGhleSByZXNvbHZlXG4qIGltbWVkaWF0ZWx5KS4gKi9cbmNvbnN0IE5PT1AgPSAoKSA9PiB7fTtcbl9TeW1ib2wkdG9TdHJpbmdUYWcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG4vKipcbiogRXZlcnkgYFByb21pc2U8VD5gIGNhbiBiZSBzaGFkb3dlZCBieSBhIHNpbmdsZSBgUHJveHlQcm9taXNlPFQ+YC4gSXQgaXNcbiogY3JlYXRlZCBvbmNlLCBjYWNoZWQgYW5kIHJldXNlZCB0aHJvdWdob3V0IHRoZSBsaWZldGltZSBvZiB0aGUgUHJvbWlzZS4gR2V0IGFcbiogUHJvbWlzZSdzIFByb3h5UHJvbWlzZSB1c2luZyBgVW5wcm9taXNlLnByb3h5KHByb21pc2UpYC5cbipcbiogVGhlIGBQcm94eVByb21pc2U8VD5gIGF0dGFjaGVzIGhhbmRsZXJzIHRvIHRoZSBvcmlnaW5hbCBgUHJvbWlzZTxUPmBcbiogYC50aGVuKClgIGFuZCBgLmNhdGNoKClgIGp1c3Qgb25jZS4gUHJvbWlzZXMgZGVyaXZlZCBmcm9tIGl0IHVzZSBhXG4qIHN1YnNjcmlwdGlvbi0gKGFuZCB1bnN1YnNjcmlwdGlvbi0pIGJhc2VkIG1lY2hhbmlzbSB0aGF0IG1vbml0b3JzIHRoZXNlXG4qIGhhbmRsZXJzLlxuKlxuKiBFdmVyeSB0aW1lIHlvdSBjYWxsIGAuc3Vic2NyaWJlKClgLCBgLnRoZW4oKWAgYC5jYXRjaCgpYCBvciBgLmZpbmFsbHkoKWAgb24gYVxuKiBgUHJveHlQcm9taXNlPFQ+YCBpdCByZXR1cm5zIGEgYFN1YnNjcmliZWRQcm9taXNlPFQ+YCBoYXZpbmcgYW4gYWRkaXRpb25hbFxuKiBgdW5zdWJzY3JpYmUoKWAgbWV0aG9kLiBDYWxsaW5nIGB1bnN1YnNjcmliZSgpYCBkZXRhY2hlcyByZWZlcmVuY2UgY2hhaW5zXG4qIGZyb20gdGhlIG9yaWdpbmFsLCBwb3RlbnRpYWxseSBsb25nLWxpdmVkIFByb21pc2UsIGVsaW1pbmF0aW5nIG1lbW9yeSBsZWFrcy5cbipcbiogVGhpcyBhcHByb2FjaCBjYW4gZWxpbWluYXRlIHRoZSBtZW1vcnkgbGVha3MgdGhhdCBvdGhlcndpc2UgY29tZSBhYm91dCBmcm9tXG4qIHJlcGVhdGVkIGByYWNlKClgIG9yIGBhbnkoKWAgY2FsbHMgaW52b2tpbmcgYC50aGVuKClgIGFuZCBgLmNhdGNoKClgIG11bHRpcGxlXG4qIHRpbWVzIG9uIHRoZSBzYW1lIGxvbmctbGl2ZWQgbmF0aXZlIFByb21pc2UgKHN1YnNjcmlwdGlvbnMgd2hpY2ggY2FuIG5ldmVyIGJlXG4qIGNsZWFuZWQgdXApLlxuKlxuKiBgVW5wcm9taXNlLnJhY2UocHJvbWlzZXMpYCBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiBgUHJvbWlzZS5yYWNlYFxuKiBhdm9pZGluZyBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyBsb25nLWxpdmVkIHVuc2V0dGxlZCBQcm9taXNlcy5cbipcbiogYFVucHJvbWlzZS5hbnkocHJvbWlzZXMpYCBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiBgUHJvbWlzZS5hbnlgXG4qIGF2b2lkaW5nIG1lbW9yeSBsZWFrcyB3aGVuIHVzaW5nIGxvbmctbGl2ZWQgdW5zZXR0bGVkIFByb21pc2VzLlxuKlxuKiBgVW5wcm9taXNlLnJlc29sdmUocHJvbWlzZSlgIHJldHVybnMgYW4gZXBoZW1lcmFsIGBTdWJzY3JpYmVkUHJvbWlzZTxUPmAgZm9yXG4qIGFueSBnaXZlbiBgUHJvbWlzZTxUPmAgZmFjaWxpdGF0aW5nIGFyYml0cmFyeSBhc3luYy9hd2FpdCBwYXR0ZXJucy4gQmVoaW5kXG4qIHRoZSBzY2VuZXMsIGByZXNvbHZlYCBpcyBpbXBsZW1lbnRlZCBzaW1wbHkgYXNcbiogYFVucHJvbWlzZS5wcm94eShwcm9taXNlKS5zdWJzY3JpYmUoKWAuIERvbid0IGZvcmdldCB0byBjYWxsIGAudW5zdWJzY3JpYmUoKWBcbiogdG8gdGlkeSB1cCFcbipcbiovXG52YXIgVW5wcm9taXNlID0gY2xhc3MgVW5wcm9taXNlIHtcblx0Y29uc3RydWN0b3IoYXJnKSB7XG5cdFx0KDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eS5kZWZhdWx0KSh0aGlzLCBcInByb21pc2VcIiwgdm9pZCAwKTtcblx0XHQoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5LmRlZmF1bHQpKHRoaXMsIFwic3Vic2NyaWJlcnNcIiwgW10pO1xuXHRcdCgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkuZGVmYXVsdCkodGhpcywgXCJzZXR0bGVtZW50XCIsIG51bGwpO1xuXHRcdCgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkuZGVmYXVsdCkodGhpcywgX1N5bWJvbCR0b1N0cmluZ1RhZywgXCJVbnByb21pc2VcIik7XG5cdFx0aWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoYXJnKTtcblx0XHRlbHNlIHRoaXMucHJvbWlzZSA9IGFyZztcblx0XHRjb25zdCB0aGVuUmV0dXJuID0gdGhpcy5wcm9taXNlLnRoZW4oKHZhbHVlKSA9PiB7XG5cdFx0XHRjb25zdCB7IHN1YnNjcmliZXJzIH0gPSB0aGlzO1xuXHRcdFx0dGhpcy5zdWJzY3JpYmVycyA9IG51bGw7XG5cdFx0XHR0aGlzLnNldHRsZW1lbnQgPSB7XG5cdFx0XHRcdHN0YXR1czogXCJmdWxmaWxsZWRcIixcblx0XHRcdFx0dmFsdWVcblx0XHRcdH07XG5cdFx0XHRzdWJzY3JpYmVycyA9PT0gbnVsbCB8fCBzdWJzY3JpYmVycyA9PT0gdm9pZCAwIHx8IHN1YnNjcmliZXJzLmZvckVhY2goKHsgcmVzb2x2ZSB9KSA9PiB7XG5cdFx0XHRcdHJlc29sdmUodmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0aWYgKFwiY2F0Y2hcIiBpbiB0aGVuUmV0dXJuKSB0aGVuUmV0dXJuLmNhdGNoKChyZWFzb24pID0+IHtcblx0XHRcdGNvbnN0IHsgc3Vic2NyaWJlcnMgfSA9IHRoaXM7XG5cdFx0XHR0aGlzLnN1YnNjcmliZXJzID0gbnVsbDtcblx0XHRcdHRoaXMuc2V0dGxlbWVudCA9IHtcblx0XHRcdFx0c3RhdHVzOiBcInJlamVjdGVkXCIsXG5cdFx0XHRcdHJlYXNvblxuXHRcdFx0fTtcblx0XHRcdHN1YnNjcmliZXJzID09PSBudWxsIHx8IHN1YnNjcmliZXJzID09PSB2b2lkIDAgfHwgc3Vic2NyaWJlcnMuZm9yRWFjaCgoeyByZWplY3QgfSkgPT4ge1xuXHRcdFx0XHRyZWplY3QocmVhc29uKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKiBDcmVhdGUgYSBwcm9taXNlIHRoYXQgbWl0aWdhdGVzIHVuY29udHJvbGxlZCBzdWJzY3JpcHRpb24gdG8gYSBsb25nLWxpdmVkXG5cdCogUHJvbWlzZSB2aWEgLnRoZW4oKSBhbmQgLmNhdGNoKCkgLSBvdGhlcndpc2UgYSBzb3VyY2Ugb2YgbWVtb3J5IGxlYWtzLlxuXHQqXG5cdCogVGhlIHJldHVybmVkIHByb21pc2UgaGFzIGFuIGB1bnN1YnNjcmliZSgpYCBtZXRob2Qgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aGVuXG5cdCogdGhlIFByb21pc2UgaXMgbm8gbG9uZ2VyIGJlaW5nIHRyYWNrZWQgYnkgYXBwbGljYXRpb24gbG9naWMsIGFuZCB3aGljaFxuXHQqIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBubyByZWZlcmVuY2UgY2hhaW4gZnJvbSB0aGUgb3JpZ2luYWwgcHJvbWlzZSB0byB0aGVcblx0KiBuZXcgb25lLCBhbmQgdGhlcmVmb3JlIG5vIG1lbW9yeSBsZWFrLlxuXHQqXG5cdCogSWYgb3JpZ2luYWwgcHJvbWlzZSBoYXMgbm90IHlldCBzZXR0bGVkLCB0aGlzIGFkZHMgYSBuZXcgdW5pcXVlIHByb21pc2Vcblx0KiB0aGF0IGxpc3RlbnMgdG8gdGhlbi9jYXRjaCBldmVudHMsIGFsb25nIHdpdGggYW4gYHVuc3Vic2NyaWJlKClgIG1ldGhvZCB0b1xuXHQqIGRldGFjaCBpdC5cblx0KlxuXHQqIElmIG9yaWdpbmFsIHByb21pc2UgaGFzIHNldHRsZWQsIHRoZW4gY3JlYXRlcyBhIG5ldyBQcm9taXNlLnJlc29sdmUoKSBvclxuXHQqIFByb21pc2UucmVqZWN0KCkgYW5kIHByb3ZpZGVkIHVuc3Vic2NyaWJlIGlzIGEgbm9vcC5cblx0KlxuXHQqIElmIHlvdSBjYWxsIGB1bnN1YnNjcmliZSgpYCBiZWZvcmUgdGhlIHJldHVybmVkIFByb21pc2UgaGFzIHNldHRsZWQsIGl0XG5cdCogd2lsbCBuZXZlciBzZXR0bGUuXG5cdCovXG5cdHN1YnNjcmliZSgpIHtcblx0XHRsZXQgcHJvbWlzZTtcblx0XHRsZXQgdW5zdWJzY3JpYmU7XG5cdFx0Y29uc3QgeyBzZXR0bGVtZW50IH0gPSB0aGlzO1xuXHRcdGlmIChzZXR0bGVtZW50ID09PSBudWxsKSB7XG5cdFx0XHRpZiAodGhpcy5zdWJzY3JpYmVycyA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiVW5wcm9taXNlIHNldHRsZWQgYnV0IHN0aWxsIGhhcyBzdWJzY3JpYmVyc1wiKTtcblx0XHRcdGNvbnN0IHN1YnNjcmliZXIgPSB3aXRoUmVzb2x2ZXJzKCk7XG5cdFx0XHR0aGlzLnN1YnNjcmliZXJzID0gbGlzdFdpdGhNZW1iZXIodGhpcy5zdWJzY3JpYmVycywgc3Vic2NyaWJlcik7XG5cdFx0XHRwcm9taXNlID0gc3Vic2NyaWJlci5wcm9taXNlO1xuXHRcdFx0dW5zdWJzY3JpYmUgPSAoKSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLnN1YnNjcmliZXJzICE9PSBudWxsKSB0aGlzLnN1YnNjcmliZXJzID0gbGlzdFdpdGhvdXRNZW1iZXIodGhpcy5zdWJzY3JpYmVycywgc3Vic2NyaWJlcik7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCB7IHN0YXR1cyB9ID0gc2V0dGxlbWVudDtcblx0XHRcdGlmIChzdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc2V0dGxlbWVudC52YWx1ZSk7XG5cdFx0XHRlbHNlIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChzZXR0bGVtZW50LnJlYXNvbik7XG5cdFx0XHR1bnN1YnNjcmliZSA9IE5PT1A7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHsgdW5zdWJzY3JpYmUgfSk7XG5cdH1cblx0LyoqIFNUQU5EQVJEIFBST01JU0UgTUVUSE9EUyAoYnV0IHJldHVybmluZyBhIFN1YnNjcmliZWRQcm9taXNlKSAqL1xuXHR0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG5cdFx0Y29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdGNhdGNoKG9ucmVqZWN0ZWQpIHtcblx0XHRjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5zdWJzY3JpYmUoKTtcblx0XHRjb25zdCB7IHVuc3Vic2NyaWJlIH0gPSBzdWJzY3JpYmVkO1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHN1YnNjcmliZWQuY2F0Y2gob25yZWplY3RlZCksIHsgdW5zdWJzY3JpYmUgfSk7XG5cdH1cblx0ZmluYWxseShvbmZpbmFsbHkpIHtcblx0XHRjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5zdWJzY3JpYmUoKTtcblx0XHRjb25zdCB7IHVuc3Vic2NyaWJlIH0gPSBzdWJzY3JpYmVkO1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKHN1YnNjcmliZWQuZmluYWxseShvbmZpbmFsbHkpLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdC8qKiBVbnByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblx0LyoqIENyZWF0ZSBvciBSZXRyaWV2ZSB0aGUgcHJveHkgVW5wcm9taXNlIChhIHJlLXVzZWQgVW5wcm9taXNlIGZvciB0aGUgVk0gbGlmZXRpbWVcblx0KiBvZiB0aGUgcHJvdmlkZWQgUHJvbWlzZSByZWZlcmVuY2UpICovXG5cdHN0YXRpYyBwcm94eShwcm9taXNlKSB7XG5cdFx0Y29uc3QgY2FjaGVkID0gVW5wcm9taXNlLmdldFN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSk7XG5cdFx0cmV0dXJuIHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCIgPyBjYWNoZWQgOiBVbnByb21pc2UuY3JlYXRlU3Vic2NyaWJhYmxlUHJvbWlzZShwcm9taXNlKTtcblx0fVxuXHQvKiogQ3JlYXRlIGFuZCBzdG9yZSBhbiBVbnByb21pc2Uga2V5ZWQgYnkgYW4gb3JpZ2luYWwgUHJvbWlzZS4gKi9cblx0c3RhdGljIGNyZWF0ZVN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSkge1xuXHRcdGNvbnN0IGNyZWF0ZWQgPSBuZXcgVW5wcm9taXNlKHByb21pc2UpO1xuXHRcdHN1YnNjcmliYWJsZUNhY2hlLnNldChwcm9taXNlLCBjcmVhdGVkKTtcblx0XHRzdWJzY3JpYmFibGVDYWNoZS5zZXQoY3JlYXRlZCwgY3JlYXRlZCk7XG5cdFx0cmV0dXJuIGNyZWF0ZWQ7XG5cdH1cblx0LyoqIFJldHJpZXZlIGEgcHJldmlvdXNseS1jcmVhdGVkIFVucHJvbWlzZSBrZXllZCBieSBhbiBvcmlnaW5hbCBQcm9taXNlLiAqL1xuXHRzdGF0aWMgZ2V0U3Vic2NyaWJhYmxlUHJvbWlzZShwcm9taXNlKSB7XG5cdFx0cmV0dXJuIHN1YnNjcmliYWJsZUNhY2hlLmdldChwcm9taXNlKTtcblx0fVxuXHQvKiogUHJvbWlzZSBTVEFUSUMgTUVUSE9EUyAqL1xuXHQvKiogTG9va3VwIHRoZSBVbnByb21pc2UgZm9yIHRoaXMgcHJvbWlzZSwgYW5kIGRlcml2ZSBhIFN1YnNjcmliZWRQcm9taXNlIGZyb21cblx0KiBpdCAodGhhdCBjYW4gYmUgbGF0ZXIgdW5zdWJzY3JpYmVkIHRvIGVsaW1pbmF0ZSBNZW1vcnkgbGVha3MpICovXG5cdHN0YXRpYyByZXNvbHZlKHZhbHVlKSB7XG5cdFx0Y29uc3QgcHJvbWlzZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcInRoZW5cIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuXHRcdHJldHVybiBVbnByb21pc2UucHJveHkocHJvbWlzZSkuc3Vic2NyaWJlKCk7XG5cdH1cblx0c3RhdGljIGFzeW5jIGFueSh2YWx1ZXMpIHtcblx0XHRjb25zdCB2YWx1ZXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFsuLi52YWx1ZXNdO1xuXHRcdGNvbnN0IHN1YnNjcmliZWRQcm9taXNlcyA9IHZhbHVlc0FycmF5Lm1hcChVbnByb21pc2UucmVzb2x2ZSk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBQcm9taXNlLmFueShzdWJzY3JpYmVkUHJvbWlzZXMpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzdWJzY3JpYmVkUHJvbWlzZXMuZm9yRWFjaCgoeyB1bnN1YnNjcmliZSB9KSA9PiB7XG5cdFx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0c3RhdGljIGFzeW5jIHJhY2UodmFsdWVzKSB7XG5cdFx0Y29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbLi4udmFsdWVzXTtcblx0XHRjb25zdCBzdWJzY3JpYmVkUHJvbWlzZXMgPSB2YWx1ZXNBcnJheS5tYXAoVW5wcm9taXNlLnJlc29sdmUpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKHN1YnNjcmliZWRQcm9taXNlcyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHN1YnNjcmliZWRQcm9taXNlcy5mb3JFYWNoKCh7IHVuc3Vic2NyaWJlIH0pID0+IHtcblx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHQvKiogQ3JlYXRlIGEgcmFjZSBvZiBTdWJzY3JpYmVkUHJvbWlzZXMgdGhhdCB3aWxsIGZ1bGZpbCB0byBhIHNpbmdsZSB3aW5uaW5nXG5cdCogUHJvbWlzZSAoaW4gYSAxLVR1cGxlKS4gRWxpbWluYXRlcyBtZW1vcnkgbGVha3MgZnJvbSBsb25nLWxpdmVkIHByb21pc2VzXG5cdCogYWNjdW11bGF0aW5nIC50aGVuKCkgYW5kIC5jYXRjaCgpIHN1YnNjcmliZXJzLiBBbGxvd3Mgc2ltcGxlIGxvZ2ljIHRvXG5cdCogY29uc3VtZSB0aGUgcmVzdWx0LCBsaWtlLi4uXG5cdCogYGBgdHNcblx0KiBjb25zdCBbIHdpbm5lciBdID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoWyBwcm9taXNlQSwgcHJvbWlzZUIgXSk7XG5cdCogaWYod2lubmVyID09PSBwcm9taXNlQil7XG5cdCogICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlQjtcblx0KiAgIC8vIGRvIHRoZSB0aGluZ1xuXHQqIH1cblx0KiBgYGBcblx0KiAqL1xuXHRzdGF0aWMgYXN5bmMgcmFjZVJlZmVyZW5jZXMocHJvbWlzZXMpIHtcblx0XHRjb25zdCBzZWxmUHJvbWlzZXMgPSBwcm9taXNlcy5tYXAocmVzb2x2ZVNlbGZUdXBsZSk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2Uoc2VsZlByb21pc2VzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0Zm9yIChjb25zdCBwcm9taXNlIG9mIHNlbGZQcm9taXNlcykgcHJvbWlzZS51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0fVxufTtcbi8qKiBQcm9taXNlcyBhIDEtdHVwbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgcHJvbWlzZSB3aGVuIGl0IHJlc29sdmVzLiBBbGxvd3NcbiogYXdhaXRpbmcgdGhlIGV2ZW50dWFsIFByb21pc2UgKioqcmVmZXJlbmNlKioqIChlYXN5IHRvIGRlc3RydWN0dXJlIGFuZFxuKiBleGFjdGx5IGNvbXBhcmUgd2l0aCA9PT0pLiBBdm9pZHMgcmVzb2x2aW5nIHRvIHRoZSBQcm9taXNlICoqKnZhbHVlKioqICh3aGljaFxuKiBtYXkgYmUgYW1iaWd1b3VzIGFuZCB0aGVyZWZvcmUgaGFyZCB0byBpZGVudGlmeSBhcyB0aGUgd2lubmVyIG9mIGEgcmFjZSkuXG4qIFlvdSBjYW4gY2FsbCB1bnN1YnNjcmliZSBvbiB0aGUgUHJvbWlzZSB0byBtaXRpZ2F0ZSBtZW1vcnkgbGVha3MuXG4qICovXG5mdW5jdGlvbiByZXNvbHZlU2VsZlR1cGxlKHByb21pc2UpIHtcblx0cmV0dXJuIFVucHJvbWlzZS5wcm94eShwcm9taXNlKS50aGVuKCgpID0+IFtwcm9taXNlXSk7XG59XG4vKiogVkVORE9SRUQgKEZ1dHVyZSkgUFJPTUlTRSBVVElMSVRJRVMgKi9cbi8qKiBSZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS13aXRoLXJlc29sdmVycyAqL1xuZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcblx0bGV0IHJlc29sdmU7XG5cdGxldCByZWplY3Q7XG5cdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcblx0XHRyZXNvbHZlID0gX3Jlc29sdmU7XG5cdFx0cmVqZWN0ID0gX3JlamVjdDtcblx0fSk7XG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZSxcblx0XHRyZXNvbHZlLFxuXHRcdHJlamVjdFxuXHR9O1xufVxuLyoqIElNTVVUQUJMRSBMSVNUIE9QRVJBVElPTlMgKi9cbmZ1bmN0aW9uIGxpc3RXaXRoTWVtYmVyKGFyciwgbWVtYmVyKSB7XG5cdHJldHVybiBbLi4uYXJyLCBtZW1iZXJdO1xufVxuZnVuY3Rpb24gbGlzdFdpdGhvdXRJbmRleChhcnIsIGluZGV4KSB7XG5cdHJldHVybiBbLi4uYXJyLnNsaWNlKDAsIGluZGV4KSwgLi4uYXJyLnNsaWNlKGluZGV4ICsgMSldO1xufVxuZnVuY3Rpb24gbGlzdFdpdGhvdXRNZW1iZXIoYXJyLCBtZW1iZXIpIHtcblx0Y29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihtZW1iZXIpO1xuXHRpZiAoaW5kZXggIT09IC0xKSByZXR1cm4gbGlzdFdpdGhvdXRJbmRleChhcnIsIGluZGV4KTtcblx0cmV0dXJuIGFycjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvZGlzcG9zYWJsZS50c1xudmFyIF9TeW1ib2wsIF9TeW1ib2wkZGlzcG9zZSwgX1N5bWJvbDIsIF9TeW1ib2wyJGFzeW5jRGlzcG9zZTtcbihfU3ltYm9sJGRpc3Bvc2UgPSAoX1N5bWJvbCA9IFN5bWJvbCkuZGlzcG9zZSkgIT09IG51bGwgJiYgX1N5bWJvbCRkaXNwb3NlICE9PSB2b2lkIDAgfHwgKF9TeW1ib2wuZGlzcG9zZSA9IFN5bWJvbCgpKTtcbihfU3ltYm9sMiRhc3luY0Rpc3Bvc2UgPSAoX1N5bWJvbDIgPSBTeW1ib2wpLmFzeW5jRGlzcG9zZSkgIT09IG51bGwgJiYgX1N5bWJvbDIkYXN5bmNEaXNwb3NlICE9PSB2b2lkIDAgfHwgKF9TeW1ib2wyLmFzeW5jRGlzcG9zZSA9IFN5bWJvbCgpKTtcbi8qKlxuKiBUYWtlcyBhIHZhbHVlIGFuZCBhIGRpc3Bvc2UgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgRGlzcG9zYWJsZSBpbnRlcmZhY2UuXG4qIFRoZSByZXR1cm5lZCBvYmplY3QgaXMgdGhlIG9yaWdpbmFsIHZhbHVlIGF1Z21lbnRlZCB3aXRoIGEgU3ltYm9sLmRpc3Bvc2UgbWV0aG9kLlxuKiBAcGFyYW0gdGhpbmcgVGhlIHZhbHVlIHRvIG1ha2UgZGlzcG9zYWJsZVxuKiBAcGFyYW0gZGlzcG9zZSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZGlzcG9zaW5nIHRoZSByZXNvdXJjZVxuKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgdmFsdWUgd2l0aCBTeW1ib2wuZGlzcG9zZSBtZXRob2QgYWRkZWRcbiovXG5mdW5jdGlvbiBtYWtlUmVzb3VyY2UodGhpbmcsIGRpc3Bvc2UpIHtcblx0Y29uc3QgaXQgPSB0aGluZztcblx0Y29uc3QgZXhpc3RpbmcgPSBpdFtTeW1ib2wuZGlzcG9zZV07XG5cdGl0W1N5bWJvbC5kaXNwb3NlXSA9ICgpID0+IHtcblx0XHRkaXNwb3NlKCk7XG5cdFx0ZXhpc3RpbmcgPT09IG51bGwgfHwgZXhpc3RpbmcgPT09IHZvaWQgMCB8fCBleGlzdGluZygpO1xuXHR9O1xuXHRyZXR1cm4gaXQ7XG59XG4vKipcbiogVGFrZXMgYSB2YWx1ZSBhbmQgYW4gYXN5bmMgZGlzcG9zZSBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBBc3luY0Rpc3Bvc2FibGUgaW50ZXJmYWNlLlxuKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIHRoZSBvcmlnaW5hbCB2YWx1ZSBhdWdtZW50ZWQgd2l0aCBhIFN5bWJvbC5hc3luY0Rpc3Bvc2UgbWV0aG9kLlxuKiBAcGFyYW0gdGhpbmcgVGhlIHZhbHVlIHRvIG1ha2UgYXN5bmMgZGlzcG9zYWJsZVxuKiBAcGFyYW0gZGlzcG9zZSBBc3luYyBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZGlzcG9zaW5nIHRoZSByZXNvdXJjZVxuKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgdmFsdWUgd2l0aCBTeW1ib2wuYXN5bmNEaXNwb3NlIG1ldGhvZCBhZGRlZFxuKi9cbmZ1bmN0aW9uIG1ha2VBc3luY1Jlc291cmNlKHRoaW5nLCBkaXNwb3NlKSB7XG5cdGNvbnN0IGl0ID0gdGhpbmc7XG5cdGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG5cdGl0W1N5bWJvbC5hc3luY0Rpc3Bvc2VdID0gYXN5bmMgKCkgPT4ge1xuXHRcdGF3YWl0IGRpc3Bvc2UoKTtcblx0XHRhd2FpdCAoZXhpc3RpbmcgPT09IG51bGwgfHwgZXhpc3RpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4aXN0aW5nKCkpO1xuXHR9O1xuXHRyZXR1cm4gaXQ7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3RpbWVyUmVzb3VyY2UudHNcbmNvbnN0IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIHRpbWVyUmVzb3VyY2UobXMpIHtcblx0bGV0IHRpbWVyID0gbnVsbDtcblx0cmV0dXJuIG1ha2VSZXNvdXJjZSh7IHN0YXJ0KCkge1xuXHRcdGlmICh0aW1lcikgdGhyb3cgbmV3IEVycm9yKFwiVGltZXIgYWxyZWFkeSBzdGFydGVkXCIpO1xuXHRcdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCksIG1zKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fSB9LCAoKSA9PiB7XG5cdFx0aWYgKHRpbWVyKSBjbGVhclRpbWVvdXQodGltZXIpO1xuXHR9KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdXNpbmdDdHguanNcbnZhciByZXF1aXJlX3VzaW5nQ3R4ID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdXNpbmdDdHguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcblx0ZnVuY3Rpb24gX3VzaW5nQ3R4KCkge1xuXHRcdHZhciByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbihyJDEsIGUkMSkge1xuXHRcdFx0dmFyIG4kMSA9IEVycm9yKCk7XG5cdFx0XHRyZXR1cm4gbiQxLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBuJDEuZXJyb3IgPSByJDEsIG4kMS5zdXBwcmVzc2VkID0gZSQxLCBuJDE7XG5cdFx0fSwgZSA9IHt9LCBuID0gW107XG5cdFx0ZnVuY3Rpb24gdXNpbmcociQxLCBlJDEpIHtcblx0XHRcdGlmIChudWxsICE9IGUkMSkge1xuXHRcdFx0XHRpZiAoT2JqZWN0KGUkMSkgIT09IGUkMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVzaW5nIGRlY2xhcmF0aW9ucyBjYW4gb25seSBiZSB1c2VkIHdpdGggb2JqZWN0cywgZnVuY3Rpb25zLCBudWxsLCBvciB1bmRlZmluZWQuXCIpO1xuXHRcdFx0XHRpZiAociQxKSB2YXIgbyA9IGUkMVtTeW1ib2wuYXN5bmNEaXNwb3NlIHx8IFN5bWJvbFtcImZvclwiXShcIlN5bWJvbC5hc3luY0Rpc3Bvc2VcIildO1xuXHRcdFx0XHRpZiAodm9pZCAwID09PSBvICYmIChvID0gZSQxW1N5bWJvbC5kaXNwb3NlIHx8IFN5bWJvbFtcImZvclwiXShcIlN5bWJvbC5kaXNwb3NlXCIpXSwgciQxKSkgdmFyIHQgPSBvO1xuXHRcdFx0XHRpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBkaXNwb3NhYmxlLlwiKTtcblx0XHRcdFx0dCAmJiAobyA9IGZ1bmN0aW9uIG8kMSgpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dC5jYWxsKGUkMSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAociQyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QociQyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pLCBuLnB1c2goe1xuXHRcdFx0XHRcdHY6IGUkMSxcblx0XHRcdFx0XHRkOiBvLFxuXHRcdFx0XHRcdGE6IHIkMVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSByJDEgJiYgbi5wdXNoKHtcblx0XHRcdFx0ZDogZSQxLFxuXHRcdFx0XHRhOiByJDFcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGUkMTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGUsXG5cdFx0XHR1OiB1c2luZy5iaW5kKG51bGwsICExKSxcblx0XHRcdGE6IHVzaW5nLmJpbmQobnVsbCwgITApLFxuXHRcdFx0ZDogZnVuY3Rpb24gZCgpIHtcblx0XHRcdFx0dmFyIG8sIHQgPSB0aGlzLmUsIHMgPSAwO1xuXHRcdFx0XHRmdW5jdGlvbiBuZXh0KCkge1xuXHRcdFx0XHRcdGZvciAoOyBvID0gbi5wb3AoKTspIHRyeSB7XG5cdFx0XHRcdFx0XHRpZiAoIW8uYSAmJiAxID09PSBzKSByZXR1cm4gcyA9IDAsIG4ucHVzaChvKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0KTtcblx0XHRcdFx0XHRcdGlmIChvLmQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHIkMSA9IG8uZC5jYWxsKG8udik7XG5cdFx0XHRcdFx0XHRcdGlmIChvLmEpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyJDEpLnRoZW4obmV4dCwgZXJyKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBzIHw9IDE7XG5cdFx0XHRcdFx0fSBjYXRjaCAociQyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyKHIkMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgxID09PSBzKSByZXR1cm4gdCAhPT0gZSA/IFByb21pc2UucmVqZWN0KHQpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdFx0aWYgKHQgIT09IGUpIHRocm93IHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gZXJyKG4kMSkge1xuXHRcdFx0XHRcdHJldHVybiB0ID0gdCAhPT0gZSA/IG5ldyByKG4kMSwgdCkgOiBuJDEsIG5leHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmV4dCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBfdXNpbmdDdHgsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL092ZXJsb2FkWWllbGQuanNcbnZhciByZXF1aXJlX092ZXJsb2FkWWllbGQgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9PdmVybG9hZFlpZWxkLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdGZ1bmN0aW9uIF9PdmVybG9hZFlpZWxkKGUsIGQpIHtcblx0XHR0aGlzLnYgPSBlLCB0aGlzLmsgPSBkO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gX092ZXJsb2FkWWllbGQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3IuanNcbnZhciByZXF1aXJlX2F3YWl0QXN5bmNHZW5lcmF0b3IgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBPdmVybG9hZFlpZWxkJDIgPSByZXF1aXJlX092ZXJsb2FkWWllbGQoKTtcblx0ZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IkNShlKSB7XG5cdFx0cmV0dXJuIG5ldyBPdmVybG9hZFlpZWxkJDIoZSwgMCk7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBfYXdhaXRBc3luY0dlbmVyYXRvciQ1LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3IuanNcbnZhciByZXF1aXJlX3dyYXBBc3luY0dlbmVyYXRvciA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvci5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgT3ZlcmxvYWRZaWVsZCQxID0gcmVxdWlyZV9PdmVybG9hZFlpZWxkKCk7XG5cdGZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IkNihlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBBc3luY0dlbmVyYXRvcihlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHRcdH07XG5cdH1cblx0ZnVuY3Rpb24gQXN5bmNHZW5lcmF0b3IoZSkge1xuXHRcdHZhciByLCB0O1xuXHRcdGZ1bmN0aW9uIHJlc3VtZShyJDEsIHQkMSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG4gPSBlW3IkMV0odCQxKSwgbyA9IG4udmFsdWUsIHUgPSBvIGluc3RhbmNlb2YgT3ZlcmxvYWRZaWVsZCQxO1xuXHRcdFx0XHRQcm9taXNlLnJlc29sdmUodSA/IG8udiA6IG8pLnRoZW4oZnVuY3Rpb24odCQyKSB7XG5cdFx0XHRcdFx0aWYgKHUpIHtcblx0XHRcdFx0XHRcdHZhciBpID0gXCJyZXR1cm5cIiA9PT0gciQxID8gXCJyZXR1cm5cIiA6IFwibmV4dFwiO1xuXHRcdFx0XHRcdFx0aWYgKCFvLmsgfHwgdCQyLmRvbmUpIHJldHVybiByZXN1bWUoaSwgdCQyKTtcblx0XHRcdFx0XHRcdHQkMiA9IGVbaV0odCQyKS52YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2V0dGxlKG4uZG9uZSA/IFwicmV0dXJuXCIgOiBcIm5vcm1hbFwiLCB0JDIpO1xuXHRcdFx0XHR9LCBmdW5jdGlvbihlJDEpIHtcblx0XHRcdFx0XHRyZXN1bWUoXCJ0aHJvd1wiLCBlJDEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGUkMSkge1xuXHRcdFx0XHRzZXR0bGUoXCJ0aHJvd1wiLCBlJDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmdW5jdGlvbiBzZXR0bGUoZSQxLCBuKSB7XG5cdFx0XHRzd2l0Y2ggKGUkMSkge1xuXHRcdFx0XHRjYXNlIFwicmV0dXJuXCI6XG5cdFx0XHRcdFx0ci5yZXNvbHZlKHtcblx0XHRcdFx0XHRcdHZhbHVlOiBuLFxuXHRcdFx0XHRcdFx0ZG9uZTogITBcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInRocm93XCI6XG5cdFx0XHRcdFx0ci5yZWplY3Qobik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6IHIucmVzb2x2ZSh7XG5cdFx0XHRcdFx0dmFsdWU6IG4sXG5cdFx0XHRcdFx0ZG9uZTogITFcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQociA9IHIubmV4dCkgPyByZXN1bWUoci5rZXksIHIuYXJnKSA6IHQgPSBudWxsO1xuXHRcdH1cblx0XHR0aGlzLl9pbnZva2UgPSBmdW5jdGlvbihlJDEsIG4pIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihvLCB1KSB7XG5cdFx0XHRcdHZhciBpID0ge1xuXHRcdFx0XHRcdGtleTogZSQxLFxuXHRcdFx0XHRcdGFyZzogbixcblx0XHRcdFx0XHRyZXNvbHZlOiBvLFxuXHRcdFx0XHRcdHJlamVjdDogdSxcblx0XHRcdFx0XHRuZXh0OiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHRcdHQgPyB0ID0gdC5uZXh0ID0gaSA6IChyID0gdCA9IGksIHJlc3VtZShlJDEsIG4pKTtcblx0XHRcdH0pO1xuXHRcdH0sIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZVtcInJldHVyblwiXSAmJiAodGhpc1tcInJldHVyblwiXSA9IHZvaWQgMCk7XG5cdH1cblx0QXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1wiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCJdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnZva2UoXCJuZXh0XCIsIGUpO1xuXHR9LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbXCJ0aHJvd1wiXSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW52b2tlKFwidGhyb3dcIiwgZSk7XG5cdH0sIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtcInJldHVyblwiXSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW52b2tlKFwicmV0dXJuXCIsIGUpO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IF93cmFwQXN5bmNHZW5lcmF0b3IkNiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSB9KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvYXN5bmNJdGVyYWJsZS50c1xudmFyIGltcG9ydF91c2luZ0N0eCQ0ID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xudmFyIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDQgPSBfX3RvRVNNKHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvcigpLCAxKTtcbnZhciBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDUgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xuZnVuY3Rpb24gaXRlcmF0b3JSZXNvdXJjZShpdGVyYWJsZSkge1xuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuXHRpZiAoaXRlcmF0b3JbU3ltYm9sLmFzeW5jRGlzcG9zZV0pIHJldHVybiBpdGVyYXRvcjtcblx0cmV0dXJuIG1ha2VBc3luY1Jlc291cmNlKGl0ZXJhdG9yLCBhc3luYyAoKSA9PiB7XG5cdFx0dmFyIF9pdGVyYXRvciRyZXR1cm47XG5cdFx0YXdhaXQgKChfaXRlcmF0b3IkcmV0dXJuID0gaXRlcmF0b3IucmV0dXJuKSA9PT0gbnVsbCB8fCBfaXRlcmF0b3IkcmV0dXJuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaXRlcmF0b3IkcmV0dXJuLmNhbGwoaXRlcmF0b3IpKTtcblx0fSk7XG59XG4vKipcbiogRGVyaXZlcyBhIG5ldyB7QGxpbmsgQXN5bmNHZW5lcmF0b3J9IGJhc2VkIG9uIHtAbGluayBpdGVyYWJsZX0sIHRoYXQgYXV0b21hdGljYWxseSBhYm9ydHMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiovXG5mdW5jdGlvbiB3aXRoTWF4RHVyYXRpb24oX3gsIF94Mikge1xuXHRyZXR1cm4gX3dpdGhNYXhEdXJhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3dpdGhNYXhEdXJhdGlvbigpIHtcblx0X3dpdGhNYXhEdXJhdGlvbiA9ICgwLCBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDUuZGVmYXVsdCkoZnVuY3Rpb24qIChpdGVyYWJsZSwgb3B0cykge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4JDEgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDQuZGVmYXVsdCkoKTtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4JDEuYShpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKSk7XG5cdFx0XHRjb25zdCB0aW1lciA9IF91c2luZ0N0eCQxLnUodGltZXJSZXNvdXJjZShvcHRzLm1heER1cmF0aW9uTXMpKTtcblx0XHRcdGNvbnN0IHRpbWVyUHJvbWlzZSA9IHRpbWVyLnN0YXJ0KCk7XG5cdFx0XHRsZXQgcmVzdWx0O1xuXHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0cmVzdWx0ID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDQuZGVmYXVsdCkoVW5wcm9taXNlLnJhY2UoW2l0ZXJhdG9yLm5leHQoKSwgdGltZXJQcm9taXNlXSkpO1xuXHRcdFx0XHRpZiAocmVzdWx0ID09PSBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0KSB0aHJvd0Fib3J0RXJyb3IoKTtcblx0XHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR5aWVsZCByZXN1bHQudmFsdWU7XG5cdFx0XHRcdHJlc3VsdCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0X3VzaW5nQ3R4JDEuZSA9IF87XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQ0LmRlZmF1bHQpKF91c2luZ0N0eCQxLmQoKSk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIF93aXRoTWF4RHVyYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxuKiBEZXJpdmVzIGEgbmV3IHtAbGluayBBc3luY0dlbmVyYXRvcn0gYmFzZWQgb2Yge0BsaW5rIGl0ZXJhYmxlfSwgdGhhdCB5aWVsZHMgaXRzIGZpcnN0XG4qIHtAbGluayBjb3VudH0gdmFsdWVzLiBUaGVuLCBhIGdyYWNlIHBlcmlvZCBvZiB7QGxpbmsgZ3JhY2VQZXJpb2RNc30gaXMgc3RhcnRlZCBpbiB3aGljaCBmdXJ0aGVyXG4qIHZhbHVlcyBtYXkgc3RpbGwgY29tZSB0aHJvdWdoLiBBZnRlciB0aGlzIHBlcmlvZCwgdGhlIGdlbmVyYXRvciBhYm9ydHMuXG4qL1xuZnVuY3Rpb24gdGFrZVdpdGhHcmFjZShfeDMsIF94NCkge1xuXHRyZXR1cm4gX3Rha2VXaXRoR3JhY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF90YWtlV2l0aEdyYWNlKCkge1xuXHRfdGFrZVdpdGhHcmFjZSA9ICgwLCBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDUuZGVmYXVsdCkoZnVuY3Rpb24qIChpdGVyYWJsZSwgb3B0cykge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkNC5kZWZhdWx0KSgpO1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSBfdXNpbmdDdHgzLmEoaXRlcmF0b3JSZXNvdXJjZShpdGVyYWJsZSkpO1xuXHRcdFx0bGV0IHJlc3VsdDtcblx0XHRcdGNvbnN0IHRpbWVyID0gX3VzaW5nQ3R4My51KHRpbWVyUmVzb3VyY2Uob3B0cy5ncmFjZVBlcmlvZE1zKSk7XG5cdFx0XHRsZXQgY291bnQgPSBvcHRzLmNvdW50O1xuXHRcdFx0bGV0IHRpbWVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQ0LmRlZmF1bHQpKFVucHJvbWlzZS5yYWNlKFtpdGVyYXRvci5uZXh0KCksIHRpbWVyUHJvbWlzZV0pKTtcblx0XHRcdFx0aWYgKHJlc3VsdCA9PT0gZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCkgdGhyb3dBYm9ydEVycm9yKCk7XG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkgcmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRpZiAoLS1jb3VudCA9PT0gMCkgdGltZXJQcm9taXNlID0gdGltZXIuc3RhcnQoKTtcblx0XHRcdFx0cmVzdWx0ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRfdXNpbmdDdHgzLmUgPSBfO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkNC5kZWZhdWx0KShfdXNpbmdDdHgzLmQoKSk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIF90YWtlV2l0aEdyYWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2NyZWF0ZURlZmVycmVkLnRzXG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZCgpIHtcblx0bGV0IHJlc29sdmU7XG5cdGxldCByZWplY3Q7XG5cdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRyZXNvbHZlID0gcmVzO1xuXHRcdHJlamVjdCA9IHJlajtcblx0fSk7XG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZSxcblx0XHRyZXNvbHZlLFxuXHRcdHJlamVjdFxuXHR9O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9tZXJnZUFzeW5jSXRlcmFibGVzLnRzXG52YXIgaW1wb3J0X3VzaW5nQ3R4JDMgPSBfX3RvRVNNKHJlcXVpcmVfdXNpbmdDdHgoKSwgMSk7XG52YXIgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkMyA9IF9fdG9FU00ocmVxdWlyZV9hd2FpdEFzeW5jR2VuZXJhdG9yKCksIDEpO1xudmFyIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkNCA9IF9fdG9FU00ocmVxdWlyZV93cmFwQXN5bmNHZW5lcmF0b3IoKSwgMSk7XG5mdW5jdGlvbiBjcmVhdGVNYW5hZ2VkSXRlcmF0b3IoaXRlcmFibGUsIG9uUmVzdWx0KSB7XG5cdGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG5cdGxldCBzdGF0ZSA9IFwiaWRsZVwiO1xuXHRmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHRcdHN0YXRlID0gXCJkb25lXCI7XG5cdFx0b25SZXN1bHQgPSAoKSA9PiB7fTtcblx0fVxuXHRmdW5jdGlvbiBwdWxsKCkge1xuXHRcdGlmIChzdGF0ZSAhPT0gXCJpZGxlXCIpIHJldHVybjtcblx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiO1xuXHRcdGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0bmV4dC50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdGlmIChyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRzdGF0ZSA9IFwiZG9uZVwiO1xuXHRcdFx0XHRvblJlc3VsdCh7XG5cdFx0XHRcdFx0c3RhdHVzOiBcInJldHVyblwiLFxuXHRcdFx0XHRcdHZhbHVlOiByZXN1bHQudmFsdWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c3RhdGUgPSBcImlkbGVcIjtcblx0XHRcdG9uUmVzdWx0KHtcblx0XHRcdFx0c3RhdHVzOiBcInlpZWxkXCIsXG5cdFx0XHRcdHZhbHVlOiByZXN1bHQudmFsdWVcblx0XHRcdH0pO1xuXHRcdH0pLmNhdGNoKChjYXVzZSkgPT4ge1xuXHRcdFx0b25SZXN1bHQoe1xuXHRcdFx0XHRzdGF0dXM6IFwiZXJyb3JcIixcblx0XHRcdFx0ZXJyb3I6IGNhdXNlXG5cdFx0XHR9KTtcblx0XHRcdGNsZWFudXAoKTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHB1bGwsXG5cdFx0ZGVzdHJveTogYXN5bmMgKCkgPT4ge1xuXHRcdFx0dmFyIF9pdGVyYXRvciRyZXR1cm47XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRhd2FpdCAoKF9pdGVyYXRvciRyZXR1cm4gPSBpdGVyYXRvci5yZXR1cm4pID09PSBudWxsIHx8IF9pdGVyYXRvciRyZXR1cm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVyYXRvciRyZXR1cm4uY2FsbChpdGVyYXRvcikpO1xuXHRcdH1cblx0fTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgbmV3IGFzeW5jIGl0ZXJhYmxlIHRoYXQgbWVyZ2VzIG11bHRpcGxlIGFzeW5jIGl0ZXJhYmxlcyBpbnRvIGEgc2luZ2xlIHN0cmVhbS5cbiogVmFsdWVzIGZyb20gdGhlIGlucHV0IGl0ZXJhYmxlcyBhcmUgeWllbGRlZCBpbiB0aGUgb3JkZXIgdGhleSByZXNvbHZlLCBzaW1pbGFyIHRvIFByb21pc2UucmFjZSgpLlxuKlxuKiBOZXcgaXRlcmFibGVzIGNhbiBiZSBhZGRlZCBkeW5hbWljYWxseSB1c2luZyB0aGUgcmV0dXJuZWQge0BsaW5rIE1lcmdlZEFzeW5jSXRlcmFibGVzLmFkZH0gbWV0aG9kLCBldmVuIGFmdGVyIGl0ZXJhdGlvbiBoYXMgc3RhcnRlZC5cbipcbiogSWYgYW55IG9mIHRoZSBpbnB1dCBpdGVyYWJsZXMgdGhyb3dzIGFuIGVycm9yLCB0aGF0IGVycm9yIHdpbGwgYmUgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBtZXJnZWQgc3RyZWFtLlxuKiBPdGhlciBpdGVyYWJsZXMgd2lsbCBub3QgY29udGludWUgdG8gYmUgcHJvY2Vzc2VkLlxuKlxuKiBAdGVtcGxhdGUgVFlpZWxkIFRoZSB0eXBlIG9mIHZhbHVlcyB5aWVsZGVkIGJ5IHRoZSBpbnB1dCBpdGVyYWJsZXNcbiovXG5mdW5jdGlvbiBtZXJnZUFzeW5jSXRlcmFibGVzKCkge1xuXHRsZXQgc3RhdGUgPSBcImlkbGVcIjtcblx0bGV0IGZsdXNoU2lnbmFsID0gY3JlYXRlRGVmZXJyZWQoKTtcblx0LyoqXG5cdCogdXNlZCB3aGlsZSB7QGxpbmsgc3RhdGV9IGlzIGBpZGxlYFxuXHQqL1xuXHRjb25zdCBpdGVyYWJsZXMgPSBbXTtcblx0LyoqXG5cdCogdXNlZCB3aGlsZSB7QGxpbmsgc3RhdGV9IGlzIGBwZW5kaW5nYFxuXHQqL1xuXHRjb25zdCBpdGVyYXRvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuXHRjb25zdCBidWZmZXIgPSBbXTtcblx0ZnVuY3Rpb24gaW5pdEl0ZXJhYmxlKGl0ZXJhYmxlKSB7XG5cdFx0aWYgKHN0YXRlICE9PSBcInBlbmRpbmdcIikgcmV0dXJuO1xuXHRcdGNvbnN0IGl0ZXJhdG9yID0gY3JlYXRlTWFuYWdlZEl0ZXJhdG9yKGl0ZXJhYmxlLCAocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAoc3RhdGUgIT09IFwicGVuZGluZ1wiKSByZXR1cm47XG5cdFx0XHRzd2l0Y2ggKHJlc3VsdC5zdGF0dXMpIHtcblx0XHRcdFx0Y2FzZSBcInlpZWxkXCI6XG5cdFx0XHRcdFx0YnVmZmVyLnB1c2goW2l0ZXJhdG9yLCByZXN1bHRdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJldHVyblwiOlxuXHRcdFx0XHRcdGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0XHRidWZmZXIucHVzaChbaXRlcmF0b3IsIHJlc3VsdF0pO1xuXHRcdFx0XHRcdGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Zmx1c2hTaWduYWwucmVzb2x2ZSgpO1xuXHRcdH0pO1xuXHRcdGl0ZXJhdG9ycy5hZGQoaXRlcmF0b3IpO1xuXHRcdGl0ZXJhdG9yLnB1bGwoKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGFkZChpdGVyYWJsZSkge1xuXHRcdFx0c3dpdGNoIChzdGF0ZSkge1xuXHRcdFx0XHRjYXNlIFwiaWRsZVwiOlxuXHRcdFx0XHRcdGl0ZXJhYmxlcy5wdXNoKGl0ZXJhYmxlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInBlbmRpbmdcIjpcblx0XHRcdFx0XHRpbml0SXRlcmFibGUoaXRlcmFibGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZG9uZVwiOiBicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXHRcdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG5cdFx0XHRyZXR1cm4gKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkNC5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBfdXNpbmdDdHgkMSA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMy5kZWZhdWx0KSgpO1xuXHRcdFx0XHRcdGlmIChzdGF0ZSAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpdGVyYXRlIHR3aWNlXCIpO1xuXHRcdFx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCI7XG5cdFx0XHRcdFx0Y29uc3QgX2ZpbmFsbHkgPSBfdXNpbmdDdHgkMS5hKG1ha2VBc3luY1Jlc291cmNlKHt9LCBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiZG9uZVwiO1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyb3JzID0gW107XG5cdFx0XHRcdFx0XHRhd2FpdCBQcm9taXNlLmFsbChBcnJheS5mcm9tKGl0ZXJhdG9ycy52YWx1ZXMoKSkubWFwKGFzeW5jIChpdCkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IGl0LmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRcdFx0XHRlcnJvcnMucHVzaChjYXVzZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdGJ1ZmZlci5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0aXRlcmF0b3JzLmNsZWFyKCk7XG5cdFx0XHRcdFx0XHRmbHVzaFNpZ25hbC5yZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHRpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpO1xuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHR3aGlsZSAoaXRlcmFibGVzLmxlbmd0aCA+IDApIGluaXRJdGVyYWJsZShpdGVyYWJsZXMuc2hpZnQoKSk7XG5cdFx0XHRcdFx0d2hpbGUgKGl0ZXJhdG9ycy5zaXplID4gMCkge1xuXHRcdFx0XHRcdFx0eWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDMuZGVmYXVsdCkoZmx1c2hTaWduYWwucHJvbWlzZSk7XG5cdFx0XHRcdFx0XHR3aGlsZSAoYnVmZmVyLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgW2l0ZXJhdG9yLCByZXN1bHRdID0gYnVmZmVyLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAocmVzdWx0LnN0YXR1cykge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJ5aWVsZFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlcmF0b3IucHVsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImVycm9yXCI6IHRocm93IHJlc3VsdC5lcnJvcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zmx1c2hTaWduYWwgPSBjcmVhdGVEZWZlcnJlZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0XHRcdF91c2luZ0N0eCQxLmUgPSBfO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQzLmRlZmF1bHQpKF91c2luZ0N0eCQxLmQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20udHNcbi8qKlxuKiBDcmVhdGVzIGEgUmVhZGFibGVTdHJlYW0gZnJvbSBhbiBBc3luY0l0ZXJhYmxlLlxuKlxuKiBAcGFyYW0gaXRlcmFibGUgLSBUaGUgc291cmNlIEFzeW5jSXRlcmFibGUgdG8gc3RyZWFtIGZyb21cbiogQHJldHVybnMgQSBSZWFkYWJsZVN0cmVhbSB0aGF0IHlpZWxkcyB2YWx1ZXMgZnJvbSB0aGUgQXN5bmNJdGVyYWJsZVxuKi9cbmZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtRnJvbShpdGVyYWJsZSkge1xuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuXHRyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBjYW5jZWwoKSB7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yJHJldHVybjtcblx0XHRcdGF3YWl0ICgoX2l0ZXJhdG9yJHJldHVybiA9IGl0ZXJhdG9yLnJldHVybikgPT09IG51bGwgfHwgX2l0ZXJhdG9yJHJldHVybiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZXJhdG9yJHJldHVybi5jYWxsKGl0ZXJhdG9yKSk7XG5cdFx0fSxcblx0XHRhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRcdGlmIChyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3dpdGhQaW5nLnRzXG52YXIgaW1wb3J0X3VzaW5nQ3R4JDIgPSBfX3RvRVNNKHJlcXVpcmVfdXNpbmdDdHgoKSwgMSk7XG52YXIgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkMiA9IF9fdG9FU00ocmVxdWlyZV9hd2FpdEFzeW5jR2VuZXJhdG9yKCksIDEpO1xudmFyIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMyA9IF9fdG9FU00ocmVxdWlyZV93cmFwQXN5bmNHZW5lcmF0b3IoKSwgMSk7XG5jb25zdCBQSU5HX1NZTSA9IFN5bWJvbChcInBpbmdcIik7XG4vKipcbiogRGVyaXZlcyBhIG5ldyB7QGxpbmsgQXN5bmNHZW5lcmF0b3J9IGJhc2VkIG9mIHtAbGluayBpdGVyYWJsZX0sIHRoYXQgeWllbGRzIHtAbGluayBQSU5HX1NZTX1cbiogd2hlbmV2ZXIgbm8gdmFsdWUgaGFzIGJlZW4geWllbGRlZCBmb3Ige0BsaW5rIHBpbmdJbnRlcnZhbE1zfS5cbiovXG5mdW5jdGlvbiB3aXRoUGluZyhfeCwgX3gyKSB7XG5cdHJldHVybiBfd2l0aFBpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF93aXRoUGluZygpIHtcblx0X3dpdGhQaW5nID0gKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMy5kZWZhdWx0KShmdW5jdGlvbiogKGl0ZXJhYmxlLCBwaW5nSW50ZXJ2YWxNcykge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4JDEgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDIuZGVmYXVsdCkoKTtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4JDEuYShpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKSk7XG5cdFx0XHRsZXQgcmVzdWx0O1xuXHRcdFx0bGV0IG5leHRQcm9taXNlID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0d2hpbGUgKHRydWUpIHRyeSB7XG5cdFx0XHRcdHZhciBfdXNpbmdDdHgzID0gKDAsIGltcG9ydF91c2luZ0N0eCQyLmRlZmF1bHQpKCk7XG5cdFx0XHRcdGNvbnN0IHBpbmdQcm9taXNlID0gX3VzaW5nQ3R4My51KHRpbWVyUmVzb3VyY2UocGluZ0ludGVydmFsTXMpKTtcblx0XHRcdFx0cmVzdWx0ID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDIuZGVmYXVsdCkoVW5wcm9taXNlLnJhY2UoW25leHRQcm9taXNlLCBwaW5nUHJvbWlzZS5zdGFydCgpXSkpO1xuXHRcdFx0XHRpZiAocmVzdWx0ID09PSBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0KSB7XG5cdFx0XHRcdFx0eWllbGQgUElOR19TWU07XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3VsdC5kb25lKSByZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRuZXh0UHJvbWlzZSA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRyZXN1bHQgPSBudWxsO1xuXHRcdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0XHRfdXNpbmdDdHgzLmUgPSBfO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0X3VzaW5nQ3R4My5kKCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0X3VzaW5nQ3R4JDEuZSA9IF87XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQyLmRlZmF1bHQpKF91c2luZ0N0eCQxLmQoKSk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIF93aXRoUGluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hc3luY0l0ZXJhdG9yLmpzXG52YXIgcmVxdWlyZV9hc3luY0l0ZXJhdG9yID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvYXN5bmNJdGVyYXRvci5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHRmdW5jdGlvbiBfYXN5bmNJdGVyYXRvciQyKHIpIHtcblx0XHR2YXIgbiwgdCwgbywgZSA9IDI7XG5cdFx0Zm9yIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgKHQgPSBTeW1ib2wuYXN5bmNJdGVyYXRvciwgbyA9IFN5bWJvbC5pdGVyYXRvcik7IGUtLTspIHtcblx0XHRcdGlmICh0ICYmIG51bGwgIT0gKG4gPSByW3RdKSkgcmV0dXJuIG4uY2FsbChyKTtcblx0XHRcdGlmIChvICYmIG51bGwgIT0gKG4gPSByW29dKSkgcmV0dXJuIG5ldyBBc3luY0Zyb21TeW5jSXRlcmF0b3Iobi5jYWxsKHIpKTtcblx0XHRcdHQgPSBcIkBAYXN5bmNJdGVyYXRvclwiLCBvID0gXCJAQGl0ZXJhdG9yXCI7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlXCIpO1xuXHR9XG5cdGZ1bmN0aW9uIEFzeW5jRnJvbVN5bmNJdGVyYXRvcihyKSB7XG5cdFx0ZnVuY3Rpb24gQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKHIkMSkge1xuXHRcdFx0aWYgKE9iamVjdChyJDEpICE9PSByJDEpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKHIkMSArIFwiIGlzIG5vdCBhbiBvYmplY3QuXCIpKTtcblx0XHRcdHZhciBuID0gciQxLmRvbmU7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIkMS52YWx1ZSkudGhlbihmdW5jdGlvbihyJDIpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2YWx1ZTogciQyLFxuXHRcdFx0XHRcdGRvbmU6IG5cblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gQXN5bmNGcm9tU3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gQXN5bmNGcm9tU3luY0l0ZXJhdG9yJDEociQxKSB7XG5cdFx0XHR0aGlzLnMgPSByJDEsIHRoaXMubiA9IHIkMS5uZXh0O1xuXHRcdH0sIEFzeW5jRnJvbVN5bmNJdGVyYXRvci5wcm90b3R5cGUgPSB7XG5cdFx0XHRzOiBudWxsLFxuXHRcdFx0bjogbnVsbCxcblx0XHRcdG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdFx0XHRcdHJldHVybiBBc3luY0Zyb21TeW5jSXRlcmF0b3JDb250aW51YXRpb24odGhpcy5uLmFwcGx5KHRoaXMucywgYXJndW1lbnRzKSk7XG5cdFx0XHR9LFxuXHRcdFx0XCJyZXR1cm5cIjogZnVuY3Rpb24gX3JldHVybihyJDEpIHtcblx0XHRcdFx0dmFyIG4gPSB0aGlzLnNbXCJyZXR1cm5cIl07XG5cdFx0XHRcdHJldHVybiB2b2lkIDAgPT09IG4gPyBQcm9taXNlLnJlc29sdmUoe1xuXHRcdFx0XHRcdHZhbHVlOiByJDEsXG5cdFx0XHRcdFx0ZG9uZTogITBcblx0XHRcdFx0fSkgOiBBc3luY0Zyb21TeW5jSXRlcmF0b3JDb250aW51YXRpb24obi5hcHBseSh0aGlzLnMsIGFyZ3VtZW50cykpO1xuXHRcdFx0fSxcblx0XHRcdFwidGhyb3dcIjogZnVuY3Rpb24gX3Rocm93KHIkMSkge1xuXHRcdFx0XHR2YXIgbiA9IHRoaXMuc1tcInJldHVyblwiXTtcblx0XHRcdFx0cmV0dXJuIHZvaWQgMCA9PT0gbiA/IFByb21pc2UucmVqZWN0KHIkMSkgOiBBc3luY0Zyb21TeW5jSXRlcmF0b3JDb250aW51YXRpb24obi5hcHBseSh0aGlzLnMsIGFyZ3VtZW50cykpO1xuXHRcdFx0fVxuXHRcdH0sIG5ldyBBc3luY0Zyb21TeW5jSXRlcmF0b3Iocik7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNJdGVyYXRvciQyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS9qc29ubC50c1xudmFyIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDEgPSBfX3RvRVNNKHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvcigpLCAxKTtcbnZhciBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDIgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xudmFyIGltcG9ydF91c2luZ0N0eCQxID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xudmFyIGltcG9ydF9hc3luY0l0ZXJhdG9yJDEgPSBfX3RvRVNNKHJlcXVpcmVfYXN5bmNJdGVyYXRvcigpLCAxKTtcbmNvbnN0IENIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRSA9IDA7XG5jb25zdCBDSFVOS19WQUxVRV9UWVBFX0FTWU5DX0lURVJBQkxFID0gMTtcbmNvbnN0IFBST01JU0VfU1RBVFVTX0ZVTEZJTExFRCA9IDA7XG5jb25zdCBQUk9NSVNFX1NUQVRVU19SRUpFQ1RFRCA9IDE7XG5jb25zdCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOID0gMDtcbmNvbnN0IEFTWU5DX0lURVJBQkxFX1NUQVRVU19ZSUVMRCA9IDE7XG5jb25zdCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfRVJST1IgPSAyO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUpKSAmJiB0eXBlb2YgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVtcInRoZW5cIl0pID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVbXCJjYXRjaFwiXSkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbnZhciBNYXhEZXB0aEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHBhdGgpIHtcblx0XHRzdXBlcihcIk1heCBkZXB0aCByZWFjaGVkIGF0IHBhdGg6IFwiICsgcGF0aC5qb2luKFwiLlwiKSk7XG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIoX3gzKSB7XG5cdHJldHVybiBfY3JlYXRlQmF0Y2hTdHJlYW1Qcm9kdWNlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIoKSB7XG5cdF9jcmVhdGVCYXRjaFN0cmVhbVByb2R1Y2VyID0gKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMi5kZWZhdWx0KShmdW5jdGlvbiogKG9wdHMpIHtcblx0XHRjb25zdCB7IGRhdGEgfSA9IG9wdHM7XG5cdFx0bGV0IGNvdW50ZXIgPSAwO1xuXHRcdGNvbnN0IHBsYWNlaG9sZGVyID0gMDtcblx0XHRjb25zdCBtZXJnZWRJdGVyYWJsZXMgPSBtZXJnZUFzeW5jSXRlcmFibGVzKCk7XG5cdFx0ZnVuY3Rpb24gcmVnaXN0ZXJBc3luYyhjYWxsYmFjaykge1xuXHRcdFx0Y29uc3QgaWR4ID0gY291bnRlcisrO1xuXHRcdFx0Y29uc3QgaXRlcmFibGUkMSA9IGNhbGxiYWNrKGlkeCk7XG5cdFx0XHRtZXJnZWRJdGVyYWJsZXMuYWRkKGl0ZXJhYmxlJDEpO1xuXHRcdFx0cmV0dXJuIGlkeDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZW5jb2RlUHJvbWlzZShwcm9taXNlLCBwYXRoKSB7XG5cdFx0XHRyZXR1cm4gcmVnaXN0ZXJBc3luYygvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfcmVmID0gKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMi5kZWZhdWx0KShmdW5jdGlvbiogKGlkeCkge1xuXHRcdFx0XHRcdGNvbnN0IGVycm9yID0gY2hlY2tNYXhEZXB0aChwYXRoKTtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHByb21pc2UuY2F0Y2goKGNhdXNlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHZhciBfb3B0cyRvbkVycm9yO1xuXHRcdFx0XHRcdFx0XHQoX29wdHMkb25FcnJvciA9IG9wdHMub25FcnJvcikgPT09IG51bGwgfHwgX29wdHMkb25FcnJvciA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3IuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNhdXNlLFxuXHRcdFx0XHRcdFx0XHRcdHBhdGhcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0ID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDEuZGVmYXVsdCkocHJvbWlzZSk7XG5cdFx0XHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRcdFx0UFJPTUlTRV9TVEFUVVNfRlVMRklMTEVELFxuXHRcdFx0XHRcdFx0XHRlbmNvZGUobmV4dCwgcGF0aClcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0XHRcdHZhciBfb3B0cyRvbkVycm9yMiwgX29wdHMkZm9ybWF0RXJyb3I7XG5cdFx0XHRcdFx0XHQoX29wdHMkb25FcnJvcjIgPSBvcHRzLm9uRXJyb3IpID09PSBudWxsIHx8IF9vcHRzJG9uRXJyb3IyID09PSB2b2lkIDAgfHwgX29wdHMkb25FcnJvcjIuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRcdGVycm9yOiBjYXVzZSxcblx0XHRcdFx0XHRcdFx0cGF0aFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRcdFx0UFJPTUlTRV9TVEFUVVNfUkVKRUNURUQsXG5cdFx0XHRcdFx0XHRcdChfb3B0cyRmb3JtYXRFcnJvciA9IG9wdHMuZm9ybWF0RXJyb3IpID09PSBudWxsIHx8IF9vcHRzJGZvcm1hdEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRmb3JtYXRFcnJvci5jYWxsKG9wdHMsIHtcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRcdFx0cGF0aFxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oX3gpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZW5jb2RlQXN5bmNJdGVyYWJsZShpdGVyYWJsZSQxLCBwYXRoKSB7XG5cdFx0XHRyZXR1cm4gcmVnaXN0ZXJBc3luYygvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfcmVmMiA9ICgwLCBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDIuZGVmYXVsdCkoZnVuY3Rpb24qIChpZHgpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eCQxLmRlZmF1bHQpKCk7XG5cdFx0XHRcdFx0XHRjb25zdCBlcnJvciA9IGNoZWNrTWF4RGVwdGgocGF0aCk7XG5cdFx0XHRcdFx0XHRpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0XHRcdFx0Y29uc3QgaXRlcmF0b3IgPSBfdXNpbmdDdHgkMS5hKGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUkMSkpO1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBuZXh0ID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDEuZGVmYXVsdCkoaXRlcmF0b3IubmV4dCgpKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobmV4dC5kb25lKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0QVNZTkNfSVRFUkFCTEVfU1RBVFVTX1JFVFVSTixcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5jb2RlKG5leHQudmFsdWUsIHBhdGgpXG5cdFx0XHRcdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHlpZWxkIFtcblx0XHRcdFx0XHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRcdFx0XHRcdEFTWU5DX0lURVJBQkxFX1NUQVRVU19ZSUVMRCxcblx0XHRcdFx0XHRcdFx0XHRcdGVuY29kZShuZXh0LnZhbHVlLCBwYXRoKVxuXHRcdFx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGNhdXNlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBfb3B0cyRvbkVycm9yMywgX29wdHMkZm9ybWF0RXJyb3IyO1xuXHRcdFx0XHRcdFx0XHQoX29wdHMkb25FcnJvcjMgPSBvcHRzLm9uRXJyb3IpID09PSBudWxsIHx8IF9vcHRzJG9uRXJyb3IzID09PSB2b2lkIDAgfHwgX29wdHMkb25FcnJvcjMuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNhdXNlLFxuXHRcdFx0XHRcdFx0XHRcdHBhdGhcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHlpZWxkIFtcblx0XHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdFx0QVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SLFxuXHRcdFx0XHRcdFx0XHRcdChfb3B0cyRmb3JtYXRFcnJvcjIgPSBvcHRzLmZvcm1hdEVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRmb3JtYXRFcnJvcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJGZvcm1hdEVycm9yMi5jYWxsKG9wdHMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjYXVzZSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhdGhcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0XHRcdF91c2luZ0N0eCQxLmUgPSBfO1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHR5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkMS5kZWZhdWx0KShfdXNpbmdDdHgkMS5kKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihfeDIpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH0oKSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNoZWNrTWF4RGVwdGgocGF0aCkge1xuXHRcdFx0aWYgKG9wdHMubWF4RGVwdGggJiYgcGF0aC5sZW5ndGggPiBvcHRzLm1heERlcHRoKSByZXR1cm4gbmV3IE1heERlcHRoRXJyb3IocGF0aCk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZW5jb2RlQXN5bmModmFsdWUsIHBhdGgpIHtcblx0XHRcdGlmIChpc1Byb21pc2UodmFsdWUpKSByZXR1cm4gW0NIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRSwgZW5jb2RlUHJvbWlzZSh2YWx1ZSwgcGF0aCldO1xuXHRcdFx0aWYgKGlzQXN5bmNJdGVyYWJsZSh2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKG9wdHMubWF4RGVwdGggJiYgcGF0aC5sZW5ndGggPj0gb3B0cy5tYXhEZXB0aCkgdGhyb3cgbmV3IEVycm9yKFwiTWF4IGRlcHRoIHJlYWNoZWRcIik7XG5cdFx0XHRcdHJldHVybiBbQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRSwgZW5jb2RlQXN5bmNJdGVyYWJsZSh2YWx1ZSwgcGF0aCldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgcGF0aCkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB2b2lkIDApIHJldHVybiBbW11dO1xuXHRcdFx0Y29uc3QgcmVnID0gZW5jb2RlQXN5bmModmFsdWUsIHBhdGgpO1xuXHRcdFx0aWYgKHJlZykgcmV0dXJuIFtbcGxhY2Vob2xkZXJdLCBbbnVsbCwgLi4ucmVnXV07XG5cdFx0XHRpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSByZXR1cm4gW1t2YWx1ZV1dO1xuXHRcdFx0Y29uc3QgbmV3T2JqID0ge307XG5cdFx0XHRjb25zdCBhc3luY1ZhbHVlcyA9IFtdO1xuXHRcdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcblx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtZWQgPSBlbmNvZGVBc3luYyhpdGVtLCBbLi4ucGF0aCwga2V5XSk7XG5cdFx0XHRcdGlmICghdHJhbnNmb3JtZWQpIHtcblx0XHRcdFx0XHRuZXdPYmpba2V5XSA9IGl0ZW07XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3T2JqW2tleV0gPSBwbGFjZWhvbGRlcjtcblx0XHRcdFx0YXN5bmNWYWx1ZXMucHVzaChba2V5LCAuLi50cmFuc2Zvcm1lZF0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtbbmV3T2JqXSwgLi4uYXN5bmNWYWx1ZXNdO1xuXHRcdH1cblx0XHRjb25zdCBuZXdIZWFkID0ge307XG5cdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkgbmV3SGVhZFtrZXldID0gZW5jb2RlKGl0ZW0sIFtrZXldKTtcblx0XHR5aWVsZCBuZXdIZWFkO1xuXHRcdGxldCBpdGVyYWJsZSA9IG1lcmdlZEl0ZXJhYmxlcztcblx0XHRpZiAob3B0cy5waW5nTXMpIGl0ZXJhYmxlID0gd2l0aFBpbmcobWVyZ2VkSXRlcmFibGVzLCBvcHRzLnBpbmdNcyk7XG5cdFx0dmFyIF9pdGVyYXRvckFicnVwdENvbXBsZXRpb24gPSBmYWxzZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvciA9ICgwLCBpbXBvcnRfYXN5bmNJdGVyYXRvciQxLmRlZmF1bHQpKGl0ZXJhYmxlKSwgX3N0ZXA7IF9pdGVyYXRvckFicnVwdENvbXBsZXRpb24gPSAhKF9zdGVwID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDEuZGVmYXVsdCkoX2l0ZXJhdG9yLm5leHQoKSkpLmRvbmU7IF9pdGVyYXRvckFicnVwdENvbXBsZXRpb24gPSBmYWxzZSkge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuXHRcdFx0XHR5aWVsZCB2YWx1ZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoX2l0ZXJhdG9yQWJydXB0Q29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQxLmRlZmF1bHQpKF9pdGVyYXRvci5yZXR1cm4oKSk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBfY3JlYXRlQmF0Y2hTdHJlYW1Qcm9kdWNlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLyoqXG4qIEpTT04gTGluZXMgc3RyZWFtIHByb2R1Y2VyXG4qIEBzZWUgaHR0cHM6Ly9qc29ubGluZXMub3JnL1xuKi9cbmZ1bmN0aW9uIGpzb25sU3RyZWFtUHJvZHVjZXIob3B0cykge1xuXHRsZXQgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIob3B0cykpO1xuXHRjb25zdCB7IHNlcmlhbGl6ZSB9ID0gb3B0cztcblx0aWYgKHNlcmlhbGl6ZSkgc3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoY2h1bmsgPT09IFBJTkdfU1lNKSBjb250cm9sbGVyLmVucXVldWUoUElOR19TWU0pO1xuXHRcdGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHNlcmlhbGl6ZShjaHVuaykpO1xuXHR9IH0pKTtcblx0cmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHsgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG5cdFx0aWYgKGNodW5rID09PSBQSU5HX1NZTSkgY29udHJvbGxlci5lbnF1ZXVlKFwiIFwiKTtcblx0XHRlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZShKU09OLnN0cmluZ2lmeShjaHVuaykgKyBcIlxcblwiKTtcblx0fSB9KSkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xufVxudmFyIEFzeW5jRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoZGF0YSkge1xuXHRcdHN1cGVyKFwiUmVjZWl2ZWQgZXJyb3IgZnJvbSBzZXJ2ZXJcIik7XG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0fVxufTtcbmNvbnN0IG5vZGVKc1N0cmVhbVRvUmVhZGVyRXNxdWUgPSAoc291cmNlKSA9PiB7XG5cdHJldHVybiB7IGdldFJlYWRlcigpIHtcblx0XHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRzb3VyY2Uub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuXHRcdFx0fSk7XG5cdFx0XHRzb3VyY2Uub24oXCJlbmRcIiwgKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHR9KTtcblx0XHRcdHNvdXJjZS5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVycm9yKGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH0gfSk7XG5cdFx0cmV0dXJuIHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0fSB9O1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVBY2N1bXVsYXRvcihmcm9tKSB7XG5cdGNvbnN0IHJlYWRlciA9IFwiZ2V0UmVhZGVyXCIgaW4gZnJvbSA/IGZyb20uZ2V0UmVhZGVyKCkgOiBub2RlSnNTdHJlYW1Ub1JlYWRlckVzcXVlKGZyb20pLmdldFJlYWRlcigpO1xuXHRsZXQgbGluZUFnZ3JlZ2F0ZSA9IFwiXCI7XG5cdHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuXHRcdGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuXHRcdFx0Y29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblx0XHRcdGlmIChkb25lKSBjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHRjYW5jZWwoKSB7XG5cdFx0XHRyZXR1cm4gcmVhZGVyLmNhbmNlbCgpO1xuXHRcdH1cblx0fSkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHR2YXIgX3BhcnRzJHBvcDtcblx0XHRsaW5lQWdncmVnYXRlICs9IGNodW5rO1xuXHRcdGNvbnN0IHBhcnRzID0gbGluZUFnZ3JlZ2F0ZS5zcGxpdChcIlxcblwiKTtcblx0XHRsaW5lQWdncmVnYXRlID0gKF9wYXJ0cyRwb3AgPSBwYXJ0cy5wb3AoKSkgIT09IG51bGwgJiYgX3BhcnRzJHBvcCAhPT0gdm9pZCAwID8gX3BhcnRzJHBvcCA6IFwiXCI7XG5cdFx0Zm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSBjb250cm9sbGVyLmVucXVldWUocGFydCk7XG5cdH0gfSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29uc3VtZXJTdHJlYW0oZnJvbSkge1xuXHRjb25zdCBzdHJlYW0gPSBjcmVhdGVMaW5lQWNjdW11bGF0b3IoZnJvbSk7XG5cdGxldCBzZW50SGVhZCA9IGZhbHNlO1xuXHRyZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0obGluZSwgY29udHJvbGxlcikge1xuXHRcdGlmICghc2VudEhlYWQpIHtcblx0XHRcdGNvbnN0IGhlYWQgPSBKU09OLnBhcnNlKGxpbmUpO1xuXHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKGhlYWQpO1xuXHRcdFx0c2VudEhlYWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBjaHVuayA9IEpTT04ucGFyc2UobGluZSk7XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuXHRcdH1cblx0fSB9KSk7XG59XG4vKipcbiogQ3JlYXRlcyBhIGhhbmRsZXIgZm9yIG1hbmFnaW5nIHN0cmVhbSBjb250cm9sbGVycyBhbmQgdGhlaXIgbGlmZWN5Y2xlXG4qL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtc01hbmFnZXIoYWJvcnRDb250cm9sbGVyKSB7XG5cdGNvbnN0IGNvbnRyb2xsZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXHQvKipcblx0KiBDaGVja3MgaWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgY29udHJvbGxlcnMgb3IgZGVmZXJyZWQgcHJvbWlzZXNcblx0Ki9cblx0ZnVuY3Rpb24gaXNFbXB0eSgpIHtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbShjb250cm9sbGVyTWFwLnZhbHVlcygpKS5ldmVyeSgoYykgPT4gYy5jbG9zZWQpO1xuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBzdHJlYW0gY29udHJvbGxlclxuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVTdHJlYW1Db250cm9sbGVyKCkge1xuXHRcdGxldCBvcmlnaW5hbENvbnRyb2xsZXI7XG5cdFx0Y29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHsgc3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0b3JpZ2luYWxDb250cm9sbGVyID0gY29udHJvbGxlcjtcblx0XHR9IH0pO1xuXHRcdGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB7XG5cdFx0XHRlbnF1ZXVlOiAodikgPT4gb3JpZ2luYWxDb250cm9sbGVyLmVucXVldWUodiksXG5cdFx0XHRjbG9zZTogKCkgPT4ge1xuXHRcdFx0XHRvcmlnaW5hbENvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0Y2xlYXIoKTtcblx0XHRcdFx0aWYgKGlzRW1wdHkoKSkgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG5cdFx0XHR9LFxuXHRcdFx0Y2xvc2VkOiBmYWxzZSxcblx0XHRcdGdldFJlYWRlclJlc291cmNlOiAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0XHRcdFx0cmV0dXJuIG1ha2VSZXNvdXJjZShyZWFkZXIsICgpID0+IHtcblx0XHRcdFx0XHRyZWFkZXIucmVsZWFzZUxvY2soKTtcblx0XHRcdFx0XHRzdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiAocmVhc29uKSA9PiB7XG5cdFx0XHRcdG9yaWdpbmFsQ29udHJvbGxlci5lcnJvcihyZWFzb24pO1xuXHRcdFx0XHRjbGVhcigpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0ZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0XHRPYmplY3QuYXNzaWduKHN0cmVhbUNvbnRyb2xsZXIsIHtcblx0XHRcdFx0Y2xvc2VkOiB0cnVlLFxuXHRcdFx0XHRjbG9zZTogKCkgPT4ge30sXG5cdFx0XHRcdGVucXVldWU6ICgpID0+IHt9LFxuXHRcdFx0XHRnZXRSZWFkZXJSZXNvdXJjZTogbnVsbCxcblx0XHRcdFx0ZXJyb3I6ICgpID0+IHt9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cmVhbUNvbnRyb2xsZXI7XG5cdH1cblx0LyoqXG5cdCogR2V0cyBvciBjcmVhdGVzIGEgc3RyZWFtIGNvbnRyb2xsZXJcblx0Ki9cblx0ZnVuY3Rpb24gZ2V0T3JDcmVhdGUoY2h1bmtJZCkge1xuXHRcdGxldCBjID0gY29udHJvbGxlck1hcC5nZXQoY2h1bmtJZCk7XG5cdFx0aWYgKCFjKSB7XG5cdFx0XHRjID0gY3JlYXRlU3RyZWFtQ29udHJvbGxlcigpO1xuXHRcdFx0Y29udHJvbGxlck1hcC5zZXQoY2h1bmtJZCwgYyk7XG5cdFx0fVxuXHRcdHJldHVybiBjO1xuXHR9XG5cdC8qKlxuXHQqIENhbmNlbHMgYWxsIHBlbmRpbmcgY29udHJvbGxlcnMgYW5kIHJlamVjdHMgZGVmZXJyZWQgcHJvbWlzZXNcblx0Ki9cblx0ZnVuY3Rpb24gY2FuY2VsQWxsKHJlYXNvbikge1xuXHRcdGZvciAoY29uc3QgY29udHJvbGxlciBvZiBjb250cm9sbGVyTWFwLnZhbHVlcygpKSBjb250cm9sbGVyLmVycm9yKHJlYXNvbik7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRnZXRPckNyZWF0ZSxcblx0XHRpc0VtcHR5LFxuXHRcdGNhbmNlbEFsbFxuXHR9O1xufVxuLyoqXG4qIEpTT04gTGluZXMgc3RyZWFtIGNvbnN1bWVyXG4qIEBzZWUgaHR0cHM6Ly9qc29ubGluZXMub3JnL1xuKi9cbmFzeW5jIGZ1bmN0aW9uIGpzb25sU3RyZWFtQ29uc3VtZXIob3B0cykge1xuXHRjb25zdCB7IGRlc2VyaWFsaXplID0gKHYpID0+IHYgfSA9IG9wdHM7XG5cdGxldCBzb3VyY2UgPSBjcmVhdGVDb25zdW1lclN0cmVhbShvcHRzLmZyb20pO1xuXHRpZiAoZGVzZXJpYWxpemUpIHNvdXJjZSA9IHNvdXJjZS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHsgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG5cdFx0Y29udHJvbGxlci5lbnF1ZXVlKGRlc2VyaWFsaXplKGNodW5rKSk7XG5cdH0gfSkpO1xuXHRsZXQgaGVhZERlZmVycmVkID0gY3JlYXRlRGVmZXJyZWQoKTtcblx0Y29uc3Qgc3RyZWFtTWFuYWdlciA9IGNyZWF0ZVN0cmVhbXNNYW5hZ2VyKG9wdHMuYWJvcnRDb250cm9sbGVyKTtcblx0ZnVuY3Rpb24gZGVjb2RlQ2h1bmtEZWZpbml0aW9uKHZhbHVlKSB7XG5cdFx0Y29uc3QgW19wYXRoLCB0eXBlLCBjaHVua0lkXSA9IHZhbHVlO1xuXHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW1NYW5hZ2VyLmdldE9yQ3JlYXRlKGNodW5rSWQpO1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSBDSFVOS19WQUxVRV9UWVBFX1BST01JU0U6IHJldHVybiBydW4oYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBfdXNpbmdDdHgzID0gKDAsIGltcG9ydF91c2luZ0N0eCQxLmRlZmF1bHQpKCk7XG5cdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gX3VzaW5nQ3R4My51KGNvbnRyb2xsZXIuZ2V0UmVhZGVyUmVzb3VyY2UoKSk7XG5cdFx0XHRcdFx0Y29uc3QgeyB2YWx1ZTogdmFsdWUkMSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblx0XHRcdFx0XHRjb25zdCBbX2NodW5rSWQsIHN0YXR1cywgZGF0YV0gPSB2YWx1ZSQxO1xuXHRcdFx0XHRcdHN3aXRjaCAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFBST01JU0VfU1RBVFVTX0ZVTEZJTExFRDogcmV0dXJuIGRlY29kZShkYXRhKTtcblx0XHRcdFx0XHRcdGNhc2UgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQ6XG5cdFx0XHRcdFx0XHRcdHZhciBfb3B0cyRmb3JtYXRFcnJvcjMsIF9vcHRzJGZvcm1hdEVycm9yNDtcblx0XHRcdFx0XHRcdFx0dGhyb3cgKF9vcHRzJGZvcm1hdEVycm9yMyA9IChfb3B0cyRmb3JtYXRFcnJvcjQgPSBvcHRzLmZvcm1hdEVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRmb3JtYXRFcnJvcjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJGZvcm1hdEVycm9yNC5jYWxsKG9wdHMsIHsgZXJyb3I6IGRhdGEgfSkpICE9PSBudWxsICYmIF9vcHRzJGZvcm1hdEVycm9yMyAhPT0gdm9pZCAwID8gX29wdHMkZm9ybWF0RXJyb3IzIDogbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdFx0X3VzaW5nQ3R4My5lID0gXztcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRfdXNpbmdDdHgzLmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRjYXNlIENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEU6IHJldHVybiBydW4oKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMi5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBfdXNpbmdDdHg0ID0gKDAsIGltcG9ydF91c2luZ0N0eCQxLmRlZmF1bHQpKCk7XG5cdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gX3VzaW5nQ3R4NC51KGNvbnRyb2xsZXIuZ2V0UmVhZGVyUmVzb3VyY2UoKSk7XG5cdFx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHsgdmFsdWU6IHZhbHVlJDEgfSA9IHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQxLmRlZmF1bHQpKHJlYWRlci5yZWFkKCkpO1xuXHRcdFx0XHRcdFx0Y29uc3QgW19jaHVua0lkLCBzdGF0dXMsIGRhdGFdID0gdmFsdWUkMTtcblx0XHRcdFx0XHRcdHN3aXRjaCAoc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1lJRUxEOlxuXHRcdFx0XHRcdFx0XHRcdHlpZWxkIGRlY29kZShkYXRhKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOOiByZXR1cm4gZGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRjYXNlIEFTWU5DX0lURVJBQkxFX1NUQVRVU19FUlJPUjpcblx0XHRcdFx0XHRcdFx0XHR2YXIgX29wdHMkZm9ybWF0RXJyb3I1LCBfb3B0cyRmb3JtYXRFcnJvcjY7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgKF9vcHRzJGZvcm1hdEVycm9yNSA9IChfb3B0cyRmb3JtYXRFcnJvcjYgPSBvcHRzLmZvcm1hdEVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRmb3JtYXRFcnJvcjYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJGZvcm1hdEVycm9yNi5jYWxsKG9wdHMsIHsgZXJyb3I6IGRhdGEgfSkpICE9PSBudWxsICYmIF9vcHRzJGZvcm1hdEVycm9yNSAhPT0gdm9pZCAwID8gX29wdHMkZm9ybWF0RXJyb3I1IDogbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdFx0X3VzaW5nQ3R4NC5lID0gXztcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRfdXNpbmdDdHg0LmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBkZWNvZGUodmFsdWUpIHtcblx0XHRjb25zdCBbW2RhdGFdLCAuLi5hc3luY1Byb3BzXSA9IHZhbHVlO1xuXHRcdGZvciAoY29uc3QgdmFsdWUkMSBvZiBhc3luY1Byb3BzKSB7XG5cdFx0XHRjb25zdCBba2V5XSA9IHZhbHVlJDE7XG5cdFx0XHRjb25zdCBkZWNvZGVkID0gZGVjb2RlQ2h1bmtEZWZpbml0aW9uKHZhbHVlJDEpO1xuXHRcdFx0aWYgKGtleSA9PT0gbnVsbCkgcmV0dXJuIGRlY29kZWQ7XG5cdFx0XHRkYXRhW2tleV0gPSBkZWNvZGVkO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXHRjb25zdCBjbG9zZU9yQWJvcnQgPSAocmVhc29uKSA9PiB7XG5cdFx0aGVhZERlZmVycmVkID09PSBudWxsIHx8IGhlYWREZWZlcnJlZCA9PT0gdm9pZCAwIHx8IGhlYWREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcblx0XHRzdHJlYW1NYW5hZ2VyLmNhbmNlbEFsbChyZWFzb24pO1xuXHR9O1xuXHRzb3VyY2UucGlwZVRvKG5ldyBXcml0YWJsZVN0cmVhbSh7XG5cdFx0d3JpdGUoY2h1bmtPckhlYWQpIHtcblx0XHRcdGlmIChoZWFkRGVmZXJyZWQpIHtcblx0XHRcdFx0Y29uc3QgaGVhZCA9IGNodW5rT3JIZWFkO1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjaHVua09ySGVhZCkpIHtcblx0XHRcdFx0XHRjb25zdCBwYXJzZWQgPSBkZWNvZGUodmFsdWUpO1xuXHRcdFx0XHRcdGhlYWRba2V5XSA9IHBhcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRoZWFkRGVmZXJyZWQucmVzb2x2ZShoZWFkKTtcblx0XHRcdFx0aGVhZERlZmVycmVkID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY2h1bmsgPSBjaHVua09ySGVhZDtcblx0XHRcdGNvbnN0IFtpZHhdID0gY2h1bms7XG5cdFx0XHRjb25zdCBjb250cm9sbGVyID0gc3RyZWFtTWFuYWdlci5nZXRPckNyZWF0ZShpZHgpO1xuXHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcblx0XHR9LFxuXHRcdGNsb3NlOiAoKSA9PiBjbG9zZU9yQWJvcnQobmV3IEVycm9yKFwiU3RyZWFtIGNsb3NlZFwiKSksXG5cdFx0YWJvcnQ6IGNsb3NlT3JBYm9ydFxuXHR9KSwgeyBzaWduYWw6IG9wdHMuYWJvcnRDb250cm9sbGVyLnNpZ25hbCB9KS5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHR2YXIgX29wdHMkb25FcnJvcjQ7XG5cdFx0KF9vcHRzJG9uRXJyb3I0ID0gb3B0cy5vbkVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRvbkVycm9yNCA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3I0LmNhbGwob3B0cywgeyBlcnJvciB9KTtcblx0XHRjbG9zZU9yQWJvcnQoZXJyb3IpO1xuXHR9KTtcblx0cmV0dXJuIFthd2FpdCBoZWFkRGVmZXJyZWQucHJvbWlzZSwgc3RyZWFtTWFuYWdlcl07XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUuanNcbnZhciByZXF1aXJlX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hc3luY0dlbmVyYXRvckRlbGVnYXRlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZV9PdmVybG9hZFlpZWxkKCk7XG5cdGZ1bmN0aW9uIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlJDEodCkge1xuXHRcdHZhciBlID0ge30sIG4gPSAhMTtcblx0XHRmdW5jdGlvbiBwdW1wKGUkMSwgcikge1xuXHRcdFx0cmV0dXJuIG4gPSAhMCwgciA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4kMSkge1xuXHRcdFx0XHRuJDEodFtlJDFdKHIpKTtcblx0XHRcdH0pLCB7XG5cdFx0XHRcdGRvbmU6ICExLFxuXHRcdFx0XHR2YWx1ZTogbmV3IE92ZXJsb2FkWWllbGQociwgMSlcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBlW1widW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LCBlLm5leHQgPSBmdW5jdGlvbih0JDEpIHtcblx0XHRcdHJldHVybiBuID8gKG4gPSAhMSwgdCQxKSA6IHB1bXAoXCJuZXh0XCIsIHQkMSk7XG5cdFx0fSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0W1widGhyb3dcIl0gJiYgKGVbXCJ0aHJvd1wiXSA9IGZ1bmN0aW9uKHQkMSkge1xuXHRcdFx0aWYgKG4pIHRocm93IG4gPSAhMSwgdCQxO1xuXHRcdFx0cmV0dXJuIHB1bXAoXCJ0aHJvd1wiLCB0JDEpO1xuXHRcdH0pLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRbXCJyZXR1cm5cIl0gJiYgKGVbXCJyZXR1cm5cIl0gPSBmdW5jdGlvbih0JDEpIHtcblx0XHRcdHJldHVybiBuID8gKG4gPSAhMSwgdCQxKSA6IHB1bXAoXCJyZXR1cm5cIiwgdCQxKTtcblx0XHR9KSwgZTtcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IF9hc3luY0dlbmVyYXRvckRlbGVnYXRlJDEsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3NzZS50c1xudmFyIGltcG9ydF9hc3luY0l0ZXJhdG9yID0gX190b0VTTShyZXF1aXJlX2FzeW5jSXRlcmF0b3IoKSwgMSk7XG52YXIgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IgPSBfX3RvRVNNKHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvcigpLCAxKTtcbnZhciBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDEgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xudmFyIGltcG9ydF9hc3luY0dlbmVyYXRvckRlbGVnYXRlID0gX190b0VTTShyZXF1aXJlX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUoKSwgMSk7XG52YXIgaW1wb3J0X3VzaW5nQ3R4ID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xuY29uc3QgUElOR19FVkVOVCA9IFwicGluZ1wiO1xuY29uc3QgU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCA9IFwic2VyaWFsaXplZC1lcnJvclwiO1xuY29uc3QgQ09OTkVDVEVEX0VWRU5UID0gXCJjb25uZWN0ZWRcIjtcbmNvbnN0IFJFVFVSTl9FVkVOVCA9IFwicmV0dXJuXCI7XG4vKipcbipcbiogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbFxuKi9cbmZ1bmN0aW9uIHNzZVN0cmVhbVByb2R1Y2VyKG9wdHMpIHtcblx0dmFyIF9vcHRzJHBpbmckZW5hYmxlZCwgX29wdHMkcGluZywgX29wdHMkcGluZyRpbnRlcnZhbE1zLCBfb3B0cyRwaW5nMiwgX29wdHMkY2xpZW50O1xuXHRjb25zdCB7IHNlcmlhbGl6ZSA9IGlkZW50aXR5IH0gPSBvcHRzO1xuXHRjb25zdCBwaW5nID0ge1xuXHRcdGVuYWJsZWQ6IChfb3B0cyRwaW5nJGVuYWJsZWQgPSAoX29wdHMkcGluZyA9IG9wdHMucGluZykgPT09IG51bGwgfHwgX29wdHMkcGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkcGluZy5lbmFibGVkKSAhPT0gbnVsbCAmJiBfb3B0cyRwaW5nJGVuYWJsZWQgIT09IHZvaWQgMCA/IF9vcHRzJHBpbmckZW5hYmxlZCA6IGZhbHNlLFxuXHRcdGludGVydmFsTXM6IChfb3B0cyRwaW5nJGludGVydmFsTXMgPSAoX29wdHMkcGluZzIgPSBvcHRzLnBpbmcpID09PSBudWxsIHx8IF9vcHRzJHBpbmcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRwaW5nMi5pbnRlcnZhbE1zKSAhPT0gbnVsbCAmJiBfb3B0cyRwaW5nJGludGVydmFsTXMgIT09IHZvaWQgMCA/IF9vcHRzJHBpbmckaW50ZXJ2YWxNcyA6IDFlM1xuXHR9O1xuXHRjb25zdCBjbGllbnQgPSAoX29wdHMkY2xpZW50ID0gb3B0cy5jbGllbnQpICE9PSBudWxsICYmIF9vcHRzJGNsaWVudCAhPT0gdm9pZCAwID8gX29wdHMkY2xpZW50IDoge307XG5cdGlmIChwaW5nLmVuYWJsZWQgJiYgY2xpZW50LnJlY29ubmVjdEFmdGVySW5hY3Rpdml0eU1zICYmIHBpbmcuaW50ZXJ2YWxNcyA+IGNsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcykgdGhyb3cgbmV3IEVycm9yKGBQaW5nIGludGVydmFsIG11c3QgYmUgbGVzcyB0aGFuIGNsaWVudCByZWNvbm5lY3QgaW50ZXJ2YWwgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZWNvbm5lY3Rpb24gLSBwaW5nLmludGVydmFsTXM6ICR7cGluZy5pbnRlcnZhbE1zfSBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXM6ICR7Y2xpZW50LnJlY29ubmVjdEFmdGVySW5hY3Rpdml0eU1zfWApO1xuXHRmdW5jdGlvbiBnZW5lcmF0b3IoKSB7XG5cdFx0cmV0dXJuIF9nZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXHRmdW5jdGlvbiBfZ2VuZXJhdG9yKCkge1xuXHRcdF9nZW5lcmF0b3IgPSAoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQxLmRlZmF1bHQpKGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHR5aWVsZCB7XG5cdFx0XHRcdGV2ZW50OiBDT05ORUNURURfRVZFTlQsXG5cdFx0XHRcdGRhdGE6IEpTT04uc3RyaW5naWZ5KGNsaWVudClcblx0XHRcdH07XG5cdFx0XHRsZXQgaXRlcmFibGUgPSBvcHRzLmRhdGE7XG5cdFx0XHRpZiAob3B0cy5lbWl0QW5kRW5kSW1tZWRpYXRlbHkpIGl0ZXJhYmxlID0gdGFrZVdpdGhHcmFjZShpdGVyYWJsZSwge1xuXHRcdFx0XHRjb3VudDogMSxcblx0XHRcdFx0Z3JhY2VQZXJpb2RNczogMVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAob3B0cy5tYXhEdXJhdGlvbk1zICYmIG9wdHMubWF4RHVyYXRpb25NcyA+IDAgJiYgb3B0cy5tYXhEdXJhdGlvbk1zICE9PSBJbmZpbml0eSkgaXRlcmFibGUgPSB3aXRoTWF4RHVyYXRpb24oaXRlcmFibGUsIHsgbWF4RHVyYXRpb25Nczogb3B0cy5tYXhEdXJhdGlvbk1zIH0pO1xuXHRcdFx0aWYgKHBpbmcuZW5hYmxlZCAmJiBwaW5nLmludGVydmFsTXMgIT09IEluZmluaXR5ICYmIHBpbmcuaW50ZXJ2YWxNcyA+IDApIGl0ZXJhYmxlID0gd2l0aFBpbmcoaXRlcmFibGUsIHBpbmcuaW50ZXJ2YWxNcyk7XG5cdFx0XHRsZXQgdmFsdWU7XG5cdFx0XHRsZXQgY2h1bms7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yQWJydXB0Q29tcGxldGlvbiA9IGZhbHNlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgaW1wb3J0X2FzeW5jSXRlcmF0b3IuZGVmYXVsdCkoaXRlcmFibGUpLCBfc3RlcDsgX2l0ZXJhdG9yQWJydXB0Q29tcGxldGlvbiA9ICEoX3N0ZXAgPSB5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IuZGVmYXVsdCkoX2l0ZXJhdG9yLm5leHQoKSkpLmRvbmU7IF9pdGVyYXRvckFicnVwdENvbXBsZXRpb24gPSBmYWxzZSkge1xuXHRcdFx0XHRcdHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlID09PSBQSU5HX1NZTSkge1xuXHRcdFx0XHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQ6IFBJTkdfRVZFTlQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTogXCJcIlxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNodW5rID0gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpID8ge1xuXHRcdFx0XHRcdFx0XHRpZDogdmFsdWVbMF0sXG5cdFx0XHRcdFx0XHRcdGRhdGE6IHZhbHVlWzFdXG5cdFx0XHRcdFx0XHR9IDogeyBkYXRhOiB2YWx1ZSB9O1xuXHRcdFx0XHRcdFx0Y2h1bmsuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShjaHVuay5kYXRhKSk7XG5cdFx0XHRcdFx0XHR5aWVsZCBjaHVuaztcblx0XHRcdFx0XHRcdHZhbHVlID0gbnVsbDtcblx0XHRcdFx0XHRcdGNodW5rID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoX2l0ZXJhdG9yQWJydXB0Q29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvci5kZWZhdWx0KShfaXRlcmF0b3IucmV0dXJuKCkpO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gX2dlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cdGZ1bmN0aW9uIGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkge1xuXHRcdHJldHVybiBfZ2VuZXJhdG9yV2l0aEVycm9ySGFuZGxpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXHRmdW5jdGlvbiBfZ2VuZXJhdG9yV2l0aEVycm9ySGFuZGxpbmcoKSB7XG5cdFx0X2dlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nID0gKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMS5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0eWllbGQqICgwLCBpbXBvcnRfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZS5kZWZhdWx0KSgoMCwgaW1wb3J0X2FzeW5jSXRlcmF0b3IuZGVmYXVsdCkoZ2VuZXJhdG9yKCkpKTtcblx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdGV2ZW50OiBSRVRVUk5fRVZFTlQsXG5cdFx0XHRcdFx0ZGF0YTogXCJcIlxuXHRcdFx0XHR9O1xuXHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0dmFyIF9vcHRzJGZvcm1hdEVycm9yLCBfb3B0cyRmb3JtYXRFcnJvcjI7XG5cdFx0XHRcdGlmIChpc0Fib3J0RXJyb3IoY2F1c2UpKSByZXR1cm47XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpO1xuXHRcdFx0XHRjb25zdCBkYXRhID0gKF9vcHRzJGZvcm1hdEVycm9yID0gKF9vcHRzJGZvcm1hdEVycm9yMiA9IG9wdHMuZm9ybWF0RXJyb3IpID09PSBudWxsIHx8IF9vcHRzJGZvcm1hdEVycm9yMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkZm9ybWF0RXJyb3IyLmNhbGwob3B0cywgeyBlcnJvciB9KSkgIT09IG51bGwgJiYgX29wdHMkZm9ybWF0RXJyb3IgIT09IHZvaWQgMCA/IF9vcHRzJGZvcm1hdEVycm9yIDogbnVsbDtcblx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdGV2ZW50OiBTRVJJQUxJWkVEX0VSUk9SX0VWRU5ULFxuXHRcdFx0XHRcdGRhdGE6IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShkYXRhKSlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gX2dlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblx0Y29uc3Qgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkpO1xuXHRyZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoXCJldmVudFwiIGluIGNodW5rKSBjb250cm9sbGVyLmVucXVldWUoYGV2ZW50OiAke2NodW5rLmV2ZW50fVxcbmApO1xuXHRcdGlmIChcImRhdGFcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBkYXRhOiAke2NodW5rLmRhdGF9XFxuYCk7XG5cdFx0aWYgKFwiaWRcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBpZDogJHtjaHVuay5pZH1cXG5gKTtcblx0XHRpZiAoXCJjb21tZW50XCIgaW4gY2h1bmspIGNvbnRyb2xsZXIuZW5xdWV1ZShgOiAke2NodW5rLmNvbW1lbnR9XFxuYCk7XG5cdFx0Y29udHJvbGxlci5lbnF1ZXVlKFwiXFxuXFxuXCIpO1xuXHR9IH0pKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChvcHRzKSB7XG5cdHRyeSB7XG5cdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IHRpbWVvdXRQcm9taXNlID0gX3VzaW5nQ3R4JDEudSh0aW1lclJlc291cmNlKG9wdHMudGltZW91dE1zKSk7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW29wdHMucHJvbWlzZSwgdGltZW91dFByb21pc2Uuc3RhcnQoKV0pO1xuXHRcdGlmIChyZXMgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHJldHVybiBhd2FpdCBvcHRzLm9uVGltZW91dCgpO1xuXHRcdHJldHVybiByZXM7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cbi8qKlxuKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sXG4qL1xuZnVuY3Rpb24gc3NlU3RyZWFtQ29uc3VtZXIob3B0cykge1xuXHRjb25zdCB7IGRlc2VyaWFsaXplID0gKHYpID0+IHYgfSA9IG9wdHM7XG5cdGxldCBjbGllbnRPcHRpb25zID0ge307XG5cdGNvbnN0IHNpZ25hbCA9IG9wdHMuc2lnbmFsO1xuXHRsZXQgX2VzID0gbnVsbDtcblx0Y29uc3QgY3JlYXRlU3RyZWFtID0gKCkgPT4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRjb25zdCBbdXJsLCBpbml0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtvcHRzLnVybCgpLCBvcHRzLmluaXQoKV0pO1xuXHRcdFx0Y29uc3QgZXZlbnRTb3VyY2UgPSBfZXMgPSBuZXcgb3B0cy5FdmVudFNvdXJjZSh1cmwsIGluaXQpO1xuXHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0dHlwZTogXCJjb25uZWN0aW5nXCIsXG5cdFx0XHRcdGV2ZW50U291cmNlOiBfZXMsXG5cdFx0XHRcdGV2ZW50OiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoQ09OTkVDVEVEX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cdFx0XHRcdGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiY29ubmVjdGVkXCIsXG5cdFx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihTRVJJQUxJWkVEX0VSUk9SX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwic2VyaWFsaXplZC1lcnJvclwiLFxuXHRcdFx0XHRcdGVycm9yOiBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSksXG5cdFx0XHRcdFx0ZXZlbnRTb3VyY2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoUElOR19FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwicGluZ1wiLFxuXHRcdFx0XHRcdGV2ZW50U291cmNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFJFVFVSTl9FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdF9lcyA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50U291cmNlLnJlYWR5U3RhdGUgPT09IGV2ZW50U291cmNlLkNMT1NFRCkgY29udHJvbGxlci5lcnJvcihldmVudCk7XG5cdFx0XHRcdGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0XHR0eXBlOiBcImNvbm5lY3RpbmdcIixcblx0XHRcdFx0XHRldmVudFNvdXJjZSxcblx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKF9tc2cpID0+IHtcblx0XHRcdFx0Y29uc3QgbXNnID0gX21zZztcblx0XHRcdFx0Y29uc3QgY2h1bmsgPSBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSk7XG5cdFx0XHRcdGNvbnN0IGRlZiA9IHsgZGF0YTogY2h1bmsgfTtcblx0XHRcdFx0aWYgKG1zZy5sYXN0RXZlbnRJZCkgZGVmLmlkID0gbXNnLmxhc3RFdmVudElkO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiZGF0YVwiLFxuXHRcdFx0XHRcdGRhdGE6IGRlZixcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3Qgb25BYm9ydCA9ICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fSBjYXRjaCAoX3VudXNlZCkge31cblx0XHRcdH07XG5cdFx0XHRpZiAoc2lnbmFsLmFib3J0ZWQpIG9uQWJvcnQoKTtcblx0XHRcdGVsc2Ugc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblx0XHR9LFxuXHRcdGNhbmNlbCgpIHtcblx0XHRcdF9lcyA9PT0gbnVsbCB8fCBfZXMgPT09IHZvaWQgMCB8fCBfZXMuY2xvc2UoKTtcblx0XHR9XG5cdH0pO1xuXHRjb25zdCBnZXRTdHJlYW1SZXNvdXJjZSA9ICgpID0+IHtcblx0XHRsZXQgc3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG5cdFx0bGV0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0XHRhc3luYyBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0YXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuXHRcdFx0X2VzID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG1ha2VBc3luY1Jlc291cmNlKHtcblx0XHRcdHJlYWQoKSB7XG5cdFx0XHRcdHJldHVybiByZWFkZXIucmVhZCgpO1xuXHRcdFx0fSxcblx0XHRcdGFzeW5jIHJlY3JlYXRlKCkge1xuXHRcdFx0XHRhd2FpdCBkaXNwb3NlKCk7XG5cdFx0XHRcdHN0cmVhbSA9IGNyZWF0ZVN0cmVhbSgpO1xuXHRcdFx0XHRyZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdFx0XHR9XG5cdFx0fSwgZGlzcG9zZSk7XG5cdH07XG5cdHJldHVybiBydW4oKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMS5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHguZGVmYXVsdCkoKTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IF91c2luZ0N0eDMuYShnZXRTdHJlYW1SZXNvdXJjZSgpKTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdGxldCBwcm9taXNlID0gc3RyZWFtLnJlYWQoKTtcblx0XHRcdFx0Y29uc3QgdGltZW91dE1zID0gY2xpZW50T3B0aW9ucy5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcztcblx0XHRcdFx0aWYgKHRpbWVvdXRNcykgcHJvbWlzZSA9IHdpdGhUaW1lb3V0KHtcblx0XHRcdFx0XHRwcm9taXNlLFxuXHRcdFx0XHRcdHRpbWVvdXRNcyxcblx0XHRcdFx0XHRvblRpbWVvdXQ6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlcyA9IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInRpbWVvdXRcIixcblx0XHRcdFx0XHRcdFx0XHRtczogdGltZW91dE1zLFxuXHRcdFx0XHRcdFx0XHRcdGV2ZW50U291cmNlOiBfZXNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG9uZTogZmFsc2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRhd2FpdCBzdHJlYW0ucmVjcmVhdGUoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yLmRlZmF1bHQpKHByb21pc2UpO1xuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdHlpZWxkIHJlc3VsdC52YWx1ZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRfdXNpbmdDdHgzLmUgPSBfO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IuZGVmYXVsdCkoX3VzaW5nQ3R4My5kKCkpO1xuXHRcdH1cblx0fSkpO1xufVxuY29uc3Qgc3NlSGVhZGVycyA9IHtcblx0XCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuXHRcIkNhY2hlLUNvbnRyb2xcIjogXCJuby1jYWNoZSwgbm8tdHJhbnNmb3JtXCIsXG5cdFwiWC1BY2NlbC1CdWZmZXJpbmdcIjogXCJub1wiLFxuXHRDb25uZWN0aW9uOiBcImtlZXAtYWxpdmVcIlxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9odHRwL3Jlc29sdmVSZXNwb25zZS50c1xudmFyIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xudmFyIGltcG9ydF9vYmplY3RTcHJlYWQyID0gX190b0VTTShyZXF1aXJlX29iamVjdFNwcmVhZDIoKSwgMSk7XG5mdW5jdGlvbiBlcnJvclRvQXN5bmNJdGVyYWJsZShlcnIpIHtcblx0cmV0dXJuIHJ1bigoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvci5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdHRocm93IGVycjtcblx0fSkpO1xufVxuY29uc3QgVFlQRV9BQ0NFUFRFRF9NRVRIT0RfTUFQID0ge1xuXHRtdXRhdGlvbjogW1wiUE9TVFwiXSxcblx0cXVlcnk6IFtcIkdFVFwiXSxcblx0c3Vic2NyaXB0aW9uOiBbXCJHRVRcIl1cbn07XG5jb25zdCBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVBfV0lUSF9NRVRIT0RfT1ZFUlJJREUgPSB7XG5cdG11dGF0aW9uOiBbXCJQT1NUXCJdLFxuXHRxdWVyeTogW1wiR0VUXCIsIFwiUE9TVFwiXSxcblx0c3Vic2NyaXB0aW9uOiBbXCJHRVRcIiwgXCJQT1NUXCJdXG59O1xuZnVuY3Rpb24gaW5pdFJlc3BvbnNlKGluaXRPcHRzKSB7XG5cdHZhciBfcmVzcG9uc2VNZXRhLCBfaW5mbyRjYWxscyRmaW5kJHByb2MsIF9pbmZvJGNhbGxzJGZpbmQ7XG5cdGNvbnN0IHsgY3R4LCBpbmZvLCByZXNwb25zZU1ldGEsIHVudHJhbnNmb3JtZWRKU09OLCBlcnJvcnMgPSBbXSwgaGVhZGVycyB9ID0gaW5pdE9wdHM7XG5cdGxldCBzdGF0dXMgPSB1bnRyYW5zZm9ybWVkSlNPTiA/IGdldEhUVFBTdGF0dXNDb2RlKHVudHJhbnNmb3JtZWRKU09OKSA6IDIwMDtcblx0Y29uc3QgZWFnZXJHZW5lcmF0aW9uID0gIXVudHJhbnNmb3JtZWRKU09OO1xuXHRjb25zdCBkYXRhID0gZWFnZXJHZW5lcmF0aW9uID8gW10gOiBBcnJheS5pc0FycmF5KHVudHJhbnNmb3JtZWRKU09OKSA/IHVudHJhbnNmb3JtZWRKU09OIDogW3VudHJhbnNmb3JtZWRKU09OXTtcblx0Y29uc3QgbWV0YSA9IChfcmVzcG9uc2VNZXRhID0gcmVzcG9uc2VNZXRhID09PSBudWxsIHx8IHJlc3BvbnNlTWV0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VNZXRhKHtcblx0XHRjdHgsXG5cdFx0aW5mbyxcblx0XHRwYXRoczogaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvLmNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5wYXRoKSxcblx0XHRkYXRhLFxuXHRcdGVycm9ycyxcblx0XHRlYWdlckdlbmVyYXRpb24sXG5cdFx0dHlwZTogKF9pbmZvJGNhbGxzJGZpbmQkcHJvYyA9IGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwIHx8IChfaW5mbyRjYWxscyRmaW5kID0gaW5mby5jYWxscy5maW5kKChjYWxsKSA9PiB7XG5cdFx0XHR2YXIgX2NhbGwkcHJvY2VkdXJlO1xuXHRcdFx0cmV0dXJuIChfY2FsbCRwcm9jZWR1cmUgPSBjYWxsLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX2NhbGwkcHJvY2VkdXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbCRwcm9jZWR1cmUuX2RlZi50eXBlO1xuXHRcdH0pKSA9PT0gbnVsbCB8fCBfaW5mbyRjYWxscyRmaW5kID09PSB2b2lkIDAgfHwgKF9pbmZvJGNhbGxzJGZpbmQgPSBfaW5mbyRjYWxscyRmaW5kLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX2luZm8kY2FsbHMkZmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luZm8kY2FsbHMkZmluZC5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9pbmZvJGNhbGxzJGZpbmQkcHJvYyAhPT0gdm9pZCAwID8gX2luZm8kY2FsbHMkZmluZCRwcm9jIDogXCJ1bmtub3duXCJcblx0fSkpICE9PSBudWxsICYmIF9yZXNwb25zZU1ldGEgIT09IHZvaWQgMCA/IF9yZXNwb25zZU1ldGEgOiB7fTtcblx0aWYgKG1ldGEuaGVhZGVycykge1xuXHRcdGlmIChtZXRhLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtZXRhLmhlYWRlcnMuZW50cmllcygpKSBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcblx0XHRlbHNlXG4gLyoqXG5cdFx0KiBAZGVwcmVjYXRlZCwgZGVsZXRlIGluIHYxMlxuXHRcdCovXG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YS5oZWFkZXJzKSkgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIGhlYWRlcnMuYXBwZW5kKGtleSwgdik7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcblx0fVxuXHRpZiAobWV0YS5zdGF0dXMpIHN0YXR1cyA9IG1ldGEuc3RhdHVzO1xuXHRyZXR1cm4geyBzdGF0dXMgfTtcbn1cbmZ1bmN0aW9uIGNhdWdodEVycm9yVG9EYXRhKGNhdXNlLCBlcnJvck9wdHMpIHtcblx0Y29uc3QgeyByb3V0ZXIsIHJlcSwgb25FcnJvciB9ID0gZXJyb3JPcHRzLm9wdHM7XG5cdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpO1xuXHRvbkVycm9yID09PSBudWxsIHx8IG9uRXJyb3IgPT09IHZvaWQgMCB8fCBvbkVycm9yKHtcblx0XHRlcnJvcixcblx0XHRwYXRoOiBlcnJvck9wdHMucGF0aCxcblx0XHRpbnB1dDogZXJyb3JPcHRzLmlucHV0LFxuXHRcdGN0eDogZXJyb3JPcHRzLmN0eCxcblx0XHR0eXBlOiBlcnJvck9wdHMudHlwZSxcblx0XHRyZXFcblx0fSk7XG5cdGNvbnN0IHVudHJhbnNmb3JtZWRKU09OID0geyBlcnJvcjogZ2V0RXJyb3JTaGFwZSh7XG5cdFx0Y29uZmlnOiByb3V0ZXIuX2RlZi5fY29uZmlnLFxuXHRcdGVycm9yLFxuXHRcdHR5cGU6IGVycm9yT3B0cy50eXBlLFxuXHRcdHBhdGg6IGVycm9yT3B0cy5wYXRoLFxuXHRcdGlucHV0OiBlcnJvck9wdHMuaW5wdXQsXG5cdFx0Y3R4OiBlcnJvck9wdHMuY3R4XG5cdH0pIH07XG5cdGNvbnN0IHRyYW5zZm9ybWVkSlNPTiA9IHRyYW5zZm9ybVRSUENSZXNwb25zZShyb3V0ZXIuX2RlZi5fY29uZmlnLCB1bnRyYW5zZm9ybWVkSlNPTik7XG5cdGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEpTT04pO1xuXHRyZXR1cm4ge1xuXHRcdGVycm9yLFxuXHRcdHVudHJhbnNmb3JtZWRKU09OLFxuXHRcdGJvZHlcblx0fTtcbn1cbi8qKlxuKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgc3RyZWFtLWxpa2Ugb2JqZWN0XG4qIC0gaWYgaXQncyBhbiBhc3luYyBpdGVyYWJsZVxuKiAtIGlmIGl0J3MgYW4gb2JqZWN0IHdpdGggYXN5bmMgaXRlcmFibGVzIG9yIHByb21pc2VzXG4qL1xuZnVuY3Rpb24gaXNEYXRhU3RyZWFtKHYpIHtcblx0aWYgKCFpc09iamVjdCh2KSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaXNBc3luY0l0ZXJhYmxlKHYpKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIE9iamVjdC52YWx1ZXModikuc29tZShpc1Byb21pc2UpIHx8IE9iamVjdC52YWx1ZXModikuc29tZShpc0FzeW5jSXRlcmFibGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVJlc3BvbnNlKG9wdHMpIHtcblx0dmFyIF9yZWYsIF9vcHRzJGFsbG93QmF0Y2hpbmcsIF9vcHRzJGJhdGNoaW5nLCBfb3B0cyRhbGxvd01ldGhvZE92ZXIsIF9jb25maWckc3NlJGVuYWJsZWQsIF9jb25maWckc3NlO1xuXHRjb25zdCB7IHJvdXRlciwgcmVxIH0gPSBvcHRzO1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoW1tcInZhcnlcIiwgXCJ0cnBjLWFjY2VwdFwiXV0pO1xuXHRjb25zdCBjb25maWcgPSByb3V0ZXIuX2RlZi5fY29uZmlnO1xuXHRjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuXHRpZiAocmVxLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDIwNCB9KTtcblx0Y29uc3QgYWxsb3dCYXRjaGluZyA9IChfcmVmID0gKF9vcHRzJGFsbG93QmF0Y2hpbmcgPSBvcHRzLmFsbG93QmF0Y2hpbmcpICE9PSBudWxsICYmIF9vcHRzJGFsbG93QmF0Y2hpbmcgIT09IHZvaWQgMCA/IF9vcHRzJGFsbG93QmF0Y2hpbmcgOiAoX29wdHMkYmF0Y2hpbmcgPSBvcHRzLmJhdGNoaW5nKSA9PT0gbnVsbCB8fCBfb3B0cyRiYXRjaGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkYmF0Y2hpbmcuZW5hYmxlZCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IHRydWU7XG5cdGNvbnN0IGFsbG93TWV0aG9kT3ZlcnJpZGUgPSAoKF9vcHRzJGFsbG93TWV0aG9kT3ZlciA9IG9wdHMuYWxsb3dNZXRob2RPdmVycmlkZSkgIT09IG51bGwgJiYgX29wdHMkYWxsb3dNZXRob2RPdmVyICE9PSB2b2lkIDAgPyBfb3B0cyRhbGxvd01ldGhvZE92ZXIgOiBmYWxzZSkgJiYgcmVxLm1ldGhvZCA9PT0gXCJQT1NUXCI7XG5cdGNvbnN0IGluZm9UdXBsZSA9IGF3YWl0IHJ1bihhc3luYyAoKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBbdm9pZCAwLCBhd2FpdCBnZXRSZXF1ZXN0SW5mbyh7XG5cdFx0XHRcdHJlcSxcblx0XHRcdFx0cGF0aDogZGVjb2RlVVJJQ29tcG9uZW50KG9wdHMucGF0aCksXG5cdFx0XHRcdHJvdXRlcixcblx0XHRcdFx0c2VhcmNoUGFyYW1zOiB1cmwuc2VhcmNoUGFyYW1zLFxuXHRcdFx0XHRoZWFkZXJzOiBvcHRzLnJlcS5oZWFkZXJzLFxuXHRcdFx0XHR1cmxcblx0XHRcdH0pXTtcblx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0cmV0dXJuIFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHZvaWQgMF07XG5cdFx0fVxuXHR9KTtcblx0Y29uc3QgY3R4TWFuYWdlciA9IHJ1bigoKSA9PiB7XG5cdFx0bGV0IHJlc3VsdCA9IHZvaWQgMDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWVPclVuZGVmaW5lZDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXJlc3VsdCkgcmV0dXJuIHZvaWQgMDtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdFsxXTtcblx0XHRcdH0sXG5cdFx0XHR2YWx1ZTogKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBbZXJyLCBjdHhdID0gcmVzdWx0O1xuXHRcdFx0XHRpZiAoZXJyKSB0aHJvdyBlcnI7XG5cdFx0XHRcdHJldHVybiBjdHg7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlOiBhc3luYyAoaW5mbykgPT4ge1xuXHRcdFx0XHRpZiAocmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIC0gcmVwb3J0IGEgYnVnIGluIHRSUENcIik7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgY3R4ID0gYXdhaXQgb3B0cy5jcmVhdGVDb250ZXh0KHsgaW5mbyB9KTtcblx0XHRcdFx0XHRyZXN1bHQgPSBbdm9pZCAwLCBjdHhdO1xuXHRcdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHZvaWQgMF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblx0Y29uc3QgbWV0aG9kTWFwcGVyID0gYWxsb3dNZXRob2RPdmVycmlkZSA/IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUF9XSVRIX01FVEhPRF9PVkVSUklERSA6IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUDtcblx0LyoqXG5cdCogQGRlcHJlY2F0ZWRcblx0Ki9cblx0Y29uc3QgaXNTdHJlYW1DYWxsID0gcmVxLmhlYWRlcnMuZ2V0KFwidHJwYy1hY2NlcHRcIikgPT09IFwiYXBwbGljYXRpb24vanNvbmxcIjtcblx0Y29uc3QgZXhwZXJpbWVudGFsU1NFID0gKF9jb25maWckc3NlJGVuYWJsZWQgPSAoX2NvbmZpZyRzc2UgPSBjb25maWcuc3NlKSA9PT0gbnVsbCB8fCBfY29uZmlnJHNzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbmZpZyRzc2UuZW5hYmxlZCkgIT09IG51bGwgJiYgX2NvbmZpZyRzc2UkZW5hYmxlZCAhPT0gdm9pZCAwID8gX2NvbmZpZyRzc2UkZW5hYmxlZCA6IHRydWU7XG5cdHRyeSB7XG5cdFx0Y29uc3QgW2luZm9FcnJvciwgaW5mb10gPSBpbmZvVHVwbGU7XG5cdFx0aWYgKGluZm9FcnJvcikgdGhyb3cgaW5mb0Vycm9yO1xuXHRcdGlmIChpbmZvLmlzQmF0Y2hDYWxsICYmICFhbGxvd0JhdGNoaW5nKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcblx0XHRcdG1lc3NhZ2U6IGBCYXRjaGluZyBpcyBub3QgZW5hYmxlZCBvbiB0aGUgc2VydmVyYFxuXHRcdH0pO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0XHRpZiAoaXNTdHJlYW1DYWxsICYmICFpbmZvLmlzQmF0Y2hDYWxsKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdG1lc3NhZ2U6IGBTdHJlYW1pbmcgcmVxdWVzdHMgbXVzdCBiZSBiYXRjaGVkICh5b3UgY2FuIGRvIGEgYmF0Y2ggb2YgMSlgLFxuXHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiXG5cdFx0fSk7XG5cdFx0YXdhaXQgY3R4TWFuYWdlci5jcmVhdGUoaW5mbyk7XG5cdFx0Y29uc3QgcnBjQ2FsbHMgPSBpbmZvLmNhbGxzLm1hcChhc3luYyAoY2FsbCkgPT4ge1xuXHRcdFx0Y29uc3QgcHJvYyA9IGNhbGwucHJvY2VkdXJlO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKG9wdHMuZXJyb3IpIHRocm93IG9wdHMuZXJyb3I7XG5cdFx0XHRcdGlmICghcHJvYykgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0Y29kZTogXCJOT1RfRk9VTkRcIixcblx0XHRcdFx0XHRtZXNzYWdlOiBgTm8gcHJvY2VkdXJlIGZvdW5kIG9uIHBhdGggXCIke2NhbGwucGF0aH1cImBcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmICghbWV0aG9kTWFwcGVyW3Byb2MuX2RlZi50eXBlXS5pbmNsdWRlcyhyZXEubWV0aG9kKSkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCAke3JlcS5tZXRob2R9LXJlcXVlc3QgdG8gJHtwcm9jLl9kZWYudHlwZX0gcHJvY2VkdXJlIGF0IHBhdGggXCIke2NhbGwucGF0aH1cImBcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChwcm9jLl9kZWYudHlwZSA9PT0gXCJzdWJzY3JpcHRpb25cIikge1xuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0XHRcdFx0XHRpZiAoaW5mby5pc0JhdGNoQ2FsbCkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBgQ2Fubm90IGJhdGNoIHN1YnNjcmlwdGlvbiBjYWxsc2Bcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcHJvYyh7XG5cdFx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHRcdGdldFJhd0lucHV0OiBjYWxsLmdldFJhd0lucHV0LFxuXHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZSgpLFxuXHRcdFx0XHRcdHR5cGU6IHByb2MuX2RlZi50eXBlLFxuXHRcdFx0XHRcdHNpZ25hbDogb3B0cy5yZXEuc2lnbmFsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gW3ZvaWQgMCwgeyBkYXRhIH1dO1xuXHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0dmFyIF9vcHRzJG9uRXJyb3IsIF9jYWxsJHByb2NlZHVyZSRfZGVmJCwgX2NhbGwkcHJvY2VkdXJlMjtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSk7XG5cdFx0XHRcdGNvbnN0IGlucHV0ID0gY2FsbC5yZXN1bHQoKTtcblx0XHRcdFx0KF9vcHRzJG9uRXJyb3IgPSBvcHRzLm9uRXJyb3IpID09PSBudWxsIHx8IF9vcHRzJG9uRXJyb3IgPT09IHZvaWQgMCB8fCBfb3B0cyRvbkVycm9yLmNhbGwob3B0cywge1xuXHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdHBhdGg6IGNhbGwucGF0aCxcblx0XHRcdFx0XHRpbnB1dCxcblx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdHR5cGU6IChfY2FsbCRwcm9jZWR1cmUkX2RlZiQgPSAoX2NhbGwkcHJvY2VkdXJlMiA9IGNhbGwucHJvY2VkdXJlKSA9PT0gbnVsbCB8fCBfY2FsbCRwcm9jZWR1cmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbCRwcm9jZWR1cmUyLl9kZWYudHlwZSkgIT09IG51bGwgJiYgX2NhbGwkcHJvY2VkdXJlJF9kZWYkICE9PSB2b2lkIDAgPyBfY2FsbCRwcm9jZWR1cmUkX2RlZiQgOiBcInVua25vd25cIixcblx0XHRcdFx0XHRyZXE6IG9wdHMucmVxXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gW2Vycm9yLCB2b2lkIDBdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmICghaW5mby5pc0JhdGNoQ2FsbCkge1xuXHRcdFx0Y29uc3QgW2NhbGxdID0gaW5mby5jYWxscztcblx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJwY0NhbGxzWzBdO1xuXHRcdFx0c3dpdGNoIChpbmZvLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInVua25vd25cIjpcblx0XHRcdFx0Y2FzZSBcIm11dGF0aW9uXCI6XG5cdFx0XHRcdGNhc2UgXCJxdWVyeVwiOiB7XG5cdFx0XHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmRhdGEpKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogXCJDYW5ub3QgdXNlIHN0cmVhbS1saWtlIHJlc3BvbnNlIGluIG5vbi1zdHJlYW1pbmcgcmVxdWVzdCAtIHVzZSBodHRwQmF0Y2hTdHJlYW1MaW5rXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb25zdCByZXMgPSBlcnJvciA/IHsgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IGNhbGwucmVzdWx0KCksXG5cdFx0XHRcdFx0XHRwYXRoOiBjYWxsLnBhdGgsXG5cdFx0XHRcdFx0XHR0eXBlOiBpbmZvLnR5cGVcblx0XHRcdFx0XHR9KSB9IDogeyByZXN1bHQ6IHsgZGF0YTogcmVzdWx0LmRhdGEgfSB9O1xuXHRcdFx0XHRcdGNvbnN0IGhlYWRSZXNwb25zZSQxID0gaW5pdFJlc3BvbnNlKHtcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRpbmZvLFxuXHRcdFx0XHRcdFx0cmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcblx0XHRcdFx0XHRcdGVycm9yczogZXJyb3IgPyBbZXJyb3JdIDogW10sXG5cdFx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdFx0dW50cmFuc2Zvcm1lZEpTT046IFtyZXNdXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1UUlBDUmVzcG9uc2UoY29uZmlnLCByZXMpKSwge1xuXHRcdFx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXMsXG5cdFx0XHRcdFx0XHRoZWFkZXJzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBcInN1YnNjcmlwdGlvblwiOiB7XG5cdFx0XHRcdFx0Y29uc3QgaXRlcmFibGUgPSBydW4oKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGVycm9yKSByZXR1cm4gZXJyb3JUb0FzeW5jSXRlcmFibGUoZXJyb3IpO1xuXHRcdFx0XHRcdFx0aWYgKCFleHBlcmltZW50YWxTU0UpIHJldHVybiBlcnJvclRvQXN5bmNJdGVyYWJsZShuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZXJpbWVudGFsIGZsYWcgXFxcInNzZVN1YnNjcmlwdGlvbnNcXFwiXCJcblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdGlmICghaXNPYnNlcnZhYmxlKHJlc3VsdC5kYXRhKSAmJiAhaXNBc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhKSkgcmV0dXJuIGVycm9yVG9Bc3luY0l0ZXJhYmxlKG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBgU3Vic2NyaXB0aW9uICR7Y2FsbC5wYXRofSBkaWQgbm90IHJldHVybiBhbiBvYnNlcnZhYmxlIG9yIGEgQXN5bmNHZW5lcmF0b3JgLFxuXHRcdFx0XHRcdFx0XHRjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiXG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhQXNJdGVyYWJsZSA9IGlzT2JzZXJ2YWJsZShyZXN1bHQuZGF0YSkgPyBvYnNlcnZhYmxlVG9Bc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhLCBvcHRzLnJlcS5zaWduYWwpIDogcmVzdWx0LmRhdGE7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YUFzSXRlcmFibGU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gc3NlU3RyZWFtUHJvZHVjZXIoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgY29uZmlnLnNzZSksIHt9LCB7XG5cdFx0XHRcdFx0XHRkYXRhOiBpdGVyYWJsZSxcblx0XHRcdFx0XHRcdHNlcmlhbGl6ZTogKHYpID0+IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKHYpLFxuXHRcdFx0XHRcdFx0Zm9ybWF0RXJyb3IoZXJyb3JPcHRzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBfY2FsbCRwcm9jZWR1cmUkX2RlZiQyLCBfY2FsbCRwcm9jZWR1cmUzLCBfb3B0cyRvbkVycm9yMjtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IkMSA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGVycm9yT3B0cy5lcnJvcik7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGlucHV0ID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnJlc3VsdCgpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBwYXRoID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnBhdGg7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHR5cGUgPSAoX2NhbGwkcHJvY2VkdXJlJF9kZWYkMiA9IGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwIHx8IChfY2FsbCRwcm9jZWR1cmUzID0gY2FsbC5wcm9jZWR1cmUpID09PSBudWxsIHx8IF9jYWxsJHByb2NlZHVyZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jYWxsJHByb2NlZHVyZTMuX2RlZi50eXBlKSAhPT0gbnVsbCAmJiBfY2FsbCRwcm9jZWR1cmUkX2RlZiQyICE9PSB2b2lkIDAgPyBfY2FsbCRwcm9jZWR1cmUkX2RlZiQyIDogXCJ1bmtub3duXCI7XG5cdFx0XHRcdFx0XHRcdChfb3B0cyRvbkVycm9yMiA9IG9wdHMub25FcnJvcikgPT09IG51bGwgfHwgX29wdHMkb25FcnJvcjIgPT09IHZvaWQgMCB8fCBfb3B0cyRvbkVycm9yMi5jYWxsKG9wdHMsIHtcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IkMSxcblx0XHRcdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRcdFx0cmVxOiBvcHRzLnJlcSxcblx0XHRcdFx0XHRcdFx0XHR0eXBlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0XHRcdGNvbmZpZyxcblx0XHRcdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJvciQxLFxuXHRcdFx0XHRcdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNoYXBlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzc2VIZWFkZXJzKSkgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgaGVhZFJlc3BvbnNlJDEgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGluZm8sXG5cdFx0XHRcdFx0XHRyZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuXHRcdFx0XHRcdFx0ZXJyb3JzOiBbXSxcblx0XHRcdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdFx0XHR1bnRyYW5zZm9ybWVkSlNPTjogbnVsbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaW5mby5hY2NlcHQgPT09IFwiYXBwbGljYXRpb24vanNvbmxcIikge1xuXHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0aGVhZGVycy5zZXQoXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLCBcImNodW5rZWRcIik7XG5cdFx0XHRjb25zdCBoZWFkUmVzcG9uc2UkMSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdGluZm8sXG5cdFx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHRcdGVycm9yczogW10sXG5cdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdHVudHJhbnNmb3JtZWRKU09OOiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IGpzb25sU3RyZWFtUHJvZHVjZXIoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgY29uZmlnLmpzb25sKSwge30sIHtcblx0XHRcdFx0bWF4RGVwdGg6IEluZmluaXR5LFxuXHRcdFx0XHRkYXRhOiBycGNDYWxscy5tYXAoYXN5bmMgKHJlcykgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJlcztcblx0XHRcdFx0XHRjb25zdCBjYWxsID0gaW5mby5jYWxsc1swXTtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHZhciBfcHJvY2VkdXJlJF9kZWYkdHlwZSwgX3Byb2NlZHVyZTtcblx0XHRcdFx0XHRcdHJldHVybiB7IGVycm9yOiBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0XHRlcnJvcixcblx0XHRcdFx0XHRcdFx0aW5wdXQ6IGNhbGwucmVzdWx0KCksXG5cdFx0XHRcdFx0XHRcdHBhdGg6IGNhbGwucGF0aCxcblx0XHRcdFx0XHRcdFx0dHlwZTogKF9wcm9jZWR1cmUkX2RlZiR0eXBlID0gKF9wcm9jZWR1cmUgPSBjYWxsLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX3Byb2NlZHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb2NlZHVyZS5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9wcm9jZWR1cmUkX2RlZiR0eXBlICE9PSB2b2lkIDAgPyBfcHJvY2VkdXJlJF9kZWYkdHlwZSA6IFwidW5rbm93blwiXG5cdFx0XHRcdFx0XHR9KSB9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQqIE5vdCB2ZXJ5IHByZXR0eSwgYnV0IHdlIG5lZWQgdG8gd3JhcCBuZXN0ZWQgZGF0YSBpbiBwcm9taXNlc1xuXHRcdFx0XHRcdCogT3VyIHN0cmVhbSBwcm9kdWNlciB3aWxsIG9ubHkgcmVzb2x2ZSB0b3AtbGV2ZWwgYXN5bmMgdmFsdWVzIG9yIGFzeW5jIHZhbHVlcyB0aGF0IGFyZSBkaXJlY3RseSBuZXN0ZWQgaW4gYW5vdGhlciBhc3luYyB2YWx1ZVxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0Y29uc3QgaXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpID8gb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSwgb3B0cy5yZXEuc2lnbmFsKSA6IFByb21pc2UucmVzb2x2ZShyZXN1bHQuZGF0YSk7XG5cdFx0XHRcdFx0cmV0dXJuIHsgcmVzdWx0OiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBpdGVyYWJsZSB9KSB9O1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0c2VyaWFsaXplOiAoZGF0YSkgPT4gY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoZGF0YSksXG5cdFx0XHRcdG9uRXJyb3I6IChjYXVzZSkgPT4ge1xuXHRcdFx0XHRcdHZhciBfb3B0cyRvbkVycm9yMywgX2luZm8kdHlwZTtcblx0XHRcdFx0XHQoX29wdHMkb25FcnJvcjMgPSBvcHRzLm9uRXJyb3IpID09PSBudWxsIHx8IF9vcHRzJG9uRXJyb3IzID09PSB2b2lkIDAgfHwgX29wdHMkb25FcnJvcjMuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuXHRcdFx0XHRcdFx0cGF0aDogdm9pZCAwLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IHZvaWQgMCxcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRyZXE6IG9wdHMucmVxLFxuXHRcdFx0XHRcdFx0dHlwZTogKF9pbmZvJHR5cGUgPSBpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm8udHlwZSkgIT09IG51bGwgJiYgX2luZm8kdHlwZSAhPT0gdm9pZCAwID8gX2luZm8kdHlwZSA6IFwidW5rbm93blwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZvcm1hdEVycm9yKGVycm9yT3B0cykge1xuXHRcdFx0XHRcdHZhciBfY2FsbCRwcm9jZWR1cmUkX2RlZiQzLCBfY2FsbCRwcm9jZWR1cmU0O1xuXHRcdFx0XHRcdGNvbnN0IGNhbGwgPSBpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm8uY2FsbHNbZXJyb3JPcHRzLnBhdGhbMF1dO1xuXHRcdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oZXJyb3JPcHRzLmVycm9yKTtcblx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5yZXN1bHQoKTtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnBhdGg7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IChfY2FsbCRwcm9jZWR1cmUkX2RlZiQzID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgfHwgKF9jYWxsJHByb2NlZHVyZTQgPSBjYWxsLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX2NhbGwkcHJvY2VkdXJlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NhbGwkcHJvY2VkdXJlNC5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9jYWxsJHByb2NlZHVyZSRfZGVmJDMgIT09IHZvaWQgMCA/IF9jYWxsJHByb2NlZHVyZSRfZGVmJDMgOiBcInVua25vd25cIjtcblx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdFx0aW5wdXQsXG5cdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBzaGFwZTtcblx0XHRcdFx0fVxuXHRcdFx0fSkpO1xuXHRcdFx0cmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcblx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXNcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvKipcblx0XHQqIE5vbi1zdHJlYW1pbmcgcmVzcG9uc2U6XG5cdFx0KiAtIGF3YWl0IGFsbCByZXNwb25zZXMgaW4gcGFyYWxsZWwsIGJsb2NraW5nIG9uIHRoZSBzbG93ZXN0IG9uZVxuXHRcdCogLSBjcmVhdGUgaGVhZGVycyB3aXRoIGtub3duIHJlc3BvbnNlIGJvZHlcblx0XHQqIC0gcmV0dXJuIGEgY29tcGxldGUgSFRUUFJlc3BvbnNlXG5cdFx0Ki9cblx0XHRoZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG5cdFx0Y29uc3QgcmVzdWx0cyA9IChhd2FpdCBQcm9taXNlLmFsbChycGNDYWxscykpLm1hcCgocmVzKSA9PiB7XG5cdFx0XHRjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSByZXM7XG5cdFx0XHRpZiAoZXJyb3IpIHJldHVybiByZXM7XG5cdFx0XHRpZiAoaXNEYXRhU3RyZWFtKHJlc3VsdC5kYXRhKSkgcmV0dXJuIFtuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0Y29kZTogXCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFXCIsXG5cdFx0XHRcdG1lc3NhZ2U6IFwiQ2Fubm90IHVzZSBzdHJlYW0tbGlrZSByZXNwb25zZSBpbiBub24tc3RyZWFtaW5nIHJlcXVlc3QgLSB1c2UgaHR0cEJhdGNoU3RyZWFtTGlua1wiXG5cdFx0XHR9KSwgdm9pZCAwXTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSk7XG5cdFx0Y29uc3QgcmVzdWx0QXNSUENSZXNwb25zZSA9IHJlc3VsdHMubWFwKChbZXJyb3IsIHJlc3VsdF0sIGluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBjYWxsID0gaW5mby5jYWxsc1tpbmRleF07XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0dmFyIF9jYWxsJHByb2NlZHVyZSRfZGVmJDQsIF9jYWxsJHByb2NlZHVyZTU7XG5cdFx0XHRcdHJldHVybiB7IGVycm9yOiBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRlcnJvcixcblx0XHRcdFx0XHRpbnB1dDogY2FsbC5yZXN1bHQoKSxcblx0XHRcdFx0XHRwYXRoOiBjYWxsLnBhdGgsXG5cdFx0XHRcdFx0dHlwZTogKF9jYWxsJHByb2NlZHVyZSRfZGVmJDQgPSAoX2NhbGwkcHJvY2VkdXJlNSA9IGNhbGwucHJvY2VkdXJlKSA9PT0gbnVsbCB8fCBfY2FsbCRwcm9jZWR1cmU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbCRwcm9jZWR1cmU1Ll9kZWYudHlwZSkgIT09IG51bGwgJiYgX2NhbGwkcHJvY2VkdXJlJF9kZWYkNCAhPT0gdm9pZCAwID8gX2NhbGwkcHJvY2VkdXJlJF9kZWYkNCA6IFwidW5rbm93blwiXG5cdFx0XHRcdH0pIH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geyByZXN1bHQ6IHsgZGF0YTogcmVzdWx0LmRhdGEgfSB9O1xuXHRcdH0pO1xuXHRcdGNvbnN0IGVycm9ycyA9IHJlc3VsdHMubWFwKChbZXJyb3JdKSA9PiBlcnJvcikuZmlsdGVyKEJvb2xlYW4pO1xuXHRcdGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0aW5mbyxcblx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHR1bnRyYW5zZm9ybWVkSlNPTjogcmVzdWx0QXNSUENSZXNwb25zZSxcblx0XHRcdGVycm9ycyxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybVRSUENSZXNwb25zZShjb25maWcsIHJlc3VsdEFzUlBDUmVzcG9uc2UpKSwge1xuXHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2Uuc3RhdHVzLFxuXHRcdFx0aGVhZGVyc1xuXHRcdH0pO1xuXHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdHZhciBfaW5mbyR0eXBlMjtcblx0XHRjb25zdCBbX2luZm9FcnJvciwgaW5mb10gPSBpbmZvVHVwbGU7XG5cdFx0Y29uc3QgY3R4ID0gY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCk7XG5cdFx0Y29uc3QgeyBlcnJvciwgdW50cmFuc2Zvcm1lZEpTT04sIGJvZHkgfSA9IGNhdWdodEVycm9yVG9EYXRhKGNhdXNlLCB7XG5cdFx0XHRvcHRzLFxuXHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdHR5cGU6IChfaW5mbyR0eXBlMiA9IGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mby50eXBlKSAhPT0gbnVsbCAmJiBfaW5mbyR0eXBlMiAhPT0gdm9pZCAwID8gX2luZm8kdHlwZTIgOiBcInVua25vd25cIlxuXHRcdH0pO1xuXHRcdGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRjdHgsXG5cdFx0XHRpbmZvLFxuXHRcdFx0cmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcblx0XHRcdHVudHJhbnNmb3JtZWRKU09OLFxuXHRcdFx0ZXJyb3JzOiBbZXJyb3JdLFxuXHRcdFx0aGVhZGVyc1xuXHRcdH0pO1xuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuXHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2Uuc3RhdHVzLFxuXHRcdFx0aGVhZGVyc1xuXHRcdH0pO1xuXHR9XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgVW5wcm9taXNlLCBjcmVhdGVEZWZlcnJlZCwgZ2V0UmVxdWVzdEluZm8sIGlzQWJvcnRFcnJvciwgaXNQcm9taXNlLCBpdGVyYXRvclJlc291cmNlLCBqc29ubFN0cmVhbUNvbnN1bWVyLCBqc29ubFN0cmVhbVByb2R1Y2VyLCBtYWtlQXN5bmNSZXNvdXJjZSwgbWFrZVJlc291cmNlLCBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tU3RyaW5nLCBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93biwgcmVxdWlyZV91c2luZ0N0eCwgcmVzb2x2ZVJlc3BvbnNlLCBzc2VIZWFkZXJzLCBzc2VTdHJlYW1Db25zdW1lciwgc3NlU3RyZWFtUHJvZHVjZXIsIHRha2VXaXRoR3JhY2UsIHRocm93QWJvcnRFcnJvciwgd2l0aE1heER1cmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlUmVzcG9uc2UtSGdhMXhPTzEubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/resolveResponse-Hga1xOO1.mjs\n',
      );

      /***/
    },

  /***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/tracked-Bp72jHif.mjs":
    /*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/tracked-Bp72jHif.mjs ***!
  \*********************************************************************************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPCError: () => (/* binding */ TRPCError),\n/* harmony export */   callProcedure: () => (/* binding */ callProcedure),\n/* harmony export */   createCallerFactory: () => (/* binding */ createCallerFactory),\n/* harmony export */   createRouterFactory: () => (/* binding */ createRouterFactory),\n/* harmony export */   defaultFormatter: () => (/* binding */ defaultFormatter),\n/* harmony export */   defaultTransformer: () => (/* binding */ defaultTransformer),\n/* harmony export */   getCauseFromUnknown: () => (/* binding */ getCauseFromUnknown),\n/* harmony export */   getDataTransformer: () => (/* binding */ getDataTransformer),\n/* harmony export */   getProcedureAtPath: () => (/* binding */ getProcedureAtPath),\n/* harmony export */   getTRPCErrorFromUnknown: () => (/* binding */ getTRPCErrorFromUnknown),\n/* harmony export */   isTrackedEnvelope: () => (/* binding */ isTrackedEnvelope),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   mergeRouters: () => (/* binding */ mergeRouters),\n/* harmony export */   sse: () => (/* binding */ sse),\n/* harmony export */   tracked: () => (/* binding */ tracked),\n/* harmony export */   transformResult: () => (/* binding */ transformResult),\n/* harmony export */   transformTRPCResponse: () => (/* binding */ transformTRPCResponse)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getErrorShape-Uhlrl4Bk.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs");\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs");\n\n\n\n//#region src/unstable-core-do-not-import/error/formatter.ts\nconst defaultFormatter = ({ shape }) => {\n\treturn shape;\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/error/TRPCError.ts\nvar import_defineProperty = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_defineProperty)(), 1);\nvar UnknownCauseError = class extends Error {};\nfunction getCauseFromUnknown(cause) {\n\tif (cause instanceof Error) return cause;\n\tconst type = typeof cause;\n\tif (type === "undefined" || type === "function" || cause === null) return void 0;\n\tif (type !== "object") return new Error(String(cause));\n\tif ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(cause)) return Object.assign(new UnknownCauseError(), cause);\n\treturn void 0;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n\tif (cause instanceof TRPCError) return cause;\n\tif (cause instanceof Error && cause.name === "TRPCError") return cause;\n\tconst trpcError = new TRPCError({\n\t\tcode: "INTERNAL_SERVER_ERROR",\n\t\tcause\n\t});\n\tif (cause instanceof Error && cause.stack) trpcError.stack = cause.stack;\n\treturn trpcError;\n}\nvar TRPCError = class extends Error {\n\tconstructor(opts) {\n\t\tvar _ref, _opts$message, _this$cause;\n\t\tconst cause = getCauseFromUnknown(opts.cause);\n\t\tconst message = (_ref = (_opts$message = opts.message) !== null && _opts$message !== void 0 ? _opts$message : cause === null || cause === void 0 ? void 0 : cause.message) !== null && _ref !== void 0 ? _ref : opts.code;\n\t\tsuper(message, { cause });\n\t\t(0, import_defineProperty.default)(this, "cause", void 0);\n\t\t(0, import_defineProperty.default)(this, "code", void 0);\n\t\tthis.code = opts.code;\n\t\tthis.name = "TRPCError";\n\t\t(_this$cause = this.cause) !== null && _this$cause !== void 0 || (this.cause = cause);\n\t}\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/transformer.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\n/**\n* @internal\n*/\nfunction getDataTransformer(transformer) {\n\tif ("input" in transformer) return transformer;\n\treturn {\n\t\tinput: transformer,\n\t\toutput: transformer\n\t};\n}\n/**\n* @internal\n*/\nconst defaultTransformer = {\n\tinput: {\n\t\tserialize: (obj) => obj,\n\t\tdeserialize: (obj) => obj\n\t},\n\toutput: {\n\t\tserialize: (obj) => obj,\n\t\tdeserialize: (obj) => obj\n\t}\n};\nfunction transformTRPCResponseItem(config, item) {\n\tif ("error" in item) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, { error: config.transformer.output.serialize(item.error) });\n\tif ("data" in item.result) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, { result: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item.result), {}, { data: config.transformer.output.serialize(item.result.data) }) });\n\treturn item;\n}\n/**\n* Takes a unserialized `TRPCResponse` and serializes it with the router\'s transformers\n**/\nfunction transformTRPCResponse(config, itemOrItems) {\n\treturn Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n/** @internal */\nfunction transformResultInner(response, transformer) {\n\tif ("error" in response) {\n\t\tconst error = transformer.deserialize(response.error);\n\t\treturn {\n\t\t\tok: false,\n\t\t\terror: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response), {}, { error })\n\t\t};\n\t}\n\tconst result = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response.result), (!response.result.type || response.result.type === "data") && {\n\t\ttype: "data",\n\t\tdata: transformer.deserialize(response.result.data)\n\t});\n\treturn {\n\t\tok: true,\n\t\tresult\n\t};\n}\nvar TransformResultError = class extends Error {\n\tconstructor() {\n\t\tsuper("Unable to transform response from server");\n\t}\n};\n/**\n* Transforms and validates that the result is a valid TRPCResponse\n* @internal\n*/\nfunction transformResult(response, transformer) {\n\tlet result;\n\ttry {\n\t\tresult = transformResultInner(response, transformer);\n\t} catch (_unused) {\n\t\tthrow new TransformResultError();\n\t}\n\tif (!result.ok && (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.error.error) || typeof result.error.error["code"] !== "number")) throw new TransformResultError();\n\tif (result.ok && !(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.result)) throw new TransformResultError();\n\treturn result;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/router.ts\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\n/**\n* @internal\n*/\nconst lazyMarker = "lazyMarker";\nfunction once(fn) {\n\tconst uncalled = Symbol();\n\tlet result = uncalled;\n\treturn () => {\n\t\tif (result === uncalled) result = fn();\n\t\treturn result;\n\t};\n}\n/**\n* Lazy load a router\n* @see https://trpc.io/docs/server/merging-routers#lazy-load\n*/\nfunction lazy(importRouter) {\n\tasync function resolve() {\n\t\tconst mod = await importRouter();\n\t\tif (isRouter(mod)) return mod;\n\t\tconst routers = Object.values(mod);\n\t\tif (routers.length !== 1 || !isRouter(routers[0])) throw new Error("Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import(\'./slow.js\').then((m) => m.slowRouter))`");\n\t\treturn routers[0];\n\t}\n\tresolve[lazyMarker] = true;\n\treturn resolve;\n}\nfunction isLazy(input) {\n\treturn typeof input === "function" && lazyMarker in input;\n}\nfunction isRouter(value) {\n\treturn (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) && (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value["_def"]) && "router" in value["_def"];\n}\nconst emptyRouter = {\n\t_ctx: null,\n\t_errorShape: null,\n\t_meta: null,\n\tqueries: {},\n\tmutations: {},\n\tsubscriptions: {},\n\terrorFormatter: defaultFormatter,\n\ttransformer: defaultTransformer\n};\n/**\n* Reserved words that can\'t be used as router or procedure names\n*/\nconst reservedWords = [\n\t"then",\n\t"call",\n\t"apply"\n];\n/**\n* @internal\n*/\nfunction createRouterFactory(config) {\n\tfunction createRouterInner(input) {\n\t\tconst reservedWordsUsed = new Set(Object.keys(input).filter((v) => reservedWords.includes(v)));\n\t\tif (reservedWordsUsed.size > 0) throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));\n\t\tconst procedures = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n\t\tconst lazy$1 = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n\t\tfunction createLazyLoader(opts) {\n\t\t\treturn {\n\t\t\t\tref: opts.ref,\n\t\t\t\tload: once(async () => {\n\t\t\t\t\tconst router$1 = await opts.ref();\n\t\t\t\t\tconst lazyPath = [...opts.path, opts.key];\n\t\t\t\t\tconst lazyKey = lazyPath.join(".");\n\t\t\t\t\topts.aggregate[opts.key] = step(router$1._def.record, lazyPath);\n\t\t\t\t\tdelete lazy$1[lazyKey];\n\t\t\t\t\tfor (const [nestedKey, nestedItem] of Object.entries(router$1._def.lazy)) {\n\t\t\t\t\t\tconst nestedRouterKey = [...lazyPath, nestedKey].join(".");\n\t\t\t\t\t\tlazy$1[nestedRouterKey] = createLazyLoader({\n\t\t\t\t\t\t\tref: nestedItem.ref,\n\t\t\t\t\t\t\tpath: lazyPath,\n\t\t\t\t\t\t\tkey: nestedKey,\n\t\t\t\t\t\t\taggregate: opts.aggregate[opts.key]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t};\n\t\t}\n\t\tfunction step(from, path = []) {\n\t\t\tconst aggregate = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n\t\t\tfor (const [key, item] of Object.entries(from !== null && from !== void 0 ? from : {})) {\n\t\t\t\tif (isLazy(item)) {\n\t\t\t\t\tlazy$1[[...path, key].join(".")] = createLazyLoader({\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tref: item,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\taggregate\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isRouter(item)) {\n\t\t\t\t\taggregate[key] = step(item._def.record, [...path, key]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!isProcedure(item)) {\n\t\t\t\t\taggregate[key] = step(item, [...path, key]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newPath = [...path, key].join(".");\n\t\t\t\tif (procedures[newPath]) throw new Error(`Duplicate key: ${newPath}`);\n\t\t\t\tprocedures[newPath] = item;\n\t\t\t\taggregate[key] = item;\n\t\t\t}\n\t\t\treturn aggregate;\n\t\t}\n\t\tconst record = step(input);\n\t\tconst _def = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({\n\t\t\t_config: config,\n\t\t\trouter: true,\n\t\t\tprocedures,\n\t\t\tlazy: lazy$1\n\t\t}, emptyRouter), {}, { record });\n\t\tconst router = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, record), {}, {\n\t\t\t_def,\n\t\t\tcreateCaller: createCallerFactory()({ _def })\n\t\t});\n\t\treturn router;\n\t}\n\treturn createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n\treturn typeof procedureOrRouter === "function";\n}\n/**\n* @internal\n*/\nasync function getProcedureAtPath(router, path) {\n\tconst { _def } = router;\n\tlet procedure = _def.procedures[path];\n\twhile (!procedure) {\n\t\tconst key = Object.keys(_def.lazy).find((key$1) => path.startsWith(key$1));\n\t\tif (!key) return null;\n\t\tconst lazyRouter = _def.lazy[key];\n\t\tawait lazyRouter.load();\n\t\tprocedure = _def.procedures[path];\n\t}\n\treturn procedure;\n}\n/**\n* @internal\n*/\nasync function callProcedure(opts) {\n\tconst { type, path } = opts;\n\tconst proc = await getProcedureAtPath(opts.router, path);\n\tif (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) throw new TRPCError({\n\t\tcode: "NOT_FOUND",\n\t\tmessage: `No "${type}"-procedure on path "${path}"`\n\t});\n\t/* istanbul ignore if -- @preserve */\n\tif (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === "subscription") throw new TRPCError({\n\t\tcode: "METHOD_NOT_SUPPORTED",\n\t\tmessage: `Method override is not supported for subscriptions`\n\t});\n\treturn proc(opts);\n}\nfunction createCallerFactory() {\n\treturn function createCallerInner(router) {\n\t\tconst { _def } = router;\n\t\treturn function createCaller(ctxOrCallback, opts) {\n\t\t\treturn (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.createRecursiveProxy)(async ({ path, args }) => {\n\t\t\t\tconst fullPath = path.join(".");\n\t\t\t\tif (path.length === 1 && path[0] === "_def") return _def;\n\t\t\t\tconst procedure = await getProcedureAtPath(router, fullPath);\n\t\t\t\tlet ctx = void 0;\n\t\t\t\ttry {\n\t\t\t\t\tif (!procedure) throw new TRPCError({\n\t\t\t\t\t\tcode: "NOT_FOUND",\n\t\t\t\t\t\tmessage: `No procedure found on path "${path}"`\n\t\t\t\t\t});\n\t\t\t\t\tctx = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n\t\t\t\t\treturn await procedure({\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\tgetRawInput: async () => args[0],\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\ttype: procedure._def.type,\n\t\t\t\t\t\tsignal: opts === null || opts === void 0 ? void 0 : opts.signal\n\t\t\t\t\t});\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tvar _opts$onError, _procedure$_def$type;\n\t\t\t\t\topts === null || opts === void 0 || (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\terror: getTRPCErrorFromUnknown(cause),\n\t\t\t\t\t\tinput: args[0],\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\ttype: (_procedure$_def$type = procedure === null || procedure === void 0 ? void 0 : procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : "unknown"\n\t\t\t\t\t});\n\t\t\t\t\tthrow cause;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n}\nfunction mergeRouters(...routerList) {\n\tvar _routerList$;\n\tconst record = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.mergeWithoutOverrides)({}, ...routerList.map((r) => r._def.record));\n\tconst errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {\n\t\tif (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n\t\t\tif (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) throw new Error("You seem to have several error formatters");\n\t\t\treturn nextRouter._def._config.errorFormatter;\n\t\t}\n\t\treturn currentErrorFormatter;\n\t}, defaultFormatter);\n\tconst transformer = routerList.reduce((prev, current) => {\n\t\tif (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n\t\t\tif (prev !== defaultTransformer && prev !== current._def._config.transformer) throw new Error("You seem to have several transformers");\n\t\t\treturn current._def._config.transformer;\n\t\t}\n\t\treturn prev;\n\t}, defaultTransformer);\n\tconst router = createRouterFactory({\n\t\terrorFormatter,\n\t\ttransformer,\n\t\tisDev: routerList.every((r) => r._def._config.isDev),\n\t\tallowOutsideOfServer: routerList.every((r) => r._def._config.allowOutsideOfServer),\n\t\tisServer: routerList.every((r) => r._def._config.isServer),\n\t\t$types: (_routerList$ = routerList[0]) === null || _routerList$ === void 0 ? void 0 : _routerList$._def._config.$types\n\t})(record);\n\treturn router;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/tracked.ts\nconst trackedSymbol = Symbol();\n/**\n* Produce a typed server-sent event message\n* @deprecated use `tracked(id, data)` instead\n*/\nfunction sse(event) {\n\treturn tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n\treturn Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n* Automatically track an event so that it can be resumed from a given id if the connection is lost\n*/\nfunction tracked(id, data) {\n\tif (id === "") throw new Error("`id` must not be an empty string as empty string is the same as not setting the id at all");\n\treturn [\n\t\tid,\n\t\tdata,\n\t\ttrackedSymbol\n\t];\n}\n\n//#endregion\n\n//# sourceMappingURL=tracked-Bp72jHif.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC90cmFja2VkLUJwNzJqSGlmLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRIO0FBQzFCOztBQUVsRztBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixvRUFBTyxDQUFDLG1GQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZEQUFRO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixvRUFBTyxDQUFDLGtGQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxXQUFXLElBQUksd0RBQXdEO0FBQzlLLDZHQUE2RyxXQUFXLElBQUksa0ZBQWtGLGtCQUFrQixJQUFJLDZEQUE2RCxHQUFHO0FBQ3BTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsZUFBZSxJQUFJLE9BQU87QUFDOUc7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLDZEQUFRO0FBQzdCLG1CQUFtQiw2REFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQU8sQ0FBQyxrRkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFRLFdBQVcsNkRBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEYscUJBQXFCLGtFQUFhLEdBQUc7QUFDckMsaUJBQWlCLGtFQUFhLEdBQUc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFhLEdBQUc7QUFDckMsd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0JBQWtCLElBQUksUUFBUTtBQUNqQyx1RkFBdUYsYUFBYTtBQUNwRztBQUNBLHlDQUF5QyxNQUFNO0FBQy9DLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssdUJBQXVCLEtBQUs7QUFDbkQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsVUFBVSxpRkFBb0IsVUFBVSxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsTUFBTTtBQUNOLFdBQVcsK0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEVBQXFCLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1UztBQUN2UyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzZWdndVxcTEVTaUFCXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAdHJwYytzZXJ2ZXJAMTEuNS4wX3R5cGVzY3JpcHRANS45LjJcXG5vZGVfbW9kdWxlc1xcQHRycGNcXHNlcnZlclxcZGlzdFxcdHJhY2tlZC1CcDcyakhpZi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX190b0VTTSwgY3JlYXRlUmVjdXJzaXZlUHJveHksIHJlcXVpcmVfZGVmaW5lUHJvcGVydHksIHJlcXVpcmVfb2JqZWN0U3ByZWFkMiB9IGZyb20gXCIuL2dldEVycm9yU2hhcGUtVWhscmw0QmsubWpzXCI7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCwgbWVyZ2VXaXRob3V0T3ZlcnJpZGVzLCBvbWl0UHJvdG90eXBlIH0gZnJvbSBcIi4vdXRpbHMtRGRiYnJEa3UubWpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL2Zvcm1hdHRlci50c1xuY29uc3QgZGVmYXVsdEZvcm1hdHRlciA9ICh7IHNoYXBlIH0pID0+IHtcblx0cmV0dXJuIHNoYXBlO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9lcnJvci9UUlBDRXJyb3IudHNcbnZhciBpbXBvcnRfZGVmaW5lUHJvcGVydHkgPSBfX3RvRVNNKHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSwgMSk7XG52YXIgVW5rbm93bkNhdXNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHt9O1xuZnVuY3Rpb24gZ2V0Q2F1c2VGcm9tVW5rbm93bihjYXVzZSkge1xuXHRpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIGNhdXNlO1xuXHRjb25zdCB0eXBlID0gdHlwZW9mIGNhdXNlO1xuXHRpZiAodHlwZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgY2F1c2UgPT09IG51bGwpIHJldHVybiB2b2lkIDA7XG5cdGlmICh0eXBlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhjYXVzZSkpO1xuXHRpZiAoaXNPYmplY3QoY2F1c2UpKSByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgVW5rbm93bkNhdXNlRXJyb3IoKSwgY2F1c2UpO1xuXHRyZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpIHtcblx0aWYgKGNhdXNlIGluc3RhbmNlb2YgVFJQQ0Vycm9yKSByZXR1cm4gY2F1c2U7XG5cdGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGNhdXNlLm5hbWUgPT09IFwiVFJQQ0Vycm9yXCIpIHJldHVybiBjYXVzZTtcblx0Y29uc3QgdHJwY0Vycm9yID0gbmV3IFRSUENFcnJvcih7XG5cdFx0Y29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcblx0XHRjYXVzZVxuXHR9KTtcblx0aWYgKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgJiYgY2F1c2Uuc3RhY2spIHRycGNFcnJvci5zdGFjayA9IGNhdXNlLnN0YWNrO1xuXHRyZXR1cm4gdHJwY0Vycm9yO1xufVxudmFyIFRSUENFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihvcHRzKSB7XG5cdFx0dmFyIF9yZWYsIF9vcHRzJG1lc3NhZ2UsIF90aGlzJGNhdXNlO1xuXHRcdGNvbnN0IGNhdXNlID0gZ2V0Q2F1c2VGcm9tVW5rbm93bihvcHRzLmNhdXNlKTtcblx0XHRjb25zdCBtZXNzYWdlID0gKF9yZWYgPSAoX29wdHMkbWVzc2FnZSA9IG9wdHMubWVzc2FnZSkgIT09IG51bGwgJiYgX29wdHMkbWVzc2FnZSAhPT0gdm9pZCAwID8gX29wdHMkbWVzc2FnZSA6IGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogb3B0cy5jb2RlO1xuXHRcdHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG5cdFx0KDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eS5kZWZhdWx0KSh0aGlzLCBcImNhdXNlXCIsIHZvaWQgMCk7XG5cdFx0KDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eS5kZWZhdWx0KSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcblx0XHR0aGlzLmNvZGUgPSBvcHRzLmNvZGU7XG5cdFx0dGhpcy5uYW1lID0gXCJUUlBDRXJyb3JcIjtcblx0XHQoX3RoaXMkY2F1c2UgPSB0aGlzLmNhdXNlKSAhPT0gbnVsbCAmJiBfdGhpcyRjYXVzZSAhPT0gdm9pZCAwIHx8ICh0aGlzLmNhdXNlID0gY2F1c2UpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3RyYW5zZm9ybWVyLnRzXG52YXIgaW1wb3J0X29iamVjdFNwcmVhZDIkMSA9IF9fdG9FU00ocmVxdWlyZV9vYmplY3RTcHJlYWQyKCksIDEpO1xuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGdldERhdGFUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcikge1xuXHRpZiAoXCJpbnB1dFwiIGluIHRyYW5zZm9ybWVyKSByZXR1cm4gdHJhbnNmb3JtZXI7XG5cdHJldHVybiB7XG5cdFx0aW5wdXQ6IHRyYW5zZm9ybWVyLFxuXHRcdG91dHB1dDogdHJhbnNmb3JtZXJcblx0fTtcbn1cbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBkZWZhdWx0VHJhbnNmb3JtZXIgPSB7XG5cdGlucHV0OiB7XG5cdFx0c2VyaWFsaXplOiAob2JqKSA9PiBvYmosXG5cdFx0ZGVzZXJpYWxpemU6IChvYmopID0+IG9ialxuXHR9LFxuXHRvdXRwdXQ6IHtcblx0XHRzZXJpYWxpemU6IChvYmopID0+IG9iaixcblx0XHRkZXNlcmlhbGl6ZTogKG9iaikgPT4gb2JqXG5cdH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkge1xuXHRpZiAoXCJlcnJvclwiIGluIGl0ZW0pIHJldHVybiAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSh7fSwgaXRlbSksIHt9LCB7IGVycm9yOiBjb25maWcudHJhbnNmb3JtZXIub3V0cHV0LnNlcmlhbGl6ZShpdGVtLmVycm9yKSB9KTtcblx0aWYgKFwiZGF0YVwiIGluIGl0ZW0ucmVzdWx0KSByZXR1cm4gKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoe30sIGl0ZW0pLCB7fSwgeyByZXN1bHQ6ICgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKHt9LCBpdGVtLnJlc3VsdCksIHt9LCB7IGRhdGE6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKGl0ZW0ucmVzdWx0LmRhdGEpIH0pIH0pO1xuXHRyZXR1cm4gaXRlbTtcbn1cbi8qKlxuKiBUYWtlcyBhIHVuc2VyaWFsaXplZCBgVFJQQ1Jlc3BvbnNlYCBhbmQgc2VyaWFsaXplcyBpdCB3aXRoIHRoZSByb3V0ZXIncyB0cmFuc2Zvcm1lcnNcbioqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKGNvbmZpZywgaXRlbU9ySXRlbXMpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbU9ySXRlbXMpID8gaXRlbU9ySXRlbXMubWFwKChpdGVtKSA9PiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkpIDogdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbShjb25maWcsIGl0ZW1Pckl0ZW1zKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcikge1xuXHRpZiAoXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSB0cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZShyZXNwb25zZS5lcnJvcik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG9rOiBmYWxzZSxcblx0XHRcdGVycm9yOiAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSh7fSwgcmVzcG9uc2UpLCB7fSwgeyBlcnJvciB9KVxuXHRcdH07XG5cdH1cblx0Y29uc3QgcmVzdWx0ID0gKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoe30sIHJlc3BvbnNlLnJlc3VsdCksICghcmVzcG9uc2UucmVzdWx0LnR5cGUgfHwgcmVzcG9uc2UucmVzdWx0LnR5cGUgPT09IFwiZGF0YVwiKSAmJiB7XG5cdFx0dHlwZTogXCJkYXRhXCIsXG5cdFx0ZGF0YTogdHJhbnNmb3JtZXIuZGVzZXJpYWxpemUocmVzcG9uc2UucmVzdWx0LmRhdGEpXG5cdH0pO1xuXHRyZXR1cm4ge1xuXHRcdG9rOiB0cnVlLFxuXHRcdHJlc3VsdFxuXHR9O1xufVxudmFyIFRyYW5zZm9ybVJlc3VsdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKFwiVW5hYmxlIHRvIHRyYW5zZm9ybSByZXNwb25zZSBmcm9tIHNlcnZlclwiKTtcblx0fVxufTtcbi8qKlxuKiBUcmFuc2Zvcm1zIGFuZCB2YWxpZGF0ZXMgdGhhdCB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgVFJQQ1Jlc3BvbnNlXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdChyZXNwb25zZSwgdHJhbnNmb3JtZXIpIHtcblx0bGV0IHJlc3VsdDtcblx0dHJ5IHtcblx0XHRyZXN1bHQgPSB0cmFuc2Zvcm1SZXN1bHRJbm5lcihyZXNwb25zZSwgdHJhbnNmb3JtZXIpO1xuXHR9IGNhdGNoIChfdW51c2VkKSB7XG5cdFx0dGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG5cdH1cblx0aWYgKCFyZXN1bHQub2sgJiYgKCFpc09iamVjdChyZXN1bHQuZXJyb3IuZXJyb3IpIHx8IHR5cGVvZiByZXN1bHQuZXJyb3IuZXJyb3JbXCJjb2RlXCJdICE9PSBcIm51bWJlclwiKSkgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG5cdGlmIChyZXN1bHQub2sgJiYgIWlzT2JqZWN0KHJlc3VsdC5yZXN1bHQpKSB0aHJvdyBuZXcgVHJhbnNmb3JtUmVzdWx0RXJyb3IoKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9yb3V0ZXIudHNcbnZhciBpbXBvcnRfb2JqZWN0U3ByZWFkMiA9IF9fdG9FU00ocmVxdWlyZV9vYmplY3RTcHJlYWQyKCksIDEpO1xuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmNvbnN0IGxhenlNYXJrZXIgPSBcImxhenlNYXJrZXJcIjtcbmZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0Y29uc3QgdW5jYWxsZWQgPSBTeW1ib2woKTtcblx0bGV0IHJlc3VsdCA9IHVuY2FsbGVkO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChyZXN1bHQgPT09IHVuY2FsbGVkKSByZXN1bHQgPSBmbigpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG4vKipcbiogTGF6eSBsb2FkIGEgcm91dGVyXG4qIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3Mvc2VydmVyL21lcmdpbmctcm91dGVycyNsYXp5LWxvYWRcbiovXG5mdW5jdGlvbiBsYXp5KGltcG9ydFJvdXRlcikge1xuXHRhc3luYyBmdW5jdGlvbiByZXNvbHZlKCkge1xuXHRcdGNvbnN0IG1vZCA9IGF3YWl0IGltcG9ydFJvdXRlcigpO1xuXHRcdGlmIChpc1JvdXRlcihtb2QpKSByZXR1cm4gbW9kO1xuXHRcdGNvbnN0IHJvdXRlcnMgPSBPYmplY3QudmFsdWVzKG1vZCk7XG5cdFx0aWYgKHJvdXRlcnMubGVuZ3RoICE9PSAxIHx8ICFpc1JvdXRlcihyb3V0ZXJzWzBdKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3V0ZXIgbW9kdWxlIC0gZWl0aGVyIGRlZmluZSBleGFjdGx5IDEgZXhwb3J0IG9yIHJldHVybiB0aGUgcm91dGVyIGRpcmVjdGx5LlxcbkV4YW1wbGU6IGBsYXp5KCgpID0+IGltcG9ydCgnLi9zbG93LmpzJykudGhlbigobSkgPT4gbS5zbG93Um91dGVyKSlgXCIpO1xuXHRcdHJldHVybiByb3V0ZXJzWzBdO1xuXHR9XG5cdHJlc29sdmVbbGF6eU1hcmtlcl0gPSB0cnVlO1xuXHRyZXR1cm4gcmVzb2x2ZTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShpbnB1dCkge1xuXHRyZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcImZ1bmN0aW9uXCIgJiYgbGF6eU1hcmtlciBpbiBpbnB1dDtcbn1cbmZ1bmN0aW9uIGlzUm91dGVyKHZhbHVlKSB7XG5cdHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWVbXCJfZGVmXCJdKSAmJiBcInJvdXRlclwiIGluIHZhbHVlW1wiX2RlZlwiXTtcbn1cbmNvbnN0IGVtcHR5Um91dGVyID0ge1xuXHRfY3R4OiBudWxsLFxuXHRfZXJyb3JTaGFwZTogbnVsbCxcblx0X21ldGE6IG51bGwsXG5cdHF1ZXJpZXM6IHt9LFxuXHRtdXRhdGlvbnM6IHt9LFxuXHRzdWJzY3JpcHRpb25zOiB7fSxcblx0ZXJyb3JGb3JtYXR0ZXI6IGRlZmF1bHRGb3JtYXR0ZXIsXG5cdHRyYW5zZm9ybWVyOiBkZWZhdWx0VHJhbnNmb3JtZXJcbn07XG4vKipcbiogUmVzZXJ2ZWQgd29yZHMgdGhhdCBjYW4ndCBiZSB1c2VkIGFzIHJvdXRlciBvciBwcm9jZWR1cmUgbmFtZXNcbiovXG5jb25zdCByZXNlcnZlZFdvcmRzID0gW1xuXHRcInRoZW5cIixcblx0XCJjYWxsXCIsXG5cdFwiYXBwbHlcIlxuXTtcbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJGYWN0b3J5KGNvbmZpZykge1xuXHRmdW5jdGlvbiBjcmVhdGVSb3V0ZXJJbm5lcihpbnB1dCkge1xuXHRcdGNvbnN0IHJlc2VydmVkV29yZHNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhpbnB1dCkuZmlsdGVyKCh2KSA9PiByZXNlcnZlZFdvcmRzLmluY2x1ZGVzKHYpKSk7XG5cdFx0aWYgKHJlc2VydmVkV29yZHNVc2VkLnNpemUgPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNlcnZlZCB3b3JkcyB1c2VkIGluIGByb3V0ZXIoe30pYCBjYWxsOiBcIiArIEFycmF5LmZyb20ocmVzZXJ2ZWRXb3Jkc1VzZWQpLmpvaW4oXCIsIFwiKSk7XG5cdFx0Y29uc3QgcHJvY2VkdXJlcyA9IG9taXRQcm90b3R5cGUoe30pO1xuXHRcdGNvbnN0IGxhenkkMSA9IG9taXRQcm90b3R5cGUoe30pO1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUxhenlMb2FkZXIob3B0cykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cmVmOiBvcHRzLnJlZixcblx0XHRcdFx0bG9hZDogb25jZShhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgcm91dGVyJDEgPSBhd2FpdCBvcHRzLnJlZigpO1xuXHRcdFx0XHRcdGNvbnN0IGxhenlQYXRoID0gWy4uLm9wdHMucGF0aCwgb3B0cy5rZXldO1xuXHRcdFx0XHRcdGNvbnN0IGxhenlLZXkgPSBsYXp5UGF0aC5qb2luKFwiLlwiKTtcblx0XHRcdFx0XHRvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV0gPSBzdGVwKHJvdXRlciQxLl9kZWYucmVjb3JkLCBsYXp5UGF0aCk7XG5cdFx0XHRcdFx0ZGVsZXRlIGxhenkkMVtsYXp5S2V5XTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtuZXN0ZWRLZXksIG5lc3RlZEl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKHJvdXRlciQxLl9kZWYubGF6eSkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZFJvdXRlcktleSA9IFsuLi5sYXp5UGF0aCwgbmVzdGVkS2V5XS5qb2luKFwiLlwiKTtcblx0XHRcdFx0XHRcdGxhenkkMVtuZXN0ZWRSb3V0ZXJLZXldID0gY3JlYXRlTGF6eUxvYWRlcih7XG5cdFx0XHRcdFx0XHRcdHJlZjogbmVzdGVkSXRlbS5yZWYsXG5cdFx0XHRcdFx0XHRcdHBhdGg6IGxhenlQYXRoLFxuXHRcdFx0XHRcdFx0XHRrZXk6IG5lc3RlZEtleSxcblx0XHRcdFx0XHRcdFx0YWdncmVnYXRlOiBvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHN0ZXAoZnJvbSwgcGF0aCA9IFtdKSB7XG5cdFx0XHRjb25zdCBhZ2dyZWdhdGUgPSBvbWl0UHJvdG90eXBlKHt9KTtcblx0XHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXMoZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDoge30pKSB7XG5cdFx0XHRcdGlmIChpc0xhenkoaXRlbSkpIHtcblx0XHRcdFx0XHRsYXp5JDFbWy4uLnBhdGgsIGtleV0uam9pbihcIi5cIildID0gY3JlYXRlTGF6eUxvYWRlcih7XG5cdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0cmVmOiBpdGVtLFxuXHRcdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdFx0YWdncmVnYXRlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzUm91dGVyKGl0ZW0pKSB7XG5cdFx0XHRcdFx0YWdncmVnYXRlW2tleV0gPSBzdGVwKGl0ZW0uX2RlZi5yZWNvcmQsIFsuLi5wYXRoLCBrZXldKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWlzUHJvY2VkdXJlKGl0ZW0pKSB7XG5cdFx0XHRcdFx0YWdncmVnYXRlW2tleV0gPSBzdGVwKGl0ZW0sIFsuLi5wYXRoLCBrZXldKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBuZXdQYXRoID0gWy4uLnBhdGgsIGtleV0uam9pbihcIi5cIik7XG5cdFx0XHRcdGlmIChwcm9jZWR1cmVzW25ld1BhdGhdKSB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBrZXk6ICR7bmV3UGF0aH1gKTtcblx0XHRcdFx0cHJvY2VkdXJlc1tuZXdQYXRoXSA9IGl0ZW07XG5cdFx0XHRcdGFnZ3JlZ2F0ZVtrZXldID0gaXRlbTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhZ2dyZWdhdGU7XG5cdFx0fVxuXHRcdGNvbnN0IHJlY29yZCA9IHN0ZXAoaW5wdXQpO1xuXHRcdGNvbnN0IF9kZWYgPSAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKHtcblx0XHRcdF9jb25maWc6IGNvbmZpZyxcblx0XHRcdHJvdXRlcjogdHJ1ZSxcblx0XHRcdHByb2NlZHVyZXMsXG5cdFx0XHRsYXp5OiBsYXp5JDFcblx0XHR9LCBlbXB0eVJvdXRlciksIHt9LCB7IHJlY29yZCB9KTtcblx0XHRjb25zdCByb3V0ZXIgPSAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKHt9LCByZWNvcmQpLCB7fSwge1xuXHRcdFx0X2RlZixcblx0XHRcdGNyZWF0ZUNhbGxlcjogY3JlYXRlQ2FsbGVyRmFjdG9yeSgpKHsgX2RlZiB9KVxuXHRcdH0pO1xuXHRcdHJldHVybiByb3V0ZXI7XG5cdH1cblx0cmV0dXJuIGNyZWF0ZVJvdXRlcklubmVyO1xufVxuZnVuY3Rpb24gaXNQcm9jZWR1cmUocHJvY2VkdXJlT3JSb3V0ZXIpIHtcblx0cmV0dXJuIHR5cGVvZiBwcm9jZWR1cmVPclJvdXRlciA9PT0gXCJmdW5jdGlvblwiO1xufVxuLyoqXG4qIEBpbnRlcm5hbFxuKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFByb2NlZHVyZUF0UGF0aChyb3V0ZXIsIHBhdGgpIHtcblx0Y29uc3QgeyBfZGVmIH0gPSByb3V0ZXI7XG5cdGxldCBwcm9jZWR1cmUgPSBfZGVmLnByb2NlZHVyZXNbcGF0aF07XG5cdHdoaWxlICghcHJvY2VkdXJlKSB7XG5cdFx0Y29uc3Qga2V5ID0gT2JqZWN0LmtleXMoX2RlZi5sYXp5KS5maW5kKChrZXkkMSkgPT4gcGF0aC5zdGFydHNXaXRoKGtleSQxKSk7XG5cdFx0aWYgKCFrZXkpIHJldHVybiBudWxsO1xuXHRcdGNvbnN0IGxhenlSb3V0ZXIgPSBfZGVmLmxhenlba2V5XTtcblx0XHRhd2FpdCBsYXp5Um91dGVyLmxvYWQoKTtcblx0XHRwcm9jZWR1cmUgPSBfZGVmLnByb2NlZHVyZXNbcGF0aF07XG5cdH1cblx0cmV0dXJuIHByb2NlZHVyZTtcbn1cbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5hc3luYyBmdW5jdGlvbiBjYWxsUHJvY2VkdXJlKG9wdHMpIHtcblx0Y29uc3QgeyB0eXBlLCBwYXRoIH0gPSBvcHRzO1xuXHRjb25zdCBwcm9jID0gYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKG9wdHMucm91dGVyLCBwYXRoKTtcblx0aWYgKCFwcm9jIHx8ICFpc1Byb2NlZHVyZShwcm9jKSB8fCBwcm9jLl9kZWYudHlwZSAhPT0gdHlwZSAmJiAhb3B0cy5hbGxvd01ldGhvZE92ZXJyaWRlKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRjb2RlOiBcIk5PVF9GT1VORFwiLFxuXHRcdG1lc3NhZ2U6IGBObyBcIiR7dHlwZX1cIi1wcm9jZWR1cmUgb24gcGF0aCBcIiR7cGF0aH1cImBcblx0fSk7XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0aWYgKHByb2MuX2RlZi50eXBlICE9PSB0eXBlICYmIG9wdHMuYWxsb3dNZXRob2RPdmVycmlkZSAmJiBwcm9jLl9kZWYudHlwZSA9PT0gXCJzdWJzY3JpcHRpb25cIikgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdG1lc3NhZ2U6IGBNZXRob2Qgb3ZlcnJpZGUgaXMgbm90IHN1cHBvcnRlZCBmb3Igc3Vic2NyaXB0aW9uc2Bcblx0fSk7XG5cdHJldHVybiBwcm9jKG9wdHMpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGVyRmFjdG9yeSgpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNhbGxlcklubmVyKHJvdXRlcikge1xuXHRcdGNvbnN0IHsgX2RlZiB9ID0gcm91dGVyO1xuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVDYWxsZXIoY3R4T3JDYWxsYmFjaywgb3B0cykge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVJlY3Vyc2l2ZVByb3h5KGFzeW5jICh7IHBhdGgsIGFyZ3MgfSkgPT4ge1xuXHRcdFx0XHRjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihcIi5cIik7XG5cdFx0XHRcdGlmIChwYXRoLmxlbmd0aCA9PT0gMSAmJiBwYXRoWzBdID09PSBcIl9kZWZcIikgcmV0dXJuIF9kZWY7XG5cdFx0XHRcdGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChyb3V0ZXIsIGZ1bGxQYXRoKTtcblx0XHRcdFx0bGV0IGN0eCA9IHZvaWQgMDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIXByb2NlZHVyZSkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIk5PVF9GT1VORFwiLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogYE5vIHByb2NlZHVyZSBmb3VuZCBvbiBwYXRoIFwiJHtwYXRofVwiYFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGN0eCA9IGlzRnVuY3Rpb24oY3R4T3JDYWxsYmFjaykgPyBhd2FpdCBQcm9taXNlLnJlc29sdmUoY3R4T3JDYWxsYmFjaygpKSA6IGN0eE9yQ2FsbGJhY2s7XG5cdFx0XHRcdFx0cmV0dXJuIGF3YWl0IHByb2NlZHVyZSh7XG5cdFx0XHRcdFx0XHRwYXRoOiBmdWxsUGF0aCxcblx0XHRcdFx0XHRcdGdldFJhd0lucHV0OiBhc3luYyAoKSA9PiBhcmdzWzBdLFxuXHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0dHlwZTogcHJvY2VkdXJlLl9kZWYudHlwZSxcblx0XHRcdFx0XHRcdHNpZ25hbDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNpZ25hbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRcdHZhciBfb3B0cyRvbkVycm9yLCBfcHJvY2VkdXJlJF9kZWYkdHlwZTtcblx0XHRcdFx0XHRvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCB8fCAoX29wdHMkb25FcnJvciA9IG9wdHMub25FcnJvcikgPT09IG51bGwgfHwgX29wdHMkb25FcnJvciA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3IuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IGFyZ3NbMF0sXG5cdFx0XHRcdFx0XHRwYXRoOiBmdWxsUGF0aCxcblx0XHRcdFx0XHRcdHR5cGU6IChfcHJvY2VkdXJlJF9kZWYkdHlwZSA9IHByb2NlZHVyZSA9PT0gbnVsbCB8fCBwcm9jZWR1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2NlZHVyZS5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9wcm9jZWR1cmUkX2RlZiR0eXBlICE9PSB2b2lkIDAgPyBfcHJvY2VkdXJlJF9kZWYkdHlwZSA6IFwidW5rbm93blwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0dGhyb3cgY2F1c2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH07XG59XG5mdW5jdGlvbiBtZXJnZVJvdXRlcnMoLi4ucm91dGVyTGlzdCkge1xuXHR2YXIgX3JvdXRlckxpc3QkO1xuXHRjb25zdCByZWNvcmQgPSBtZXJnZVdpdGhvdXRPdmVycmlkZXMoe30sIC4uLnJvdXRlckxpc3QubWFwKChyKSA9PiByLl9kZWYucmVjb3JkKSk7XG5cdGNvbnN0IGVycm9yRm9ybWF0dGVyID0gcm91dGVyTGlzdC5yZWR1Y2UoKGN1cnJlbnRFcnJvckZvcm1hdHRlciwgbmV4dFJvdXRlcikgPT4ge1xuXHRcdGlmIChuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAmJiBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlcikge1xuXHRcdFx0aWYgKGN1cnJlbnRFcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlciAmJiBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3Ugc2VlbSB0byBoYXZlIHNldmVyYWwgZXJyb3IgZm9ybWF0dGVyc1wiKTtcblx0XHRcdHJldHVybiBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGN1cnJlbnRFcnJvckZvcm1hdHRlcjtcblx0fSwgZGVmYXVsdEZvcm1hdHRlcik7XG5cdGNvbnN0IHRyYW5zZm9ybWVyID0gcm91dGVyTGlzdC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcblx0XHRpZiAoY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgJiYgY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgIT09IGRlZmF1bHRUcmFuc2Zvcm1lcikge1xuXHRcdFx0aWYgKHByZXYgIT09IGRlZmF1bHRUcmFuc2Zvcm1lciAmJiBwcmV2ICE9PSBjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lcikgdGhyb3cgbmV3IEVycm9yKFwiWW91IHNlZW0gdG8gaGF2ZSBzZXZlcmFsIHRyYW5zZm9ybWVyc1wiKTtcblx0XHRcdHJldHVybiBjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lcjtcblx0XHR9XG5cdFx0cmV0dXJuIHByZXY7XG5cdH0sIGRlZmF1bHRUcmFuc2Zvcm1lcik7XG5cdGNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdXRlckZhY3Rvcnkoe1xuXHRcdGVycm9yRm9ybWF0dGVyLFxuXHRcdHRyYW5zZm9ybWVyLFxuXHRcdGlzRGV2OiByb3V0ZXJMaXN0LmV2ZXJ5KChyKSA9PiByLl9kZWYuX2NvbmZpZy5pc0RldiksXG5cdFx0YWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IHJvdXRlckxpc3QuZXZlcnkoKHIpID0+IHIuX2RlZi5fY29uZmlnLmFsbG93T3V0c2lkZU9mU2VydmVyKSxcblx0XHRpc1NlcnZlcjogcm91dGVyTGlzdC5ldmVyeSgocikgPT4gci5fZGVmLl9jb25maWcuaXNTZXJ2ZXIpLFxuXHRcdCR0eXBlczogKF9yb3V0ZXJMaXN0JCA9IHJvdXRlckxpc3RbMF0pID09PSBudWxsIHx8IF9yb3V0ZXJMaXN0JCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JvdXRlckxpc3QkLl9kZWYuX2NvbmZpZy4kdHlwZXNcblx0fSkocmVjb3JkKTtcblx0cmV0dXJuIHJvdXRlcjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdHJhY2tlZC50c1xuY29uc3QgdHJhY2tlZFN5bWJvbCA9IFN5bWJvbCgpO1xuLyoqXG4qIFByb2R1Y2UgYSB0eXBlZCBzZXJ2ZXItc2VudCBldmVudCBtZXNzYWdlXG4qIEBkZXByZWNhdGVkIHVzZSBgdHJhY2tlZChpZCwgZGF0YSlgIGluc3RlYWRcbiovXG5mdW5jdGlvbiBzc2UoZXZlbnQpIHtcblx0cmV0dXJuIHRyYWNrZWQoZXZlbnQuaWQsIGV2ZW50LmRhdGEpO1xufVxuZnVuY3Rpb24gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlWzJdID09PSB0cmFja2VkU3ltYm9sO1xufVxuLyoqXG4qIEF1dG9tYXRpY2FsbHkgdHJhY2sgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBmcm9tIGEgZ2l2ZW4gaWQgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbG9zdFxuKi9cbmZ1bmN0aW9uIHRyYWNrZWQoaWQsIGRhdGEpIHtcblx0aWYgKGlkID09PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoXCJgaWRgIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZyBhcyBlbXB0eSBzdHJpbmcgaXMgdGhlIHNhbWUgYXMgbm90IHNldHRpbmcgdGhlIGlkIGF0IGFsbFwiKTtcblx0cmV0dXJuIFtcblx0XHRpZCxcblx0XHRkYXRhLFxuXHRcdHRyYWNrZWRTeW1ib2xcblx0XTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBUUlBDRXJyb3IsIGNhbGxQcm9jZWR1cmUsIGNyZWF0ZUNhbGxlckZhY3RvcnksIGNyZWF0ZVJvdXRlckZhY3RvcnksIGRlZmF1bHRGb3JtYXR0ZXIsIGRlZmF1bHRUcmFuc2Zvcm1lciwgZ2V0Q2F1c2VGcm9tVW5rbm93biwgZ2V0RGF0YVRyYW5zZm9ybWVyLCBnZXRQcm9jZWR1cmVBdFBhdGgsIGdldFRSUENFcnJvckZyb21Vbmtub3duLCBpc1RyYWNrZWRFbnZlbG9wZSwgbGF6eSwgbWVyZ2VSb3V0ZXJzLCBzc2UsIHRyYWNrZWQsIHRyYW5zZm9ybVJlc3VsdCwgdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja2VkLUJwNzJqSGlmLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/tracked-Bp72jHif.mjs\n',
      );

      /***/
    },

  /***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs":
    /*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs ***!
  \*******************************************************************************************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPC_ERROR_CODES_BY_KEY: () => (/* binding */ TRPC_ERROR_CODES_BY_KEY),\n/* harmony export */   TRPC_ERROR_CODES_BY_NUMBER: () => (/* binding */ TRPC_ERROR_CODES_BY_NUMBER),\n/* harmony export */   abortSignalsAnyPonyfill: () => (/* binding */ abortSignalsAnyPonyfill),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   mergeWithoutOverrides: () => (/* binding */ mergeWithoutOverrides),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   omitPrototype: () => (/* binding */ omitPrototype),\n/* harmony export */   retryableRpcCodes: () => (/* binding */ retryableRpcCodes),\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n//#region src/unstable-core-do-not-import/rpc/codes.ts\n/**\n* JSON-RPC 2.0 Error codes\n*\n* `-32000` to `-32099` are reserved for implementation-defined server-errors.\n* For tRPC we\'re copying the last digits of HTTP 4XX errors.\n*/\nconst TRPC_ERROR_CODES_BY_KEY = {\n\tPARSE_ERROR: -32700,\n\tBAD_REQUEST: -32600,\n\tINTERNAL_SERVER_ERROR: -32603,\n\tNOT_IMPLEMENTED: -32603,\n\tBAD_GATEWAY: -32603,\n\tSERVICE_UNAVAILABLE: -32603,\n\tGATEWAY_TIMEOUT: -32603,\n\tUNAUTHORIZED: -32001,\n\tPAYMENT_REQUIRED: -32002,\n\tFORBIDDEN: -32003,\n\tNOT_FOUND: -32004,\n\tMETHOD_NOT_SUPPORTED: -32005,\n\tTIMEOUT: -32008,\n\tCONFLICT: -32009,\n\tPRECONDITION_FAILED: -32012,\n\tPAYLOAD_TOO_LARGE: -32013,\n\tUNSUPPORTED_MEDIA_TYPE: -32015,\n\tUNPROCESSABLE_CONTENT: -32022,\n\tTOO_MANY_REQUESTS: -32029,\n\tCLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n\t[-32700]: "PARSE_ERROR",\n\t[-32600]: "BAD_REQUEST",\n\t[-32603]: "INTERNAL_SERVER_ERROR",\n\t[-32001]: "UNAUTHORIZED",\n\t[-32002]: "PAYMENT_REQUIRED",\n\t[-32003]: "FORBIDDEN",\n\t[-32004]: "NOT_FOUND",\n\t[-32005]: "METHOD_NOT_SUPPORTED",\n\t[-32008]: "TIMEOUT",\n\t[-32009]: "CONFLICT",\n\t[-32012]: "PRECONDITION_FAILED",\n\t[-32013]: "PAYLOAD_TOO_LARGE",\n\t[-32015]: "UNSUPPORTED_MEDIA_TYPE",\n\t[-32022]: "UNPROCESSABLE_CONTENT",\n\t[-32029]: "TOO_MANY_REQUESTS",\n\t[-32099]: "CLIENT_CLOSED_REQUEST"\n};\n/**\n* tRPC error codes that are considered retryable\n* With out of the box SSE, the client will reconnect when these errors are encountered\n*/\nconst retryableRpcCodes = [\n\tTRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n\tTRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n\tTRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n\tTRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n\n//#endregion\n//#region src/unstable-core-do-not-import/utils.ts\n/**\n* Ensures there are no duplicate keys when building a procedure.\n* @internal\n*/\nfunction mergeWithoutOverrides(obj1, ...objs) {\n\tconst newObj = Object.assign(Object.create(null), obj1);\n\tfor (const overrides of objs) for (const key in overrides) {\n\t\tif (key in newObj && newObj[key] !== overrides[key]) throw new Error(`Duplicate key ${key}`);\n\t\tnewObj[key] = overrides[key];\n\t}\n\treturn newObj;\n}\n/**\n* Check that value is object\n* @internal\n*/\nfunction isObject(value) {\n\treturn !!value && !Array.isArray(value) && typeof value === "object";\n}\nfunction isFunction(fn) {\n\treturn typeof fn === "function";\n}\n/**\n* Create an object without inheriting anything from `Object.prototype`\n* @internal\n*/\nfunction omitPrototype(obj) {\n\treturn Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === "function" && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n\treturn asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n* Run an IIFE\n*/\nconst run = (fn) => fn();\nfunction noop() {}\nfunction identity(it) {\n\treturn it;\n}\n/**\n* Generic runtime assertion function. Throws, if the condition is not `true`.\n*\n* Can be used as a slightly less dangerous variant of type assertions. Code\n* mistakes would be revealed at runtime then (hopefully during testing).\n*/\nfunction assert(condition, msg = "no additional info") {\n\tif (!condition) throw new Error(`AssertionError: ${msg}`);\n}\nfunction sleep(ms = 0) {\n\treturn new Promise((res) => setTimeout(res, ms));\n}\n/**\n* Ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/\nfunction abortSignalsAnyPonyfill(signals) {\n\tif (typeof AbortSignal.any === "function") return AbortSignal.any(signals);\n\tconst ac = new AbortController();\n\tfor (const signal of signals) {\n\t\tif (signal.aborted) {\n\t\t\ttrigger();\n\t\t\tbreak;\n\t\t}\n\t\tsignal.addEventListener("abort", trigger, { once: true });\n\t}\n\treturn ac.signal;\n\tfunction trigger() {\n\t\tac.abort();\n\t\tfor (const signal of signals) signal.removeEventListener("abort", trigger);\n\t}\n}\n\n//#endregion\n\n//# sourceMappingURL=utils-DdbbrDku.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjUuMF90eXBlc2NyaXB0QDUuOS4yL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC91dGlscy1EZGJickRrdS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzROO0FBQzVOIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNlZ2d1XFxMRVNpQUJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB0cnBjK3NlcnZlckAxMS41LjBfdHlwZXNjcmlwdEA1LjkuMlxcbm9kZV9tb2R1bGVzXFxAdHJwY1xcc2VydmVyXFxkaXN0XFx1dGlscy1EZGJickRrdS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcnBjL2NvZGVzLnRzXG4vKipcbiogSlNPTi1SUEMgMi4wIEVycm9yIGNvZGVzXG4qXG4qIGAtMzIwMDBgIHRvIGAtMzIwOTlgIGFyZSByZXNlcnZlZCBmb3IgaW1wbGVtZW50YXRpb24tZGVmaW5lZCBzZXJ2ZXItZXJyb3JzLlxuKiBGb3IgdFJQQyB3ZSdyZSBjb3B5aW5nIHRoZSBsYXN0IGRpZ2l0cyBvZiBIVFRQIDRYWCBlcnJvcnMuXG4qL1xuY29uc3QgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkgPSB7XG5cdFBBUlNFX0VSUk9SOiAtMzI3MDAsXG5cdEJBRF9SRVFVRVNUOiAtMzI2MDAsXG5cdElOVEVSTkFMX1NFUlZFUl9FUlJPUjogLTMyNjAzLFxuXHROT1RfSU1QTEVNRU5URUQ6IC0zMjYwMyxcblx0QkFEX0dBVEVXQVk6IC0zMjYwMyxcblx0U0VSVklDRV9VTkFWQUlMQUJMRTogLTMyNjAzLFxuXHRHQVRFV0FZX1RJTUVPVVQ6IC0zMjYwMyxcblx0VU5BVVRIT1JJWkVEOiAtMzIwMDEsXG5cdFBBWU1FTlRfUkVRVUlSRUQ6IC0zMjAwMixcblx0Rk9SQklEREVOOiAtMzIwMDMsXG5cdE5PVF9GT1VORDogLTMyMDA0LFxuXHRNRVRIT0RfTk9UX1NVUFBPUlRFRDogLTMyMDA1LFxuXHRUSU1FT1VUOiAtMzIwMDgsXG5cdENPTkZMSUNUOiAtMzIwMDksXG5cdFBSRUNPTkRJVElPTl9GQUlMRUQ6IC0zMjAxMixcblx0UEFZTE9BRF9UT09fTEFSR0U6IC0zMjAxMyxcblx0VU5TVVBQT1JURURfTUVESUFfVFlQRTogLTMyMDE1LFxuXHRVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IC0zMjAyMixcblx0VE9PX01BTllfUkVRVUVTVFM6IC0zMjAyOSxcblx0Q0xJRU5UX0NMT1NFRF9SRVFVRVNUOiAtMzIwOTlcbn07XG5jb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiA9IHtcblx0Wy0zMjcwMF06IFwiUEFSU0VfRVJST1JcIixcblx0Wy0zMjYwMF06IFwiQkFEX1JFUVVFU1RcIixcblx0Wy0zMjYwM106IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG5cdFstMzIwMDFdOiBcIlVOQVVUSE9SSVpFRFwiLFxuXHRbLTMyMDAyXTogXCJQQVlNRU5UX1JFUVVJUkVEXCIsXG5cdFstMzIwMDNdOiBcIkZPUkJJRERFTlwiLFxuXHRbLTMyMDA0XTogXCJOT1RfRk9VTkRcIixcblx0Wy0zMjAwNV06IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIixcblx0Wy0zMjAwOF06IFwiVElNRU9VVFwiLFxuXHRbLTMyMDA5XTogXCJDT05GTElDVFwiLFxuXHRbLTMyMDEyXTogXCJQUkVDT05ESVRJT05fRkFJTEVEXCIsXG5cdFstMzIwMTNdOiBcIlBBWUxPQURfVE9PX0xBUkdFXCIsXG5cdFstMzIwMTVdOiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0Wy0zMjAyMl06IFwiVU5QUk9DRVNTQUJMRV9DT05URU5UXCIsXG5cdFstMzIwMjldOiBcIlRPT19NQU5ZX1JFUVVFU1RTXCIsXG5cdFstMzIwOTldOiBcIkNMSUVOVF9DTE9TRURfUkVRVUVTVFwiXG59O1xuLyoqXG4qIHRSUEMgZXJyb3IgY29kZXMgdGhhdCBhcmUgY29uc2lkZXJlZCByZXRyeWFibGVcbiogV2l0aCBvdXQgb2YgdGhlIGJveCBTU0UsIHRoZSBjbGllbnQgd2lsbCByZWNvbm5lY3Qgd2hlbiB0aGVzZSBlcnJvcnMgYXJlIGVuY291bnRlcmVkXG4qL1xuY29uc3QgcmV0cnlhYmxlUnBjQ29kZXMgPSBbXG5cdFRSUENfRVJST1JfQ09ERVNfQllfS0VZLkJBRF9HQVRFV0FZLFxuXHRUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5TRVJWSUNFX1VOQVZBSUxBQkxFLFxuXHRUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5HQVRFV0FZX1RJTUVPVVQsXG5cdFRSUENfRVJST1JfQ09ERVNfQllfS0VZLklOVEVSTkFMX1NFUlZFUl9FUlJPUlxuXTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC91dGlscy50c1xuLyoqXG4qIEVuc3VyZXMgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZSBrZXlzIHdoZW4gYnVpbGRpbmcgYSBwcm9jZWR1cmUuXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIG1lcmdlV2l0aG91dE92ZXJyaWRlcyhvYmoxLCAuLi5vYmpzKSB7XG5cdGNvbnN0IG5ld09iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqMSk7XG5cdGZvciAoY29uc3Qgb3ZlcnJpZGVzIG9mIG9ianMpIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlcykge1xuXHRcdGlmIChrZXkgaW4gbmV3T2JqICYmIG5ld09ialtrZXldICE9PSBvdmVycmlkZXNba2V5XSkgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUga2V5ICR7a2V5fWApO1xuXHRcdG5ld09ialtrZXldID0gb3ZlcnJpZGVzW2tleV07XG5cdH1cblx0cmV0dXJuIG5ld09iajtcbn1cbi8qKlxuKiBDaGVjayB0aGF0IHZhbHVlIGlzIG9iamVjdFxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCI7XG59XG4vKipcbiogQ3JlYXRlIGFuIG9iamVjdCB3aXRob3V0IGluaGVyaXRpbmcgYW55dGhpbmcgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWBcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gb21pdFByb3RvdHlwZShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqKTtcbn1cbmNvbnN0IGFzeW5jSXRlcmF0b3JzU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmICEhU3ltYm9sLmFzeW5jSXRlcmF0b3I7XG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUodmFsdWUpIHtcblx0cmV0dXJuIGFzeW5jSXRlcmF0b3JzU3VwcG9ydGVkICYmIGlzT2JqZWN0KHZhbHVlKSAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZTtcbn1cbi8qKlxuKiBSdW4gYW4gSUlGRVxuKi9cbmNvbnN0IHJ1biA9IChmbikgPT4gZm4oKTtcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gaWRlbnRpdHkoaXQpIHtcblx0cmV0dXJuIGl0O1xufVxuLyoqXG4qIEdlbmVyaWMgcnVudGltZSBhc3NlcnRpb24gZnVuY3Rpb24uIFRocm93cywgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgYHRydWVgLlxuKlxuKiBDYW4gYmUgdXNlZCBhcyBhIHNsaWdodGx5IGxlc3MgZGFuZ2Vyb3VzIHZhcmlhbnQgb2YgdHlwZSBhc3NlcnRpb25zLiBDb2RlXG4qIG1pc3Rha2VzIHdvdWxkIGJlIHJldmVhbGVkIGF0IHJ1bnRpbWUgdGhlbiAoaG9wZWZ1bGx5IGR1cmluZyB0ZXN0aW5nKS5cbiovXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cgPSBcIm5vIGFkZGl0aW9uYWwgaW5mb1wiKSB7XG5cdGlmICghY29uZGl0aW9uKSB0aHJvdyBuZXcgRXJyb3IoYEFzc2VydGlvbkVycm9yOiAke21zZ31gKTtcbn1cbmZ1bmN0aW9uIHNsZWVwKG1zID0gMCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIG1zKSk7XG59XG4vKipcbiogUG9ueWZpbGwgZm9yXG4qIFtgQWJvcnRTaWduYWwuYW55YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsL2FueV9zdGF0aWMpLlxuKi9cbmZ1bmN0aW9uIGFib3J0U2lnbmFsc0FueVBvbnlmaWxsKHNpZ25hbHMpIHtcblx0aWYgKHR5cGVvZiBBYm9ydFNpZ25hbC5hbnkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIEFib3J0U2lnbmFsLmFueShzaWduYWxzKTtcblx0Y29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cdGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHMpIHtcblx0XHRpZiAoc2lnbmFsLmFib3J0ZWQpIHtcblx0XHRcdHRyaWdnZXIoKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRyaWdnZXIsIHsgb25jZTogdHJ1ZSB9KTtcblx0fVxuXHRyZXR1cm4gYWMuc2lnbmFsO1xuXHRmdW5jdGlvbiB0cmlnZ2VyKCkge1xuXHRcdGFjLmFib3J0KCk7XG5cdFx0Zm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0cmlnZ2VyKTtcblx0fVxufVxuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IFRSUENfRVJST1JfQ09ERVNfQllfS0VZLCBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiwgYWJvcnRTaWduYWxzQW55UG9ueWZpbGwsIGFzc2VydCwgaWRlbnRpdHksIGlzQXN5bmNJdGVyYWJsZSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIG1lcmdlV2l0aG91dE92ZXJyaWRlcywgbm9vcCwgb21pdFByb3RvdHlwZSwgcmV0cnlhYmxlUnBjQ29kZXMsIHJ1biwgc2xlZXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLURkYmJyRGt1Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.5.0_typescript@5.9.2/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\n',
      );

      /***/
    },
};
